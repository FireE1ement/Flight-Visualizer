<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Flight Visualizer - B737 NG PFD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: #0f172a;
      color:#fff;
      overflow:auto;
    }
    #app {
      width:100vw;
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    header {
      padding:12px 20px;
      background:#020617;
      border-bottom:1px solid #1e293b;
      display:flex;
      align-items:center;
      gap:12px;
    }
    header h1 { font-size:20px; font-weight:600; }
    
    #content {
      flex:1;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding:10px;
      min-height:0;
    }
    .panel {
      background:#020617;
      border:1px solid #1e293b;
      border-radius:8px;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .panel-title {
      font-size:13px;
      padding:6px 12px;
      border-bottom:1px solid #1e293b;
      background:#030712;
      text-transform:uppercase;
      letter-spacing:0.05em;
      color:#94a3b8;
      font-weight:600;
    }
    .panel-body {
      flex:1;
      position:relative;
      display:flex;
      flex-direction:column;
    }
    
    /* PFD –≤—Å–µ–≥–¥–∞ —Å–ª–µ–≤–∞ */
    #panel-pfd {
      grid-column:1;
      grid-row:1;
    }
    
    /* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ */
    #panel-views {
      grid-column:2;
      grid-row:1;
    }
    
    /* –í–∫–ª–∞–¥–∫–∏ */
    .tabs {
      display:flex;
      background:#030712;
      border-bottom:1px solid #1e293b;
    }
    .tab-btn {
      flex:1;
      padding:8px 12px;
      background:transparent;
      border:none;
      border-right:1px solid #1e293b;
      color:#94a3b8;
      font-size:12px;
      cursor:pointer;
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:0.05em;
      font-weight:600;
    }
    .tab-btn:last-child { border-right:none; }
    .tab-btn:hover { background:#1e293b; }
    .tab-btn.active {
      background:#1e40af;
      color:#fff;
    }
    
    .tab-content {
      display:none;
      flex:1;
      position:relative;
    }
    .tab-content.active {
      display:flex;
    }
    
    canvas {
      width:100%;
      height:100%;
      display:block;
    }

    #controls {
      padding:10px 16px;
      border-top:1px solid #1e293b;
      background:#020617;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    button {
      background:#1e293b;
      color:#e2e8f0;
      border:1px solid #334155;
      border-radius:5px;
      padding:6px 12px;
      font-size:13px;
      cursor:pointer;
      transition:all 0.2s;
      font-weight:500;
    }
    button:hover { border-color:#60a5fa; background:#334155; }
    button:disabled { opacity:0.3; cursor:not-allowed; }
    button.active {
      background:#1d4ed8;
      border-color:#60a5fa;
      color:#fff;
    }
    #file-input { display:none; }
    #timeline {
      flex:1;
      appearance:none;
      height:7px;
      background:#1e293b;
      border-radius:999px;
      outline:none;
      min-width:200px;
    }
    #timeline::-webkit-slider-thumb {
      appearance:none;
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      box-shadow:0 0 8px rgba(96,165,250,0.6);
      cursor:pointer;
    }
    #timeline::-moz-range-thumb {
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      border:none;
      cursor:pointer;
    }
    .time-label {
      font-family:"Consolas","Courier New",monospace;
      font-size:13px;
      min-width:100px;
      text-align:right;
      color:#cbd5e1;
    }
    #loading {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.8);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100;
    }
    #loading-inner {
      background:#020617;
      border:1px solid #475569;
      border-radius:10px;
      padding:20px 32px;
      text-align:center;
      font-size:15px;
    }
    #loading-inner div {
      width:40px; height:40px;
      border-radius:50%;
      border:4px solid #475569;
      border-top-color:#60a5fa;
      margin:0 auto 12px;
      animation:spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform:rotate(360deg); }
    }
    .toggle-label {
      display:flex; align-items:center; gap:6px;
      font-size:13px;
      color:#cbd5e1;
    }
    input[type="checkbox"] {
      width:16px; height:16px;
      cursor:pointer;
    }
    .control-group {
      display:flex;
      gap:6px;
      align-items:center;
    }
    .divider {
      width:1px;
      height:24px;
      background:#334155;
      margin:0 4px;
    }
    @media(max-width:1200px){
      #content {
        grid-template-columns:1fr;
        grid-template-rows: auto auto;
      }
      #panel-pfd { grid-column:1; grid-row:1; min-height:400px; }
      #panel-views { grid-column:1; grid-row:2; min-height:400px; }
    }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>‚úàÔ∏è Flight Visualizer ‚Äì B737 NG PFD & Trajectory</h1>
  </header>

  <div id="content">
    <!-- PFD —Å–ª–µ–≤–∞ -->
    <div class="panel" id="panel-pfd">
      <div class="panel-title">Primary Flight Display</div>
      <div class="panel-body">
        <canvas id="canvas-pfd"></canvas>
      </div>
    </div>

    <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ -->
    <div class="panel" id="panel-views">
      <div class="tabs">
        <button class="tab-btn active" data-tab="tab-3d">3D –°–∞–º–æ–ª—ë—Ç</button>

      </div>
      <div class="panel-body">
        <div class="tab-content active" id="tab-3d">
          <canvas id="canvas-3d"></canvas>
        </div>
        <div class="tab-content" id="tab-side">
          <canvas id="canvas-side"></canvas>
        </div>
        <div class="tab-content" id="tab-top">
          <canvas id="canvas-top"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="controls">
 <!-- –ù–û–í–û–ï: –ø–æ–ª–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ -->
  <label style="color:#cbd5e1; font-size:13px; display:flex; align-items:center; gap:6px;">
    RWY HDG:
    <input type="number" id="input-hdg" min="0" max="360" value="0" 
           style="width:70px; padding:4px 8px; background:#1e293b; border:1px solid #475569; 
                  border-radius:4px; color:#e879f9; font-size:14px; font-weight:bold; text-align:center;">
  </label>
  
  <div class="divider"></div>

    <button id="btn-load" onclick="loadFile()">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</button>
    <input type="file" id="file-input" accept=".xlsx,.xls">

    <div class="divider"></div>

    <button id="btn-play" onclick="togglePlay()" disabled>‚ñ∂Ô∏è Play</button>
    <button id="btn-stop" onclick="stopPlayback()" disabled>‚èπ Stop</button>

    <div class="divider"></div>

    <button onclick="skipTime(-10)" id="btn-b10" disabled>‚èÆ -10s</button>
    <button onclick="skipTime(-1)"  id="btn-b1"  disabled>‚è™ -1s</button>
    <input type="range" id="timeline" min="0" max="100" value="0" disabled>
    <button onclick="skipTime(1)"  id="btn-f1"  disabled>+1s ‚è©</button>
    <button onclick="skipTime(10)" id="btn-f10" disabled>+10s ‚è≠</button>

    <span class="time-label" id="time-label">00:00 / 00:00</span>

    <div class="divider"></div>

    <label class="toggle-label">
      <input type="checkbox" id="chk-gs" checked onchange="toggleGsCorridor()">
      <span>–ö—É—Ä—Å/–≥–ª–∏—Å—Å–∞–¥–∞ (3D)</span>
    </label>

    <label class="toggle-label">
  	<input type="checkbox" id="chk-path" onchange="togglePath()">
 	 <span>–ü—É—Ç—å</span>
    </label>

    <div class="divider"></div>

    <span style="color:#cbd5e1; font-size:13px;">–°–∫–æ—Ä–æ—Å—Ç—å:</span>
    <div class="control-group">
      <button onclick="setSpeed(0.5)">0.5√ó</button>
      <button onclick="setSpeed(1)" class="active" id="speed-1x">1√ó</button>
      <button onclick="setSpeed(2)">2√ó</button>
      <button onclick="setSpeed(4)">4√ó</button>
    </div>
  </div>
</div>

<div id="loading">
  <div id="loading-inner">
    <div></div>
    <div>–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö‚Ä¶</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script> 

// ================================================================
// –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
// ================================================================
const FPS = 32;
const FRAME_MS = 1000 / FPS;
const GS_ANGLE_DEG = 3; // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –≥–ª–∏—Å—Å–∞–¥–∞
const HEIGHT_PER_NM = 300; // ft –Ω–∞ 1 –º–æ—Ä—Å–∫—É—é –º–∏–ª—é –ø—Ä–∏ 3¬∞

let selectedHeading = 263;
let flightData = [];
let totalFrames = 0;
let currentFrame = 0;
let isPlaying = false;
let playbackSpeed = 1;
let timerId = null;

let lastWindUpdateMs = 0;
let cachedWindDir = 0;
let cachedWindSpd = 0;

// three.js
let scene, renderer, camera3d, airplane3d, runwayMesh, gsPlane, locPlane;
let gsVisible = true;
let orbitControls;
let pathLine = null;
let pathPoints = [];
let showPath = false;

// canvas
let pfdCanvas, pfdCtx;
let sideCanvas, sideCtx;
let topCanvas, topCtx;

// –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø—É—Ç–∏
let pathMeta = {
  totalDistanceNM: 10, // –±—É–¥–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
};

// ================================================================
// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
// ================================================================
window.addEventListener("load", () => {
  init3D();
  initPFD();
  initSideView();
  initTopView();
  initTimeline();
  initTabs();
  initSelectedHeading();
});

// -------------------------------------------------
// –í–∫–ª–∞–¥–∫–∏
// -------------------------------------------------
function initTabs() {
  const btns = document.querySelectorAll(".tab-btn");
  btns.forEach(btn => {
    btn.addEventListener("click", () => {
      const target = btn.dataset.tab;
      btns.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));
      document.getElementById(target).classList.add("active");
      
      // –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∫–ª–∞–¥–∫–∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º, –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
      if (flightData.length) {
        resize3D();
        resizeSide();
        resizeTop();
        updateAllViews();
      }
    });
  });
}

// -------------------------------------------------
// 3D —Å—Ü–µ–Ω–∞
// -------------------------------------------------
// ================================================================
// 3D –°–¶–ï–ù–ê - –ü–û–õ–ù–ê–Ø –ü–ï–†–ï–î–ï–õ–ö–ê
// ================================================================

function init3D() {
  const canvas = document.getElementById("canvas-3d");
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ç–µ–Ω–∏
  resize3D();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏: —Ç—É–º–∞–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 2000–º, –ø–æ–ª–Ω–∞—è –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ 8000–º
  scene.fog = new THREE.Fog(0x87ceeb, 2000, 8000);

  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(500, 800, 300); // –ø–æ–¥–Ω–∏–º–∞–µ–º –≤—ã—à–µ –∏ –¥–∞–ª—å—à–µ
  sun.castShadow = true;
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –æ–±–ª–∞—Å—Ç—å —Ç–µ–Ω–µ–π –¥–ª—è –ø–æ–∫—Ä—ã—Ç–∏—è –≤—Å–µ–π –ø–æ–ª–æ—Å—ã
  sun.shadow.camera.left = -2000;
  sun.shadow.camera.right = 2000;
  sun.shadow.camera.top = 2000;
  sun.shadow.camera.bottom = -2000;
  sun.shadow.camera.near = 100;
  sun.shadow.camera.far = 3000;
  sun.shadow.mapSize.width = 4096; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ç–µ–Ω–µ–π
  sun.shadow.mapSize.height = 4096;
  sun.shadow.bias = -0.0001; // —É—Å—Ç—Ä–∞–Ω—è–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Ç–µ–Ω–µ–π
  
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

  camera3d = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
  camera3d.position.set(0, 50, 100);

  // OrbitControls –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
orbitControls = new THREE.OrbitControls(camera3d, canvas);
orbitControls.enableDamping = false;
orbitControls.enablePan = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
orbitControls.minDistance = 10;
orbitControls.maxDistance = 1000;
orbitControls.maxPolarAngle = Math.PI / 2 + 0.3;
orbitControls.autoRotate = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–ø–æ–≤–æ—Ä–æ—Ç



  createGround();
  createRunway();
  createGlideSlopeCorridor();
  createAirplane();

  window.addEventListener("resize", resize3D);

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º resize –ø–æ—Å–ª–µ –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
  // —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ–ª—É—á–∏–ª —Å–≤–æ–∏ —Ä–∞–∑–º–µ—Ä—ã
    setTimeout(() => {
    resize3D();
  }, 100);

  // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è controls
  animate3D();
}

function createGround() {
  // –ó–µ–º–ª—è: 20000√ó20000 –º–µ—Ç—Ä–æ–≤ —Å –æ—Ç–∫–ª—é—á–µ–Ω–Ω–æ–π –∑–∞–ø–∏—Å—å—é –≤ –±—É—Ñ–µ—Ä –≥–ª—É–±–∏–Ω—ã
  const groundGeom = new THREE.PlaneGeometry(20000, 20000);
  const groundMat = new THREE.MeshLambertMaterial({ 
    color: 0x228b22,
    depthWrite: false  // –æ—Ç–∫–ª—é—á–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±—É—Ñ–µ—Ä –≥–ª—É–±–∏–Ω—ã
  });
  const ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.1; // –æ–ø—É—Å–∫–∞–µ–º –∑–µ–º–ª—é –Ω–∏–∂–µ
  ground.receiveShadow = true;
  ground.renderOrder = 0; // —Ä–µ–Ω–¥–µ—Ä–∏–º –ø–µ—Ä–≤–æ–π
  scene.add(ground);
}

// –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–ª—è OrbitControls
function animate3D() {
  requestAnimationFrame(animate3D);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å–∞–º–æ–ª—ë—Ç–∞
  if (airplane3d && orbitControls && camera3d) {
    updateCamera();
  }
  
  if (renderer && camera3d && scene) {
    renderer.render(scene, camera3d);
  }
}



function resize3D() {
  const canvas = document.getElementById('canvas-3d');
  const parent = canvas.parentElement;
  if (!parent) return;
  
  const w = parent.clientWidth;
  const h = parent.clientHeight;
  if (!renderer || !camera3d || !w || !h) return;
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π pixel ratio
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(w, h, false);
  
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
}

function createRunway() {
  // –ü–æ–ª–æ—Å–∞ 60–º √ó 3000–º (—Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã)
  const rwGeom = new THREE.PlaneGeometry(60, 3000);
  const rwMat = new THREE.MeshLambertMaterial({ 
    color: 0x3a3a3a,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  runwayMesh = new THREE.Mesh(rwGeom, rwMat);
  runwayMesh.rotation.x = -Math.PI / 2;
  runwayMesh.position.set(0, 0, -1400); // –Ω–∞ —É—Ä–æ–≤–Ω–µ –∑–µ–º–ª–∏
  runwayMesh.receiveShadow = true;
  runwayMesh.renderOrder = 1;
  scene.add(runwayMesh);

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
  const lineMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });
  
  for (let z = 30; z > -2900; z -= 30) {
    const segmentGeom = new THREE.PlaneGeometry(1.2, 20);
    const segment = new THREE.Mesh(segmentGeom, lineMat);
    segment.rotation.x = -Math.PI / 2;
    segment.position.set(0, 0.01, z);
    segment.renderOrder = 2;
    scene.add(segment);
  }

  // –ü–æ—Ä–æ–≥ –í–ü–ü (–∑–µ–±—Ä–∞) –Ω–∞ z = 80
  const thresholdZ = 80;
  const stripeGeom = new THREE.PlaneGeometry(4, 30);
  for (let x = -20; x <= 20; x += 8) {
    const stripe = new THREE.Mesh(stripeGeom, lineMat);
    stripe.rotation.x = -Math.PI / 2;
    stripe.position.set(x, 0.01, thresholdZ);
    stripe.renderOrder = 2;
    scene.add(stripe);
  }

  // –ó–û–ù–ê –ü–†–ò–ó–ï–ú–õ–ï–ù–ò–Ø
  const touchdownZ = -215;
  
  // 1. –ü–µ—Ä–≤–∞—è –ø–∞—Ä–∞ –º–∞–ª–µ–Ω—å–∫–∏—Ö - –∑–∞ 100–º –¥–æ –∫–∞—Å–∞–Ω–∏—è
  const tinyBoxGeom = new THREE.PlaneGeometry(6, 10);
  [
    { x: -10, z: touchdownZ + 100 }, { x: 10, z: touchdownZ + 100 }
  ].forEach(pos => {
    const box = new THREE.Mesh(tinyBoxGeom, lineMat);
    box.rotation.x = -Math.PI / 2;
    box.position.set(pos.x, 0.01, pos.z);
    box.renderOrder = 2;
    scene.add(box);
  });

  // 2. –ë–û–õ–¨–®–ò–ï - —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è
  const bigBoxGeom = new THREE.PlaneGeometry(12, 20);
  [
    { x: -15, z: touchdownZ }, { x: 15, z: touchdownZ }
  ].forEach(pos => {
    const box = new THREE.Mesh(bigBoxGeom, lineMat);
    box.rotation.x = -Math.PI / 2;
    box.position.set(pos.x, 0.01, pos.z);
    box.renderOrder = 2;
    scene.add(box);
  });

  // 3. –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞–ª–µ–Ω—å–∫–∏–µ (–∫–∞–∂–¥—ã–µ 150–º –ø–æ—Å–ª–µ –∫–∞—Å–∞–Ω–∏—è)
  const smallBoxGeom = new THREE.PlaneGeometry(8, 12);
  for (let i = 1; i <= 10; i++) {
    const z = touchdownZ - i * 150;
    if (z > -2900) {
      [
        { x: -12, z: z }, { x: 12, z: z }
      ].forEach(pos => {
        const box = new THREE.Mesh(smallBoxGeom, lineMat);
        box.rotation.x = -Math.PI / 2;
        box.position.set(pos.x, 0.01, pos.z);
        box.renderOrder = 2;
        scene.add(box);
      });
    }
  }

  // –ë–æ–∫–æ–≤—ã–µ –ø–æ–ª–æ—Å—ã
  const sideGeom = new THREE.PlaneGeometry(0.8, 3000);
  [-28, 28].forEach(x => {
    const side = new THREE.Mesh(sideGeom, lineMat);
    side.rotation.x = -Math.PI / 2;
    side.position.set(x, 0.01, -1400);
    side.renderOrder = 2;
    scene.add(side);
  });

  // –ù–æ–º–µ—Ä –í–ü–ü - –±–ª–∏–∂–µ –∫ –∑–µ–±—Ä–µ
  createRunwayNumber(50);
}


function createRunwayNumber(z) {
  const canvas = document.createElement('canvas');
  canvas.width = 512; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 180px Arial'; // —É–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–º–µ—Ä –í–ü–ü –∏–∑ selectedHeading
  const runwayNumber = Math.round(selectedHeading / 10) % 36;
  const displayNumber = runwayNumber === 0 ? 36 : runwayNumber;
  
  ctx.fillText(displayNumber.toString().padStart(2, '0'), 256, 128);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  
  const numMat = new THREE.MeshBasicMaterial({ 
    map: texture, 
    transparent: true,
    depthWrite: true,
    side: THREE.DoubleSide,
    polygonOffset: true,
    polygonOffsetFactor: -3,
    polygonOffsetUnits: -3
  });
  
  const numGeom = new THREE.PlaneGeometry(50, 25);
  
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –Ω–æ–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å
  const oldNumber = scene.getObjectByName('runwayNumber');
  if (oldNumber) scene.remove(oldNumber);
  
  const number = new THREE.Mesh(numGeom, numMat);
  number.rotation.x = -Math.PI / 2;
  number.position.set(0, 0.02, z); // —á—É—Ç—å –ø—Ä–∏–ø–æ–¥–Ω—è—Ç–æ –Ω–∞–¥ –ø–æ–ª–æ—Å–æ–π
  number.name = 'runwayNumber';
  number.renderOrder = 3; // —Ä–µ–Ω–¥–µ—Ä–∏–º –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
  scene.add(number);
}

function createGlideSlopeCorridor() {
  const corridorGroup = new THREE.Group();
  corridorGroup.visible = true;

  // –ì–õ–ò–°–°–ê–î–ê (—Ä–∞—Å—à–∏—Ä—è—é—â–∞—è—Å—è —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å)
  // –ì–ª–∏—Å—Å–∞–¥–∞ 3¬∞ –æ—Ç —Ç–æ—á–∫–∏ –Ω–∞ –≤—ã—Å–æ—Ç–µ ~300–º –¥–æ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const gsAngle = 3 * Math.PI / 180; // 3 –≥—Ä–∞–¥—É—Å–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö
  
  // –¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –Ω–∞ z = -215 (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const touchdownZ = -215;
  
  // –ù–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã: –Ω–∞ –≤—ã—Å–æ—Ç–µ 300–º, —ç—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 300/tan(3¬∞) ‚âà 5730–º –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è
  const gsStartZ = touchdownZ + 5730; // ‚âà 5515
  const gsEndZ = touchdownZ; // —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è
  const gsStartHeight = 300; // –Ω–∞—á–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ 300–º
  const gsEndHeight = 0; // –≤—ã—Å–æ—Ç–∞ –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  
  const gsLength = gsStartZ - gsEndZ; // –¥–ª–∏–Ω–∞ –ø—Ä–æ–µ–∫—Ü–∏–∏ –Ω–∞ –∑–µ–º–ª—é
  const gsWidthStart = 300; // —à–∏—Ä–∏–Ω–∞ –≤ –Ω–∞—á–∞–ª–µ (—Ä–∞—Å—à–∏—Ä–µ–Ω–∞)
  const gsWidthEnd = 60; // —à–∏—Ä–∏–Ω–∞ –≤ –∫–æ–Ω—Ü–µ (—à–∏—Ä–∏–Ω–∞ –ø–æ–ª–æ—Å—ã)
  
  // –°–æ–∑–¥–∞—ë–º —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω—É—é –≥–µ–æ–º–µ—Ç—Ä–∏—é
  const gsGeom = new THREE.BufferGeometry();
  
  // –í–µ—Ä—à–∏–Ω—ã —Ç—Ä–∞–ø–µ—Ü–∏–∏ (4 —É–≥–ª–∞)
  const vertices = new Float32Array([
    // –ù–∏–∂–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (—É —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è, z = 0 –≤ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
    -gsWidthEnd/2, -gsLength/2, 0,  // –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π
    gsWidthEnd/2, -gsLength/2, 0,   // –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π
    
    // –í–µ—Ä—Ö–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (–≤ –Ω–∞—á–∞–ª–µ –≥–ª–∏—Å—Å–∞–¥—ã, z = gsLength/2)
    -gsWidthStart/2, gsLength/2, 0, // –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
    gsWidthStart/2, gsLength/2, 0   // –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
  ]);
  
  // –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤, –æ–±—Ä–∞–∑—É—é—â–∏—Ö —Ç—Ä–∞–ø–µ—Ü–∏—é
  const indices = new Uint16Array([
    0, 1, 2,  // –ø–µ—Ä–≤—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
    1, 3, 2   // –≤—Ç–æ—Ä–æ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
  ]);
  
  gsGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  gsGeom.setIndex(new THREE.BufferAttribute(indices, 1));
  gsGeom.computeVertexNormals();
  
  const gsMat = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.05,
    side: THREE.DoubleSide,
    depthWrite: false
  });

  gsPlane = new THREE.Mesh(gsGeom, gsMat);
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≥–ª–∏—Å—Å–∞–¥—É
  const gsCenterZ = (gsStartZ + gsEndZ) / 2;
  const gsCenterHeight = (gsStartHeight + gsEndHeight) / 2;
  
  gsPlane.position.set(0, gsCenterHeight, gsCenterZ);
  gsPlane.rotation.x = Math.PI / 2 - gsAngle; // –Ω–∞–∫–ª–æ–Ω –Ω–∞ 3¬∞
  
  corridorGroup.add(gsPlane);

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è –≥–ª–∏—Å—Å–∞–¥—ã –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫—É—Ä—Å–∞
  const gsLineGeometry = new THREE.BufferGeometry();
  const gsLineVertices = new Float32Array([
    0, gsStartHeight, gsStartZ,  // –Ω–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã
    0, gsEndHeight, gsEndZ       // –∫–æ–Ω–µ—Ü –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  ]);
  gsLineGeometry.setAttribute('position', new THREE.BufferAttribute(gsLineVertices, 3));
  
  const gsLineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 3,
    transparent: true,
    opacity: 0.5
  });
  
  const gsLine = new THREE.Line(gsLineGeometry, gsLineMaterial);
  corridorGroup.add(gsLine);

  // –ë–æ–∫–æ–≤—ã–µ –ª–∏–Ω–∏–∏ —Ç—Ä–∞–ø–µ—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏—Ü
  const leftBorder = new THREE.BufferGeometry();
  const leftVertices = new Float32Array([
    -gsWidthEnd/2, gsEndHeight, gsEndZ,
    -gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  leftBorder.setAttribute('position', new THREE.BufferAttribute(leftVertices, 3));
  
  const borderMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 2,
    transparent: true,
    opacity: 0.2
  });
  
  const leftBorderLine = new THREE.Line(leftBorder, borderMaterial);
  corridorGroup.add(leftBorderLine);

  const rightBorder = new THREE.BufferGeometry();
  const rightVertices = new Float32Array([
    gsWidthEnd/2, gsEndHeight, gsEndZ,
    gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  rightBorder.setAttribute('position', new THREE.BufferAttribute(rightVertices, 3));
  
  const rightBorderLine = new THREE.Line(rightBorder, borderMaterial.clone());
  corridorGroup.add(rightBorderLine);

  scene.add(corridorGroup);
  locPlane = corridorGroup;
}

function createAirplane() {
  airplane3d = new THREE.Group();
  
  // –§—é–∑–µ–ª—è–∂ - —Ç–æ–ª—â–µ, —á—Ç–æ–±—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –æ—Å–Ω–æ–≤–∞–Ω–∏—é –∫–æ–Ω—É—Å–∞
  const bodyGeom = new THREE.CylinderGeometry(2.0, 2, 25, 16); // —É–≤–µ–ª–∏—á–µ–Ω —Ä–∞–¥–∏—É—Å
  const bodyMat = new THREE.MeshPhongMaterial({ color: 0xe5e5e5 });
  const body = new THREE.Mesh(bodyGeom, bodyMat);
  body.rotation.z = Math.PI / 2; // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ –≤–¥–æ–ª—å X
  body.scale.set(1, 1, 0.75); // —Å–ø–ª—é—Å–Ω—É—Ç –ø–æ –≤—ã—Å–æ—Ç–µ (Z –ø–æ—Å–ª–µ –ø–æ–≤–æ—Ä–æ—Ç–∞)
  body.castShadow = true;
  airplane3d.add(body);

  // –ù–æ—Å - –ø—Ä–∏–ø–ª—é—Å–Ω—É—Ç—ã–π –∫–æ–Ω—É—Å, —Å–æ–≤–ø–∞–¥–∞—é—â–∏–π –ø–æ –¥–∏–∞–º–µ—Ç—Ä—É —Å —Ñ—é–∑–µ–ª—è–∂–µ–º
  const noseGeom = new THREE.ConeGeometry(2.0, 2.5, 16); // —Ä–∞–¥–∏—É—Å —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–µ—Ä–µ–¥–Ω–µ–π —á–∞—Å—Ç—å—é —Ñ—é–∑–µ–ª—è–∂–∞
  const nose = new THREE.Mesh(noseGeom, bodyMat);
  nose.rotation.z = -Math.PI / 2;
  nose.position.x = 13.75;
  nose.scale.set(1, 1, 0.75); // —Å–ø–ª—é—Å–Ω—É—Ç –ø–æ –≤—ã—Å–æ—Ç–µ (Z)
  nose.castShadow = true;
  airplane3d.add(nose);

  // –ö—Ä—ã–ª—å—è - —à–∏—Ä–æ–∫–∏–µ –∏ –ø–ª–æ—Å–∫–∏–µ
  const wingGeom = new THREE.BoxGeometry(6, 0.5, 30); // –Ω–µ–º–Ω–æ–≥–æ —É–≤–µ–ª–∏—á–µ–Ω—ã –¥–ª—è –ø—Ä–æ–ø–æ—Ä—Ü–∏–π
  const wingMat = new THREE.MeshPhongMaterial({ color: 0xb0b0b0 });
  const wings = new THREE.Mesh(wingGeom, wingMat);
  wings.position.x = -2;
  wings.castShadow = true;
  airplane3d.add(wings);

  // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –æ–ø–µ—Ä–µ–Ω–∏–µ
  const vtailGeom = new THREE.BoxGeometry(4, 5, 0.6);
  const vtail = new THREE.Mesh(vtailGeom, wingMat);
  vtail.position.set(-10, 2.5, 0);
  vtail.castShadow = true;
  airplane3d.add(vtail);

  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ–ø–µ—Ä–µ–Ω–∏–µ
  const htailGeom = new THREE.BoxGeometry(4, 0.4, 10);
  const htail = new THREE.Mesh(htailGeom, wingMat);
  htail.position.set(-10, 0.5, 0);
  htail.castShadow = true;
  airplane3d.add(htail);

  // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è
  airplane3d.position.set(0, 3, -255);
  airplane3d.rotation.y = Math.PI / 2;
  airplane3d.castShadow = true;
  scene.add(airplane3d);
}


function toggleGsCorridor() {
  gsVisible = document.getElementById("chk-gs").checked;
  if (locPlane) locPlane.visible = gsVisible;
  if (gsPlane) gsPlane.visible = gsVisible;
  if (renderer && camera3d) renderer.render(scene, camera3d);
}

function togglePath() {
  showPath = document.getElementById('chk-path').checked;
  if (pathLine) {
    pathLine.visible = showPath;
  }
  if (renderer && camera3d) {
    renderer.render(scene, camera3d);
  }
}


function update3D(d) {
  if (!airplane3d) return;
  
  const altitudeFt = d.altitude || 0;
  const altitudeMeters = altitudeFt * 0.3048;
  const distFromTouchdownFt = d.distanceFromTouchdown || 0;
  
  let zPos, yPos;
  
  const zTouchdown = -215;
  const metersFromTouchdown = distFromTouchdownFt * 0.3048;
  
  zPos = zTouchdown - metersFromTouchdown;
  
  const gearHeight = 3;
  yPos = Math.max(gearHeight, altitudeMeters);
  
let xPos = 0;
if (d.locDeviation && altitudeMeters > 1) {
  // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Ä–∞—Å—á–µ—Ç –±–æ–∫–æ–≤–æ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
  // 1 —Ç–æ—á–∫–∞ LOC = 2.5¬∞ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏
  // –ù–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ distNM —ç—Ç–æ –¥–∞–µ—Ç –±–æ–∫–æ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ:
  const distNM = d.distanceToThresholdNM || 0.1;
  const deviationDegrees = d.locDeviation * 2.5; // 1 —Ç–æ—á–∫–∞ = 2.5¬∞
  const deviationRadians = (deviationDegrees * Math.PI) / 180;
  const lateralOffsetNM = Math.tan(deviationRadians) * distNM;
  const lateralOffsetMeters = lateralOffsetNM * 1852; // 1 NM = 1852 –º–µ—Ç—Ä–∞
  xPos = lateralOffsetMeters;
}
airplane3d.position.set(xPos, yPos, zPos);
  
  const runwayHeading = selectedHeading;
  const planeHeading = d.heading || runwayHeading;
  let headingDiff = planeHeading - runwayHeading;
  
  while (headingDiff > 180) headingDiff -= 360;
  while (headingDiff < -180) headingDiff += 360;
  
 const yaw = Math.PI/2 - THREE.MathUtils.degToRad(headingDiff);
const pitch = THREE.MathUtils.degToRad(d.pitch);
const roll = THREE.MathUtils.degToRad(d.roll);

// –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å: —Å–Ω–∞—á–∞–ª–∞ Roll, –ø–æ—Ç–æ–º Pitch, –ø–æ—Ç–æ–º Yaw
const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), roll);
const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitch);
const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

// –ü—Ä–∏–º–µ–Ω—è–µ–º –≤ –ø–æ—Ä—è–¥–∫–µ: Yaw -> Pitch -> Roll (–≤ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
airplane3d.quaternion.copy(qYaw);
airplane3d.quaternion.multiply(qPitch);
airplane3d.quaternion.multiply(qRoll);

  // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏ –ø—É—Ç–∏
  pathPoints.push(new THREE.Vector3(xPos, yPos, zPos));
  
  // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 500)
  if (pathPoints.length > 500) {
    pathPoints.shift();
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–∏ –ø—É—Ç–∏
  if (pathLine) {
    scene.remove(pathLine);
  }
  
  if (pathPoints.length > 1) {
    const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
    const pathMaterial = new THREE.LineBasicMaterial({ 
      color: 0x00ff00, 
      linewidth: 2,
      transparent: true,
      opacity: 0.8
    });
    pathLine = new THREE.Line(pathGeometry, pathMaterial);
    pathLine.visible = showPath;
    scene.add(pathLine);
  }


}


function updateCamera() {
  if (!airplane3d || !orbitControls || !camera3d) return;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Å—Ñ–µ—Ä–∏—á–µ—Å–∫—É—é –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ target
  const spherical = new THREE.Spherical();
  const offset = new THREE.Vector3();
  
  // –í—ã—á–∏—Å–ª—è–µ–º offset –æ—Ç —Å—Ç–∞—Ä–æ–≥–æ target
  offset.copy(camera3d.position).sub(orbitControls.target);
  spherical.setFromVector3(offset);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º target –Ω–∞ –ø–æ–∑–∏—Ü–∏—é —Å–∞–º–æ–ª—ë—Ç–∞
  orbitControls.target.copy(airplane3d.position);
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–æ—Ç –∂–µ offset –∫ –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
  offset.setFromSpherical(spherical);
  camera3d.position.copy(airplane3d.position).add(offset);
  
  // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ —Å–∞–º–æ–ª—ë—Ç
  camera3d.lookAt(airplane3d.position);
}

// ========================================
// PFD - –ê–î–ê–ü–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø
// ========================================

function initPFD() {
  pfdCanvas = document.getElementById('canvas-pfd');
  pfdCtx = pfdCanvas.getContext('2d');
  resizePFD();
  window.addEventListener('resize', resizePFD);
  drawPFD(null);
}

function resizePFD() {
  const rect = pfdCanvas.parentElement.getBoundingClientRect();
  pfdCanvas.width = rect.width;
  pfdCanvas.height = rect.height;
}

// PFD - –≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (–∞–¥–∞–ø—Ç–∏–≤–Ω–∞—è)
function drawPFD(data) {
  const ctx = pfdCtx;
  const w = pfdCanvas.width;
  const h = pfdCanvas.height;
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);
  
  if (!data) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '18px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö', w / 2, h / 2);
    return;
  }
  
  const cx = w / 2;
  const cy = h / 2;
  
  // –ë–∞–∑–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ 600px
  const scale = Math.min(w, h) / 600;
  
  // Top bar

  
  // DME –∏ Wind - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
  const margin = Math.max(10, w * 0.02);
  const topOffset = Math.max(40, h * 0.08);
  drawDME(ctx, margin, topOffset, data, scale);
  drawWindCompact(ctx, w - margin - 100 * scale, topOffset, data, scale);
  
  // Horizon - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä
  const horizonSize = Math.min(w * 0.35, h * 0.4, 250 * scale);
  drawAttitudeFull(ctx, cx, cy, horizonSize, data, scale);
  
  // Speed tape - —Å–ª–µ–≤–∞
  const tapeWidth = Math.max(50, w * 0.11);
  const tapeHeight = Math.min(h * 0.5, 300 * scale);
  drawSpeedTapeFull(ctx, tapeWidth * 0.7, cy, tapeWidth * 0.75, tapeHeight, data, scale);
  
  // Altitude tape - —Å–ø—Ä–∞–≤–∞
  const altTapeWidth = Math.max(60, w * 0.13);
  drawAltitudeTapeFull(ctx, w - altTapeWidth * 1.2, cy, altTapeWidth * 0.7, tapeHeight, data, scale);
  
  // Vertical speed - –∫—Ä–∞–π–Ω—è—è –ø—Ä–∞–≤–∞—è
  const vsWidth = Math.max(25, w * 0.05);
  const vsHeight = Math.min(h * 0.4, 240 * scale);
  drawVerticalSpeedFull(ctx, w - vsWidth * 0.7, cy, vsWidth, vsHeight, data, scale);
  
  // Heading tape - –≤–Ω–∏–∑—É
  const headingY = h - Math.max(70, h * 0.14);
  const headingWidth = Math.min(w * 0.6, 420 * scale);
  const headingHeight = Math.max(50, h * 0.11);
  drawHeadingFull(ctx, cx, headingY, headingWidth, headingHeight, data, scale);
  
  // Radio altitude - –Ω–∞–¥ heading
  const raY = headingY - Math.max(25, h * 0.06);
  drawRadioHeight(ctx, cx, raY, data, scale);
  
  // Status - –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
  drawStatus(ctx, margin, h - margin - 10, data, scale);
}

function drawTopBar(ctx, w, data, scale = 1) {
  ctx.fillStyle = '#4a5568';
  ctx.fillRect(0, 0, w, 30 * scale);
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#10b981';
  ctx.fillText('SINGLE CH', w / 2, 20 * scale);
}

function drawDME(ctx, x, y, data, scale = 1) {
  const distNM = (data.distanceToThresholdNM || 0);
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e0e0e0';
  ctx.textAlign = 'left';
  ctx.fillText('DME', x, y);
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.fillStyle = '#10b981';
  ctx.fillText(distNM.toFixed(1), x, y + 18 * scale);
}

function drawWindCompact(ctx, x, y, data, scale = 1) {
  const windDir = data.windDirection || 0;
  const windSpd = Math.round(data.windSpeed || 0);
  const heading = data.heading || 0;
  
  if (windSpd < 1) return;
  
  let relativeDir = windDir - heading;
  while (relativeDir > 180) relativeDir -= 360;
  while (relativeDir < -180) relativeDir += 360;
  
  const arrowAngle = relativeDir;
  const arrowSize = 11 * scale;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((arrowAngle * Math.PI) / 180);
  ctx.strokeStyle = '#0ea5e9';
  ctx.fillStyle = '#0ea5e9';
  ctx.lineWidth = 2 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -arrowSize);
  ctx.lineTo(0, arrowSize);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, arrowSize);
  ctx.lineTo(-4 * scale, arrowSize - 5 * scale);
  ctx.lineTo(4 * scale, arrowSize - 5 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  
  ctx.fillStyle = '#0ea5e9';
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'left';
  const absDir = Math.round(windDir % 360);
  ctx.fillText(`${absDir.toString().padStart(3, '0')}/${windSpd}KT`, x + 16 * scale, y + 5 * scale);
}

function drawAttitudeFull(ctx, cx, cy, size, data, scale = 1) {
  const pitch = data.pitch;
  const roll = data.roll;
  
  ctx.save();
  const r = size / 2;
  ctx.beginPath();
  ctx.rect(cx - r, cy - r, size, size);
  ctx.clip();
  
  ctx.translate(cx, cy);
  ctx.rotate((-roll * Math.PI) / 180);
  
  const pitchScale = 10 * scale;
  const offset = pitch * pitchScale;
  
  // Sky
  ctx.fillStyle = '#3b82f6';
  ctx.fillRect(-size, -size - offset, size * 2, size);
  
  // Ground
  ctx.fillStyle = '#92400e';
  ctx.fillRect(-size, -offset, size * 2, size);
  
  // Horizon line
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(-size, -offset);
  ctx.lineTo(size, -offset);
  ctx.stroke();
  
  // Pitch lines
  ctx.font = `bold ${Math.round(14 * scale)}px monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  
  // Major lines (10¬∞)
  for (let a = -30; a <= 30; a += 10) {
    if (a === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 65 * scale;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2.5 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
    
    const label = Math.abs(a).toString();
    ctx.fillText(label, -lineW - 22 * scale, y + 5 * scale);
    ctx.fillText(label, lineW + 22 * scale, y + 5 * scale);
  }
  
  // Medium lines (5¬∞)
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  for (let a = -30; a <= 30; a += 5) {
    if (a === 0 || a % 10 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 42 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  // Short lines (2.5¬∞)
  ctx.strokeStyle = '#aaaaaa';
  ctx.lineWidth = 1.5 * scale;
  for (let a = -30; a <= 30; a += 2.5) {
    if (a === 0 || a % 5 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 25 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Aircraft reference symbol
  ctx.strokeStyle = '#fbbf24';
  ctx.fillStyle = '#fbbf24';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - 65 * scale, cy);
  ctx.lineTo(cx - 23 * scale, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 23 * scale, cy);
  ctx.lineTo(cx + 65 * scale, cy);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(cx, cy - 5 * scale);
  ctx.lineTo(cx - 8 * scale, cy + 6 * scale);
  ctx.lineTo(cx + 8 * scale, cy + 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(cx, cy, 3 * scale, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  
  // Roll indicator
  drawRollIndicatorFull(ctx, cx, cy - r - 12 * scale, r * 0.92, roll, scale);
  
  // GS and LOC indicators
  drawGSIndicator(ctx, cx + r + 28 * scale, cy, size * 0.4, data.gsDeviation, scale);
  drawLOCIndicator(ctx, cx, cy + r + 28 * scale, size * 0.4, data.locDeviation, scale);
}

function drawRollIndicatorFull(ctx, cx, cy, radius, roll, scale = 1) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.strokeStyle = '#ffffff';
  ctx.fillStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  
  const marks = [
    { angle: -60, len: 13 * scale, label: '60' },
    { angle: -45, len: 13 * scale, label: '45' },
    { angle: -30, len: 13 * scale, label: '30' },
    { angle: -20, len: 8 * scale, label: null },
    { angle: -10, len: 8 * scale, label: '10' },
    { angle: 0, len: 13 * scale, label: '0' },
    { angle: 10, len: 8 * scale, label: '10' },
    { angle: 20, len: 8 * scale, label: null },
    { angle: 30, len: 13 * scale, label: '30' },
    { angle: 45, len: 13 * scale, label: '45' },
    { angle: 60, len: 13 * scale, label: '60' }
  ];
  
  marks.forEach(m => {
    const rad = (m.angle * Math.PI) / 180;
    const x1 = Math.sin(rad) * radius;
    const y1 = -Math.cos(rad) * radius;
    const x2 = Math.sin(rad) * (radius + m.len);
    const y2 = -Math.cos(rad) * (radius + m.len);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    
    if (m.label) {
      const labelRadius = radius + m.len + 11 * scale;
      const lx = Math.sin(rad) * labelRadius;
      const ly = -Math.cos(rad) * labelRadius;
      ctx.fillText(m.label, lx, ly + 4 * scale);
    }
  });
  
  // Roll pointer
  ctx.rotate((roll * Math.PI) / 180);
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -radius);
  ctx.lineTo(-8 * scale, -radius - 13 * scale);
  ctx.lineTo(8 * scale, -radius - 13 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  

  // Roll value text
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
  ctx.fillText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
}

function drawGSIndicator(ctx, x, cy, height, gsDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(x, cy - height / 2);
  ctx.lineTo(x, cy + height / 2);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotY = cy + (i * height) / 5;
    ctx.beginPath();
    ctx.arc(x, dotY, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (gsDeviation !== null && gsDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, gsDeviation));
    const gy = cy + (clamped * height) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x - 8 * scale, gy);
    ctx.lineTo(x, gy - 6 * scale);
    ctx.lineTo(x + 8 * scale, gy);
    ctx.lineTo(x, gy + 6 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawLOCIndicator(ctx, cx, y, width, locDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - width / 2, y);
  ctx.lineTo(cx + width / 2, y);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotX = cx + (i * width) / 5;
    ctx.beginPath();
    ctx.arc(dotX, y, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (locDeviation !== null && locDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, locDeviation));
    const lx = cx + (clamped * width) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(lx, y - 8 * scale);
    ctx.lineTo(lx + 6 * scale, y);
    ctx.lineTo(lx, y + 8 * scale);
    ctx.lineTo(lx - 6 * scale, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawSpeedTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const speed = data.airspeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Speed tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'right';
  const step = 20;
  const pixelsPerKnot = 3.5 * scale;
  
  for (let s = Math.floor((speed - step) / step) * step - 100; s <= speed + 100; s += step) {
    if (s < 40) continue;
    const sy = y - (s - speed) * pixelsPerKnot;
    if (sy < y - h / 2 || sy > y + h / 2) continue;
    
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x + w / 2 - 16 * scale, sy);
    ctx.lineTo(x + w / 2, sy);
    ctx.stroke();
    ctx.fillText(s.toString(), x + w / 2 - 20 * scale, sy + 4 * scale);
  }
  ctx.restore();
  
  // Current speed box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(18 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(speed), x, y);
  ctx.textBaseline = 'alphabetic';
  
  // Ground speed
  const groundSpeed = data.groundSpeed || 0;
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const gsText = Math.round(groundSpeed).toString();
  ctx.strokeText(gsText, x, y + h / 2 + 15 * scale);
  ctx.fillText(gsText, x, y + h / 2 + 15 * scale);
  ctx.font = `${Math.round(10 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('GS', x, y + h / 2 + 26 * scale);
}

function drawAltitudeTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const alt = data.altitude;
  const selectedAlt = 2000;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Selected altitude
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(selectedAlt.toString(), x, y - h / 2 - 8 * scale);
  
  // Altitude tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'left';
  const step = 100;
  const pixelsPerFoot = 1.1 * scale;
  
  for (let a = Math.floor((alt - step) / step) * step - 1000; a <= alt + 1000; a += step) {
    if (a < 0) continue;
    const ay = y - (a - alt) * pixelsPerFoot;
    if (ay < y - h / 2 || ay > y + h / 2) continue;
    
    if (a % 200 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 16 * scale, ay);
      ctx.stroke();
      ctx.fillText(a.toString(), x - w / 2 + 19 * scale, ay + 4 * scale);
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 1 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 10 * scale, ay);
      ctx.stroke();
    }
  }
  ctx.restore();
  
  // Current altitude box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(17 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(alt), x, y);
  ctx.textBaseline = 'alphabetic';
}

function drawVerticalSpeedFull(ctx, x, y, w, h, data, scale = 1) {
  const vs = data.verticalSpeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w, y - h / 2, w, h);
  
  const maxVS = 2000;
  const vsScale = h / (maxVS * 2);
  const clamped = Math.max(-maxVS, Math.min(maxVS, vs));
  const posY = y - clamped * vsScale;
  
  ctx.fillStyle = '#10b981';
  ctx.beginPath();
  ctx.moveTo(x - w + 3 * scale, posY);
  ctx.lineTo(x - 3 * scale, posY);
  ctx.lineTo(x - w / 2, posY - 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.font = `${Math.round(9 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.textAlign = 'center';
  
  [-2, -1, 0, 1, 2].forEach(val => {
    const my = y - (val * 1000) * vsScale;
    if (my >= y - h / 2 && my <= y + h / 2) {
      ctx.fillText(val, x - w / 2, my + 3 * scale);
    }
  });
  
  // VS value
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const vsText = Math.round(vs).toString();
  ctx.strokeText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.fillText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.font = `${Math.round(8 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('FPM', x - w / 2, y + h / 2 + 24 * scale);
}

function drawHeadingFull(ctx, cx, y, w, h, data, scale = 1) {
  const hdg = data.heading;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(cx - w / 2, y, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(cx - w / 2, y, w, h);
  
  // Selected heading
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(selectedHeading.toString().padStart(3, '0'), cx - w / 2 + 8 * scale, y + h - 8 * scale);
  
  // Current heading box
  const boxW = 75 * scale;
  const boxH = 28 * scale; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –≤—ã—Å–æ—Ç–∞
  ctx.fillStyle = '#000';
  ctx.fillRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  ctx.strokeStyle = '#fbbf24';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  
  ctx.fillStyle = '#fbbf24';
  ctx.font = `bold ${Math.round(20 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle'; // –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
  ctx.fillText(Math.round(hdg).toString().padStart(3, '0'), cx, y + 3 * scale + boxH / 2);
  ctx.textBaseline = 'alphabetic'; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
  
  // Heading tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(cx - w / 2, y + 20 * scale, w, h - 20 * scale);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  const pxPerDeg = 4.5 * scale;
  
  for (let a = 0; a < 360; a += 5) {
    let diff = hdg - a;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;
    
    const hx = cx - diff * pxPerDeg;
    if (hx < cx - w / 2 || hx > cx + w / 2) continue;
    
    if (a % 30 === 0) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 18 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
      
      const labels = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.fillText((labels[a] || (a / 10).toString()), hx, y + h - 21 * scale);
    } else if (a % 10 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.2 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 11 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 0.8 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 8 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    }
  }
  
  // Selected heading marker
  let diffSel = hdg - selectedHeading;
  if (diffSel > 180) diffSel -= 360;
  if (diffSel < -180) diffSel += 360;
  const selX = cx - diffSel * pxPerDeg;
  
  if (selX >= cx - w / 2 && selX <= cx + w / 2) {
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(selX, y + 56 * scale);
    ctx.lineTo(selX - 8 * scale, y + 44 * scale);
    ctx.lineTo(selX + 8 * scale, y + 44 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Current heading pointer
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx, y + 56 * scale);
  ctx.lineTo(cx - 8 * scale, y + 44 * scale);
  ctx.lineTo(cx + 8 * scale, y + 44 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}


function drawRadioHeight(ctx, x, y, data, scale = 1) {
  const radioAlt = Math.round(data.radioAltitude || 0);
  ctx.font = `bold ${Math.round(24 * scale)}px monospace`;
  ctx.fillStyle = '#fbbf24';
  ctx.textAlign = 'center';
  ctx.fillText(`RA ${radioAlt}`, x, y);
}

function drawStatus(ctx, x, y, d, scale = 1) {
  ctx.fillStyle = '#e5e7eb';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(d.onGround ? 'GROUND' : 'AIRBORNE', x, y);
}

// ================================================================
// –í–∏–¥ —Å–±–æ–∫—É (–≥–ª–∏—Å—Å–∞–¥–∞)
// ================================================================
function initSideView() {
  sideCanvas = document.getElementById("canvas-side");
  sideCtx = sideCanvas.getContext("2d");
  resizeSide();
  window.addEventListener("resize", resizeSide);
  drawSide(null);
}
function resizeSide() {
  const r = sideCanvas.parentElement.getBoundingClientRect();
  sideCanvas.width = r.width;
  sideCanvas.height = r.height;
}

function drawSide(d) {
  const ctx = sideCtx;
  const w = sideCanvas.width;
  const h = sideCanvas.height;
  ctx.fillStyle = "#020617";
  ctx.fillRect(0, 0, w, h);

  const groundY = h * 0.78;
  ctx.strokeStyle = "#475569";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(w, groundY);
  ctx.stroke();

  const rwLen = w * 0.28;
  ctx.fillStyle = "#52525b";
  ctx.fillRect(w * 0.62, groundY - 5, rwLen, 10);

  // –≥–ª–∏—Å—Å–∞–¥–∞
  ctx.strokeStyle = "rgba(96,165,250,0.5)";
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  const gsStartX = w * 0.08;
  const gsEndX = w * 0.62;
  const gsStartY = groundY - h * 0.4;
  ctx.moveTo(gsStartX, gsStartY);
  ctx.lineTo(gsEndX, groundY);
  ctx.stroke();
  ctx.setLineDash([]);

  if (!d) return;

  const distNM = d.distanceToThresholdNM || 0;
  const maxDist = pathMeta.totalDistanceNM || 10;
  const tNorm = 1 - Math.min(1, distNM / maxDist);
  const x = gsStartX + (gsEndX - gsStartX) * tNorm;
  const idealY = gsStartY + (groundY - gsStartY) * tNorm;

  let dy = 0;
  if (d.gsDeviation != null) {
    const clamped = Math.max(-2, Math.min(2, d.gsDeviation));
    dy = -clamped * (h * 0.04);
  }
  const y = idealY + dy;

  drawTinyPlaneSide(ctx, x, y);
}

function drawTinyPlaneSide(ctx, x, y) {
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = "#e5e7eb";
  ctx.strokeStyle = "#1e293b";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.lineTo(12, -4);
  ctx.lineTo(12, 4);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(-4, -2);
  ctx.lineTo(2, -10);
  ctx.lineTo(6, -10);
  ctx.lineTo(0, -2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ================================================================
// –í–∏–¥ —Å–≤–µ—Ä—Ö—É (–∫—É—Ä—Å)
// ================================================================
function initTopView() {
  topCanvas = document.getElementById("canvas-top");
  topCtx = topCanvas.getContext("2d");
  resizeTop();
  window.addEventListener("resize", resizeTop);
  drawTop(null);
}
function resizeTop() {
  const r = topCanvas.parentElement.getBoundingClientRect();
  topCanvas.width = r.width;
  topCanvas.height = r.height;
}

function drawTop(d) {
  const ctx = topCtx;
  const w = topCanvas.width;
  const h = topCanvas.height;
  ctx.fillStyle = "#020617";
  ctx.fillRect(0, 0, w, h);

  const rwWidth = w * 0.14;
  const rwLen = h * 0.72;
  const rwX = w * 0.43;
  const rwY = h * 0.14;
  ctx.fillStyle = "#52525b";
  ctx.fillRect(rwX, rwY, rwWidth, rwLen);

  const cx = rwX + rwWidth / 2;
  ctx.strokeStyle = "rgba(96,165,250,0.5)";
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(cx, 10);
  ctx.lineTo(cx, h - 10);
  ctx.stroke();
  ctx.setLineDash([]);

  if (!d) return;

  const distNM = d.distanceToThresholdNM || 0;
  const maxDist = pathMeta.totalDistanceNM || 10;
  const tNorm = 1 - Math.min(1, distNM / maxDist);
  const y = rwY + rwLen * (1 - tNorm);

  let dx = 0;
  if (d.locDeviation != null) {
    const clamped = Math.max(-2, Math.min(2, d.locDeviation));
    dx = clamped * (w * 0.03);
  }
  const x = cx + dx;

  drawTinyPlaneTop(ctx, x, y);
}

function drawTinyPlaneTop(ctx, x, y) {
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = "#e5e7eb";
  ctx.strokeStyle = "#1e293b";
  ctx.lineWidth = 1.5;

  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-4, 10);
  ctx.lineTo(4, 10);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.lineTo(14, 0);
  ctx.lineTo(5, 3);
  ctx.lineTo(-5, 3);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// ================================================================
// –ó–ê–ì–†–£–ó–ö–ê –ò –î–ê–ù–ù–´–ï
// ================================================================
function loadFile() {
  document.getElementById("file-input").click();
}
document.getElementById("file-input").addEventListener("change", handleFile);

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById("loading").style.display = "flex";

  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const wb = XLSX.read(ev.target.result, { type: "binary" });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet);
      
      // –ò–°–ü–†–ê–í–õ–ï–ù–û: forward-fill –¥–ª—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤–µ—Ç—Ä–∞
      let lastWindSpeed = 0;
      let lastWindDir = 0;
      let lastLocDeviation = null;
      let lastGsDeviation = null;
      const raw = rows.map((r, i) => {
        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à, –µ—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        if (r["Vw"] !== undefined && r["Vw"] !== null && r["Vw"] !== "") {
          lastWindSpeed = parseFloat(r["Vw"]);
        }
        if (r["Wdirr"] !== undefined && r["Wdirr"] !== null && r["Wdirr"] !== "") {
          lastWindDir = parseFloat(r["Wdirr"]);
        }
        
        return {
          timestamp: i * 250,
          pitch: parseFloat(r["PITCH"]) || 0,
          roll: parseFloat(r["ROLL"]) || 0,
          heading: parseFloat(r["HDN"]) || 0,
          airspeed: parseFloat(r["Vcom"]) || 0,
          groundSpeed: parseFloat(r["Vgr"]) || 0,
          verticalSpeed: parseFloat(r["Vy"]) || 0,
locDeviation: (() => {
  if (r['LOCdev.l'] !== undefined && r['LOCdev.l'] !== '' && r['LOCdev.l'] !== null) {
    lastLocDeviation = parseFloat(r['LOCdev.l']);
  }
  return lastLocDeviation;
})(),
gsDeviation: (() => {
  if (r['GSdev.l'] !== undefined && r['GSdev.l'] !== '' && r['GSdev.l'] !== null) {
    lastGsDeviation = parseFloat(r['GSdev.l']);
  }
  return lastGsDeviation;
})(),
          windSpeed: lastWindSpeed,      // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
          windDirection: lastWindDir,    // –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ
          onGround: r["AirGr"] === "ground",
          radioAltitude: parseFloat(r["Hg"]) || 0,
        };
      });
      
      flightData = interpolateData(raw);
      calculateDistanceAndHeight();
      
      totalFrames = flightData.length;
      currentFrame = 0;
      enableControls();
      updateAllViews();
      
      console.log(`‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${totalFrames} –∫–∞–¥—Ä–æ–≤, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å ${(totalFrames/FPS).toFixed(1)} —Å–µ–∫`);
    } catch (err) {
      console.error(err);
      alert("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞.");
    } finally {
      document.getElementById("loading").style.display = "none";
    }
  };
  reader.readAsBinaryString(file);
}

function interpolateData(data) {
  if (data.length < 2) return data;
  const t0 = data[0].timestamp;
  const t1 = data[data.length - 1].timestamp;
  const total = t1 - t0;
  const frames = Math.ceil(total / FRAME_MS);
  const out = [];
  for (let i = 0; i < frames; i++) {
    const t = t0 + i * FRAME_MS;
    let j2 = data.findIndex(d => d.timestamp >= t);
    if (j2 === -1) { out.push({ ...data[data.length - 1], timestamp: t }); continue; }
    if (j2 === 0) { out.push({ ...data[0], timestamp: t }); continue; }
    const j1 = j2 - 1;
    const d1 = data[j1], d2 = data[j2];
    const k = (t - d1.timestamp) / (d2.timestamp - d1.timestamp);
    out.push({
      timestamp: t,
      pitch: lerp(d1.pitch, d2.pitch, k),
      roll: lerp(d1.roll, d2.roll, k),
      heading: lerpAngle(d1.heading, d2.heading, k),
      airspeed: lerp(d1.airspeed, d2.airspeed, k),
      groundSpeed: lerp(d1.groundSpeed, d2.groundSpeed, k),
      verticalSpeed: lerp(d1.verticalSpeed, d2.verticalSpeed, k),
      locDeviation: mixOpt(d1.locDeviation, d2.locDeviation, k),
      gsDeviation: mixOpt(d1.gsDeviation, d2.gsDeviation, k),
      windSpeed: lerp(d1.windSpeed, d2.windSpeed, k),
      windDirection: lerpAngle(d1.windDirection, d2.windDirection, k),
      onGround: d1.onGround || d2.onGround,
      radioAltitude: lerp(d1.radioAltitude, d2.radioAltitude, k),
    });
  }
  return out;
}

function calculateDistanceAndHeight() {
  if (flightData.length === 0) return;
  
  // 1. –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É –∫–∞—Å–∞–Ω–∏—è (radioAltitude = -4)
  let touchdownIdx = flightData.findIndex(d => d.radioAltitude <= -4);
  if (touchdownIdx === -1) {
    touchdownIdx = flightData.reduce((minIdx, d, idx, arr) => 
      d.radioAltitude < arr[minIdx].radioAltitude ? idx : minIdx, 0);
  }
  
  console.log(`–¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è: –∫–∞–¥—Ä ${touchdownIdx}, radioAlt = ${flightData[touchdownIdx].radioAltitude}`);
  
  // 2. –í —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è: altitude = 0, distance = 0
  flightData[touchdownIdx].altitude = 0;
  flightData[touchdownIdx].distanceFromTouchdown = 0;
  
  // 3. –ù–ê–ó–ê–î –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è: –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –í–í–ï–†–•
  for (let i = touchdownIdx - 1; i >= 0; i--) {
    const dt = (flightData[i + 1].timestamp - flightData[i].timestamp) / 1000;
    const vs = flightData[i].verticalSpeed; // —Ñ—É—Ç–æ–≤ –≤ –º–∏–Ω—É—Ç—É
    const vsPerSec = vs / 60; // —Ñ—É—Ç–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
    const deltaH = vsPerSec * dt; // –∏–∑–º–µ–Ω–µ–Ω–∏–µ –≤—ã—Å–æ—Ç—ã –∑–∞ dt
    
    // –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º –Ω–∞–∑–∞–¥: altitude[i] = altitude[i+1] - deltaH
    flightData[i].altitude = Math.max(0, flightData[i + 1].altitude - deltaH);
    
    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º Vgr –Ω–∞–∑–∞–¥ (–≤ —Ñ—É—Ç–∞—Ö)
    const gsMps = flightData[i].groundSpeed * 0.514444; // –º/—Å
    const gsFps = gsMps * 3.28084; // —Ñ—É—Ç–æ–≤/—Å
    const distDelta = gsFps * dt;
    
    flightData[i].distanceFromTouchdown = flightData[i + 1].distanceFromTouchdown - distDelta;
  }
  
  // 4. –í–ü–ï–†–Å–î –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è: –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –í–ù–ò–ó (–¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å ~0)
  for (let i = touchdownIdx + 1; i < flightData.length; i++) {
    const dt = (flightData[i].timestamp - flightData[i - 1].timestamp) / 1000;
    
    // –ü–æ—Å–ª–µ –∫–∞—Å–∞–Ω–∏—è –≤—ã—Å–æ—Ç–∞ = 0
    flightData[i].altitude = 0;
    
    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å Vgr –≤–ø–µ—Ä—ë–¥
    const gsMps = flightData[i - 1].groundSpeed * 0.514444;
    const gsFps = gsMps * 3.28084;
    const distDelta = gsFps * dt;
    
    flightData[i].distanceFromTouchdown = flightData[i - 1].distanceFromTouchdown + distDelta;
  }
  
  // 5. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º distanceToThresholdNM
  // –¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ 315–º (1033 —Ñ—É—Ç–∞) –ü–û–°–õ–ï –ø–æ—Ä–æ–≥–∞ –í–ü–ü –ø—Ä–∏ –≥–ª–∏—Å—Å–∞–¥–µ 3¬∞
  // –¢–æ –µ—Å—Ç—å –ø–æ—Ä–æ–≥ –í–ü–ü –Ω–∞ 1033 —Ñ—É—Ç–∞ –ü–ï–†–ï–î —Ç–æ—á–∫–æ–π –∫–∞—Å–∞–Ω–∏—è
  const thresholdOffsetFt = 1033; // —Ñ—É—Ç–æ–≤ –æ—Ç –ø–æ—Ä–æ–≥–∞ –¥–æ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è
  
  for (let i = 0; i < flightData.length; i++) {
    // distanceFromTouchdown: –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è = –î–û –∫–∞—Å–∞–Ω–∏—è, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ = –ü–û–°–õ–ï
    // distanceToThreshold: —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ø–æ—Ä–æ–≥–∞ –í–ü–ü
    const distToThresholdFt = flightData[i].distanceFromTouchdown + thresholdOffsetFt;
    flightData[i].distanceToThresholdNM = Math.abs(distToThresholdFt / 6076); // —É–±—Ä–∞–ª–∏ Math.max
    
    // –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –∫–∞–¥—Ä–∞
    if (i === 0) {
      console.log(`–ö–∞–¥—Ä 0: distanceFromTouchdown = ${flightData[i].distanceFromTouchdown.toFixed(1)} ft`);
      console.log(`–ö–∞–¥—Ä 0: distToThresholdFt = ${distToThresholdFt.toFixed(1)} ft`);
      console.log(`–ö–∞–¥—Ä 0: distanceToThresholdNM = ${flightData[i].distanceToThresholdNM.toFixed(2)} NM`);
    }
  }
  
  pathMeta.totalDistanceNM = Math.max(...flightData.map(d => d.distanceToThresholdNM));
  
 
}

function lerp(a, b, t) { return a + (b - a) * t; }
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return (a + diff * t + 360) % 360;
}
function mixOpt(a, b, t) {
  if (a != null && b != null) return lerp(a, b, t);
  return a != null ? a : b;
}

// ================================================================
// –í–û–°–ü–†–û–ò–ó–í–ï–î–ï–ù–ò–ï
// ================================================================
function enableControls() {
  ["btn-play","btn-stop","btn-b10","btn-b1","btn-f1","btn-f10"].forEach(id=>{
    document.getElementById(id).disabled = false;
  });
  document.getElementById("timeline").disabled = false;
}
function togglePlay() { isPlaying ? pause() : play(); }

function play() {
  if (!flightData.length) return;

  isPlaying = true;
  document.getElementById("btn-play").textContent = "‚è∏ Pause";

  if (timerId) clearInterval(timerId);
  timerId = setInterval(() => {
    currentFrame += playbackSpeed;
    currentFrame = Math.round(currentFrame);

    if (currentFrame >= totalFrames) {
      currentFrame = totalFrames - 1;
      pause();
    }

    updateAllViews();
  }, FRAME_MS);
}
function pause() {
  isPlaying = false;
  document.getElementById("btn-play").textContent = "‚ñ∂Ô∏è Play";
  if (timerId) { clearInterval(timerId); timerId = null; }
}
function stopPlayback() {
  pause();
  currentFrame = 0;
  pathPoints = []; // –û—á–∏—Å—Ç–∫–∞ –ø—É—Ç–∏
  if (pathLine) {
    scene.remove(pathLine);
    pathLine = null;
  }
  updateAllViews();
}
function skipTime(sec) {
  if (!flightData.length) return;
  const frames = sec * FPS;
  currentFrame = Math.max(0, Math.min(totalFrames - 1, currentFrame + frames));
  updateAllViews();
}
function setSpeed(s) {
  playbackSpeed = s;
  document.querySelectorAll(".control-group button").forEach(b => b.classList.remove("active"));
  event.target.classList.add("active");
}

function initTimeline() {
  const tl = document.getElementById("timeline");
  tl.addEventListener("input", (e) => {
    if (!flightData.length) return;
    const v = parseFloat(e.target.value) / 100;
    currentFrame = Math.floor(v * (totalFrames - 1));
    updateAllViews();
  });
}

function updateTimelineLabel() {
  const label = document.getElementById("time-label");
  if (!flightData.length) { label.textContent = "00:00 / 00:00"; return; }
  const curSec = Math.floor(currentFrame / FPS);
  const totSec = Math.floor(totalFrames / FPS);
  const fmt = (s) => {
    const m = Math.floor(s / 60);
    const ss = s % 60;
    return m.toString().padStart(2,"0") + ":" + ss.toString().padStart(2,"0");
  };
  label.textContent = fmt(curSec) + " / " + fmt(totSec);
  const tl = document.getElementById("timeline");
  tl.value = (currentFrame / (totalFrames - 1)) * 100;
}

// ================================================================
// –û–ë–ù–û–í–õ–ï–ù–ò–ï –í–°–ï–• –í–ò–î–û–í
// ================================================================
function updateAllViews() {
  if (!flightData.length) return;
  const d = flightData[currentFrame];
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –≤–∏–¥—ã
  drawPFD(d);
  update3D(d);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–ª–∞–π–Ω
  const tl = document.getElementById("timeline");
  if (tl && !tl.matches(':active')) {
    tl.value = (currentFrame / totalFrames) * 100;
  }
    updateTimelineLabel();
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
  const timeEl = document.getElementById("current-time");
  if (timeEl) {
    const sec = currentFrame / FPS;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    timeEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  }

}

function initSelectedHeading() {
  const input = document.getElementById("input-hdg");
  input.addEventListener("input", (e) => {
    let val = parseInt(e.target.value);
    if (isNaN(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 360) val = 360;
    selectedHeading = val;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–º–µ—Ä –í–ü–ü
    updateRunwayNumber();
    
    if (flightData.length) updateAllViews();
  });
}

function updateRunwayNumber() {
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –Ω–æ–º–µ—Ä
  const oldNumber = scene.getObjectByName('runwayNumber');
  if (oldNumber) scene.remove(oldNumber);
  
  // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 100px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  const runwayNumber = Math.round(selectedHeading / 10) % 36;
  const displayNumber = runwayNumber === 0 ? 36 : runwayNumber;
  
  ctx.fillText(displayNumber.toString().padStart(2, '0'), 128, 64);
  
  const texture = new THREE.CanvasTexture(canvas);
  const numMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
  const numGeom = new THREE.PlaneGeometry(50, 25);
  const number = new THREE.Mesh(numGeom, numMat);
  number.rotation.x = -Math.PI / 2;
  number.position.set(0, 0.3, 60);
  number.name = 'runwayNumber';
  scene.add(number);
}


</script>
</body>
</html>
