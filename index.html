<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Flight Visualizer - B737 NG PFD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: #0f172a;
      color:#fff;
      overflow:auto;
    }
    #app {
      width:100vw;
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    header {
      padding:12px 20px;
      background:#020617;
      border-bottom:1px solid #1e293b;
      display:flex;
      align-items:center;
      gap:12px;
    }
    header h1 { font-size:20px; font-weight:600; }
    
    #content {
      flex:1;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding:10px;
      min-height:0;
    }
    .panel {
      background:#020617;
      border:1px solid #1e293b;
      border-radius:8px;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .panel-title {
      font-size:13px;
      padding:6px 12px;
      border-bottom:1px solid #1e293b;
      background:#030712;
      text-transform:uppercase;
      letter-spacing:0.05em;
      color:#94a3b8;
      font-weight:600;
    }
    .panel-body {
      flex:1;
      position:relative;
      display:flex;
      flex-direction:column;
    }
    
    /* PFD –≤—Å–µ–≥–¥–∞ —Å–ª–µ–≤–∞ */
    #panel-pfd {
      grid-column:1;
      grid-row:1;
    }
    
    /* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ */
    #panel-views {
      grid-column:2;
      grid-row:1;
    }
    
    /* –í–∫–ª–∞–¥–∫–∏ */
    .tabs {
      display:flex;
      background:#030712;
      border-bottom:1px solid #1e293b;
    }
    .tab-btn {
      flex:1;
      padding:8px 12px;
      background:transparent;
      border:none;
      border-right:1px solid #1e293b;
      color:#94a3b8;
      font-size:12px;
      cursor:pointer;
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:0.05em;
      font-weight:600;
    }
    .tab-btn:last-child { border-right:none; }
    .tab-btn:hover { background:#1e293b; }
    .tab-btn.active {
      background:#1e40af;
      color:#fff;
    }
    
    .tab-content {
      display:none;
      flex:1;
      position:relative;
    }
    .tab-content.active {
      display:flex;
    }
    
    canvas {
      width:100%;
      height:100%;
      display:block;
    }

    #controls {
      padding:10px 16px;
      border-top:1px solid #1e293b;
      background:#020617;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    button {
      background:#1e293b;
      color:#e2e8f0;
      border:1px solid #334155;
      border-radius:5px;
      padding:6px 12px;
      font-size:13px;
      cursor:pointer;
      transition:all 0.2s;
      font-weight:500;
    }
    button:hover { border-color:#60a5fa; background:#334155; }
    button:disabled { opacity:0.3; cursor:not-allowed; }
    button.active {
      background:#1d4ed8;
      border-color:#60a5fa;
      color:#fff;
    }
    #file-input { display:none; }
    #timeline {
      flex:1;
      appearance:none;
      height:7px;
      background:#1e293b;
      border-radius:999px;
      outline:none;
      min-width:200px;
    }
    #timeline::-webkit-slider-thumb {
      appearance:none;
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      box-shadow:0 0 8px rgba(96,165,250,0.6);
      cursor:pointer;
    }
    #timeline::-moz-range-thumb {
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      border:none;
      cursor:pointer;
    }
    .time-label {
      font-family:"Consolas","Courier New",monospace;
      font-size:13px;
      min-width:100px;
      text-align:right;
      color:#cbd5e1;
    }
    #loading {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.8);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100;
    }
    #loading-inner {
      background:#020617;
      border:1px solid #475569;
      border-radius:10px;
      padding:20px 32px;
      text-align:center;
      font-size:15px;
    }
    #loading-inner div {
      width:40px; height:40px;
      border-radius:50%;
      border:4px solid #475569;
      border-top-color:#60a5fa;
      margin:0 auto 12px;
      animation:spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform:rotate(360deg); }
    }
    .toggle-label {
      display:flex; align-items:center; gap:6px;
      font-size:13px;
      color:#cbd5e1;
    }
    input[type="checkbox"] {
      width:16px; height:16px;
      cursor:pointer;
    }
    .control-group {
      display:flex;
      gap:6px;
      align-items:center;
    }
    .divider {
      width:1px;
      height:24px;
      background:#334155;
      margin:0 4px;
    }
    @media(max-width:1200px){
      #content {
        grid-template-columns:1fr;
        grid-template-rows: auto auto;
      }
      #panel-pfd { grid-column:1; grid-row:1; min-height:400px; }
      #panel-views { grid-column:1; grid-row:2; min-height:400px; }
    }
	
/* –ü–†–ê–í–ê–Ø DEBUG –ü–ê–ù–ï–õ–¨ */
/* –ü–†–ê–í–ê–Ø DEBUG –ü–ê–ù–ï–õ–¨ (–û–±–Ω–æ–≤–ª–µ–Ω–æ) */
#debug-panel {
  display: none;
  position: fixed;
  top: 60px;
  right: 20px;
  width: auto;
  min-width: 200px; /* –°–¥–µ–ª–∞–ª —á—É—Ç—å —É–∂–µ */
  max-width: 350px;
  
  /* –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –í–´–°–û–¢–ê –ò –°–ö–†–û–õ–õ */
  max-height: calc(100vh - 100px); /* –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ —ç–∫—Ä–∞–Ω–∞ */
  display: flex; /* Flex –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–∫—Ä–æ–ª–ª–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ */
  flex-direction: column;
  
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: -5px 5px 15px rgba(0,0,0,0.5);
  z-index: 900;
  color: #cbd5e1;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px; /* –ß—É—Ç—å –º–µ–Ω—å—à–µ —à—Ä–∏—Ñ—Ç */
}

#debug-header {
  padding: 6px 10px; /* –ö–æ–º–ø–∞–∫—Ç–Ω–µ–µ */
  background: #1e293b;
  border-bottom: 1px solid #334155;
  border-radius: 8px 8px 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0; /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ —Å–∂–∏–º–∞–µ—Ç—Å—è */
}

#debug-content {
  padding: 5px 10px;
  overflow-y: auto; /* –í–ï–†–¢–ò–ö–ê–õ–¨–ù–´–ô –°–ö–†–û–õ–õ –¢–û–õ–¨–ö–û –ó–î–ï–°–¨ */
  flex-grow: 1; /* –ó–∞–Ω–∏–º–∞–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –º–µ—Å—Ç–æ */
}

/* –°–∫—Ä–æ–ª–ª–±–∞—Ä –¥–ª—è Webkit (Chrome, Safari) - —á—Ç–æ–±—ã –±—ã–ª —Ç–æ–Ω–∫–∏–º */
#debug-content::-webkit-scrollbar {
  width: 6px;
}
#debug-content::-webkit-scrollbar-track {
  background: #0f172a;
}
#debug-content::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 3px;
}

.debug-row {
  display: flex;
  justify-content: space-between;
  padding: 1px 0; /* –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ô –û–¢–°–¢–£–ü –ú–ï–ñ–î–£ –°–¢–†–û–ö–ê–ú–ò */
  border-bottom: 1px solid #1e293b;
  line-height: 1.2; /* –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ */
}
.debug-row:last-child {
  border-bottom: none;
}

.debug-key { color: #94a3b8; }
.debug-val { color: #60a5fa; font-weight: bold; text-align: right; padding-left: 10px; }
.debug-val.null { color: #ef4444; }
	
.path-toggle-group {
  display: flex;
  background: #1e293b;
  border-radius: 6px;
  padding: 2px;
  border: 1px solid #475569;
  margin-right: 10px; /* –æ—Ç—Å—Ç—É–ø –æ—Ç –¥—Ä—É–≥–∏—Ö –∫–Ω–æ–ø–æ–∫ */
}

.path-btn {
  background: transparent;
  border: none;
  color: #94a3b8;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.path-btn:hover {
  color: #fff;
  background: rgba(255,255,255,0.05);
}

.path-btn.active {
  background: #3b82f6; /* –ê–∫—Ç–∏–≤–Ω—ã–π —Å–∏–Ω–∏–π */
  color: white;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

/* –ì—Ä—É–ø–ø–∞ –¥–ª—è –∏–Ω–ø—É—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ */
.speed-input-group {
  display: flex;
  align-items: center;
  background: #1e293b;
  border-radius: 4px;
  border: 1px solid #475569;
  overflow: hidden;
}

/* –ü–æ–ª–µ –≤–≤–æ–¥–∞ */
#speed-input {
  width: 50px;
  background: transparent;
  border: none;
  color: #e2e8f0;
  text-align: center;
  font-family: monospace;
  font-size: 14px;
  padding: 4px 0;
  -moz-appearance: textfield; /* —É–±—Ä–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Å—Ç—Ä–µ–ª–∫–∏ */
}
#speed-input::-webkit-outer-spin-button,
#speed-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
#speed-input:focus {
  outline: none;
  background: #334155;
}

/* –ö–Ω–æ–ø–∫–∏ +/- */
.speed-step-btn {
  background: #334155;
  color: #94a3b8;
  border: none;
  width: 24px;
  height: 28px;
  cursor: pointer;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
}
.speed-step-btn:hover {
  background: #475569;
  color: #fff;
}

/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä 3D –≤–∏–¥–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å relative */
#view-3d {
  position: relative; 
  /* ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ ... */
}

#compass-container {
  position: absolute;
  top: 10px;      /* –í –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É */
  right: 10px;
  width: 50px;    /* –ß—É—Ç—å –∫–æ–º–ø–∞–∫—Ç–Ω–µ–µ */
  height: 50px;
  background: rgba(30, 41, 59, 0.4); /* –ü—Ä–æ–∑—Ä–∞—á–Ω–µ–µ */
  border-radius: 50%;
  border: 1px solid #64748b; /* –¢–æ–Ω–∫–∞—è —Ä–∞–º–∫–∞ */
  display: flex;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  z-index: 10;    /* –ü–æ–≤–µ—Ä—Ö canvas */
  /* box-shadow —É–¥–∞–ª–µ–Ω */
}

#compass-ring {
  color: #f1f5f9;
  font-weight: bold;
  font-family: sans-serif;
  font-size: 8px;
  position: absolute;
  top: 1px; 
}

#compass-arrow {
  width: 0; 
  height: 0; 
  border-left: 2px solid transparent;
  border-right: 2px solid transparent;
  border-bottom: 15px solid #ef4444; /* –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –≤–º–µ—Å—Ç–æ –ø–æ–ª–æ—Å–∫–∏ */
  position: absolute;
  top: 10px; /* –ü–æ–¥ –±—É–∫–≤–æ–π N */
}


  </style>
</head>
<body>
<div id="app">
  

  <div id="content">
    <!-- PFD —Å–ª–µ–≤–∞ -->
    <div class="panel" id="panel-pfd">
      
      <div class="panel-body">
        <canvas id="canvas-pfd"></canvas>
      </div>
    </div>

    <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ -->
    <div class="panel" id="panel-views">
      <div class="panel-body">
        <div class="tab-content active" id="tab-3d">
          <canvas id="canvas-3d"></canvas>
          <div id="compass-container">
            <div id="compass-ring">N</div>
            <div id="compass-arrow"></div>
        </div>
      </div>
        </div>
      </div>
    </div>
  </div>

  <div id="controls">
 <!-- –ù–û–í–û–ï: –ø–æ–ª–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ -->
  <label style="color:#cbd5e1; font-size:13px; display:flex; align-items:center; gap:6px;">
    RWY HDG:
    <input type="number" id="input-hdg" min="0" max="360" value="0" 
           style="width:70px; padding:4px 8px; background:#1e293b; border:1px solid #475569; 
                  border-radius:4px; color:#e879f9; font-size:14px; font-weight:bold; text-align:center;">
  </label>
	<div class="divider"></div>

<button id="btn-debug" class="debug-btn" onclick="toggleDebug()">üêû Debug</button>


	
  <div class="divider"></div>

    <button id="btn-load" onclick="loadFile()">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</button>
    <input type="file" id="file-input" accept=".xlsx,.xls">

    <div class="divider"></div>

    <button id="btn-play" onclick="togglePlay()" disabled>‚ñ∂Ô∏è Play</button>
    <button id="btn-stop" onclick="stopPlayback()" disabled>‚èπ Stop</button>

    <div class="divider"></div>

    <button onclick="skipTime(-10)" id="btn-b10" disabled>‚èÆ -10s</button>
    <button onclick="skipTime(-1)"  id="btn-b1"  disabled>‚è™ -1s</button>
    <input type="range" id="timeline" min="0" max="100" value="0" disabled>
    <button onclick="skipTime(1)"  id="btn-f1"  disabled>+1s ‚è©</button>
    <button onclick="skipTime(10)" id="btn-f10" disabled>+10s ‚è≠</button>

    <span class="time-label" id="time-label">00:00 / 00:00</span>

    <div class="divider"></div>

    <!-- <label class="camera-mode-label">
      <input type="checkbox" id="dynamic-camera-chk"> –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –∫–∞–º–µ—Ä–∞
    </label> -->

    <label class="toggle-label">
      <input type="checkbox" id="chk-gs" checked onchange="toggleGsCorridor()">
      <span>–ö—É—Ä—Å/–≥–ª–∏—Å—Å–∞–¥–∞ (3D)</span>
    </label>

    <div class="path-toggle-group">
      <button class="path-btn active" data-mode="none" title="–°–∫—Ä—ã—Ç—å –ø—É—Ç—å">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"></path>
        </svg>
      </button>
      <button class="path-btn" data-mode="trail" title="–°–ª–µ–¥ –∑–∞ —Å–∞–º–æ–ª—ë—Ç–æ–º">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M2 12h5l3-5 4 10 3-5h5"/>
        </svg>
      </button>
      <button class="path-btn" data-mode="full" title="–í–µ—Å—å –ø—É—Ç—å">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          <path d="M9 12l2 2 4-4" />
        </svg>
      </button>
    </div>

    <div class="divider"></div>

    <span style="color:#cbd5e1; font-size:13px;">–°–∫–æ—Ä–æ—Å—Ç—å:</span>
    <div class="control-group">
      <span style="margin-right: 8px; color: #94a3b8; font-size: 14px;">–°–∫–æ—Ä–æ—Å—Ç—å:</span>
    <div class="control-group speed-input-group">
      <!-- –ö–Ω–æ–ø–∫–∞ –º–∏–Ω—É—Å -->
      <button onclick="changeSpeedBy(-1)" class="speed-step-btn" title="–£–º–µ–Ω—å—à–∏—Ç—å">-</button>
      
      <!-- –ü–æ–ª–µ –≤–≤–æ–¥–∞ -->
      <input type="number" id="speed-input" value="1" step="0.25" min="0.03125" max="10" 
             onchange="setSpeedFromInput()" title="–°–∫–æ—Ä–æ—Å—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è">
             
      <!-- –ö–Ω–æ–ø–∫–∞ –ø–ª—é—Å -->
      <button onclick="changeSpeedBy(1)" class="speed-step-btn" title="–£–≤–µ–ª–∏—á–∏—Ç—å">+</button>
    </div>
    </div>
  </div>
</div>

<div id="loading">
  <div id="loading-inner">
    <div></div>
  </div>
</div>

<!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ Debug -->
<div id="debug-panel">
  <div id="debug-header">
    <span id="debug-title">üêû Live Data</span>
    <button onclick="toggleDebug()" style="background:none; border:none; color:#fff; cursor:pointer; font-size:16px;">&times;</button>
  </div>
  <div id="debug-content">
    <!-- –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
    <div style="padding:10px; text-align:center; color:#64748b;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>
  </div>
</div>



<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script> 

// ================================================================
// –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
// ================================================================
const FPS = 32;
const FRAME_MS = 1000 / FPS;
const GS_ANGLE_DEG = 3; // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –≥–ª–∏—Å—Å–∞–¥–∞
const HEIGHT_PER_NM = 300; // ft –Ω–∞ 1 –º–æ—Ä—Å–∫—É—é –º–∏–ª—é –ø—Ä–∏ 3¬∞
const GEAR_TRANSITION_SEC = 2;
const GEAR_TRANSITION_FRAMES = GEAR_TRANSITION_SEC * FPS;
const CAM_LERP_POS = 0.05;  // –ò–Ω–µ—Ä—Ü–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
const CAM_LERP_LOOK = 0.1;  // –ò–Ω–µ—Ä—Ü–∏—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –≤–∑–≥–ª—è–¥–∞


// –¶–µ–ª–µ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∞–º–æ–ª–µ—Ç–∞ (–æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Ä–µ–¥–∫–æ, –∏–∑ –¥–∞–Ω–Ω—ã—Ö)
let targetPlanePos = new THREE.Vector3();
let targetPlaneQuat = new THREE.Quaternion();

// –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è "—Å—ã—Ä—ã—Ö" –¥–∞–Ω–Ω—ã—Ö –ø–æ–≤–æ—Ä–æ—Ç–∞, —á—Ç–æ–±—ã —Å—á–∏—Ç–∞—Ç—å –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω
let targetPitch = 0, targetRoll = 0, targetYaw = 0; 
let isDynamicCamera = false; // –°–æ—Å—Ç–æ—è–Ω–∏–µ —á–µ–∫–±–æ–∫—Å–∞
let smoothedTarget = new THREE.Vector3(); // –°–≥–ª–∞–∂–µ–Ω–Ω–∞—è —Ü–µ–ª—å (–∫—É–¥–∞ —Å–º–æ—Ç—Ä—è—Ç –∫–æ–Ω—Ç—Ä–æ–ª—ã)
let smoothedCameraPos = new THREE.Vector3(); // –°–≥–ª–∞–∂–µ–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
let isCameraInitialized = false; // –§–ª–∞–≥ –ø–µ—Ä–≤–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
let camPos = new THREE.Vector3(); // –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã
let camTarget = new THREE.Vector3(); // –¢–µ–∫—É—â–∞—è —Ç–æ—á–∫–∞, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –∫–∞–º–µ—Ä–∞
let gearFrac = 1;      // 0..1, —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
let targetGearFrac = 1;
let noseStrut, mainStrutL, mainStrutR, nWheel, mWheelL, mWheelR;
let strutOriginalY = { nose: -2.5, mainL: -2.5, mainR: -2.5 }; // –ò—Å—Ö–æ–¥–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
let wheelOriginalY = { nose: -3.5, mainL: -3.8, mainR: -3.8 };
let strutCompression = 0; // 0-1 (—Å–∂–∞—Ç–∏–µ)
let selectedHeading = 263;
let flightData = [];
let totalFrames = 0;
let currentFrame = 0;
let isPlaying = false;
let playbackSpeed = 1;
let timerId = null;

let lastWindUpdateMs = 0;
let cachedWindDir = 0;
let cachedWindSpd = 0;
let pathMode = 'none'; // 'none', 'trail', 'full'

// three.js
let scene, renderer, camera3d, airplane3d, runwayMesh, gsPlane, locPlane;
let gsVisible = true;
let orbitControls;
let pathLine = null;
let pathPoints = [];
let showPath = false;
let trailGroup = null;
let trailLine = null;
let trailWall = null;
let trailDividers = null; 


// canvas
let pfdCanvas, pfdCtx;
let sideCanvas, sideCtx;
let topCanvas, topCtx;

// –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø—É—Ç–∏
let pathMeta = {
  totalDistanceNM: 10, // –±—É–¥–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
};

// ================================================================
// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
// ================================================================
window.addEventListener("load", () => {
  init3D();
  initPFD();
  initTimeline();
  initTabs();
  initSelectedHeading();
  initPathControls();
  document.getElementById('debug-panel').style.display = 'none';
  isDebugVisible = false;
});

// -------------------------------------------------
// –í–∫–ª–∞–¥–∫–∏
// -------------------------------------------------
function initTabs() {
  const btns = document.querySelectorAll(".tab-btn");
  btns.forEach(btn => {
    btn.addEventListener("click", () => {
      const target = btn.dataset.tab;
      btns.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));
      document.getElementById(target).classList.add("active");
      
      // –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∫–ª–∞–¥–∫–∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º, –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
      if (flightData.length) {
        resize3D();
        resizeSide();
        resizeTop();
        updateAllViews();
      }
    });
  });
}


// -------------------------------------------------
// 3D —Å—Ü–µ–Ω–∞
// -------------------------------------------------
// ================================================================
// 3D –°–¶–ï–ù–ê - –ü–û–õ–ù–ê–Ø –ü–ï–†–ï–î–ï–õ–ö–ê
// ================================================================

function init3D() {
  const canvas = document.getElementById("canvas-3d");
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ç–µ–Ω–∏
  resize3D();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏: —Ç—É–º–∞–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 2000–º, –ø–æ–ª–Ω–∞—è –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ 8000–º
  scene.fog = new THREE.Fog(0x87ceeb, 2000, 8000);

  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(500, 800, 300); // –ø–æ–¥–Ω–∏–º–∞–µ–º –≤—ã—à–µ –∏ –¥–∞–ª—å—à–µ
  sun.castShadow = true;
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –æ–±–ª–∞—Å—Ç—å —Ç–µ–Ω–µ–π –¥–ª—è –ø–æ–∫—Ä—ã—Ç–∏—è –≤—Å–µ–π –ø–æ–ª–æ—Å—ã
  sun.shadow.camera.left = -2000;
  sun.shadow.camera.right = 2000;
  sun.shadow.camera.top = 2000;
  sun.shadow.camera.bottom = -2000;
  sun.shadow.camera.near = 100;
  sun.shadow.camera.far = 3000;
  sun.shadow.mapSize.width = 4096; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ç–µ–Ω–µ–π
  sun.shadow.mapSize.height = 4096;
  sun.shadow.bias = -0.0001; // —É—Å—Ç—Ä–∞–Ω—è–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Ç–µ–Ω–µ–π
  
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

camera3d = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 20000);
  camera3d.position.set(0, 50, 100);

  // OrbitControls –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
orbitControls = new THREE.OrbitControls(camera3d, canvas);
orbitControls.enableDamping = false;
orbitControls.enablePan = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
orbitControls.minDistance = 10;
orbitControls.maxDistance = 1000;
orbitControls.maxPolarAngle = Math.PI / 2 + 0.3;
orbitControls.autoRotate = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–ø–æ–≤–æ—Ä–æ—Ç


// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —á–µ–∫–±–æ–∫—Å–∞
const dcChk = document.getElementById('dynamic-camera-chk');
if (dcChk) {
  dcChk.addEventListener('change', (e) => {
    isDynamicCamera = e.target.checked;
    // –°–±—Ä–æ—Å –∏–Ω–µ—Ä—Ü–∏–∏ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏
    if (airplane3d) {
      smoothedTarget.copy(airplane3d.position);
      if (orbitControls) orbitControls.target.copy(airplane3d.position);
    }
  });
}


  createGround();
  createRunway();
  createGlideSlopeCorridor();
  createAirplane();

  window.addEventListener("resize", resize3D);

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º resize –ø–æ—Å–ª–µ –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
  // —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ–ª—É—á–∏–ª —Å–≤–æ–∏ —Ä–∞–∑–º–µ—Ä—ã
    setTimeout(() => {
    resize3D();
  }, 100);

  // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è controls
  animate3D();
  
}



function createGround() {
  // –ó–µ–º–ª—è: –î–µ–ª–∞–µ–º –ø–æ–º–µ–Ω—å—à–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä 10x10 –∫–º), —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –±—É–¥–µ—Ç –µ–∑–¥–∏—Ç—å –∑–∞ –Ω–∞–º–∏
  const groundGeom = new THREE.PlaneGeometry(15000, 15000);
  const groundMat = new THREE.MeshLambertMaterial({ 
    color: 0x228b22,
    depthWrite: false 
  });
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é (–∏–ª–∏ —Å–≤–æ–π—Å—Ç–≤–æ window), —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –≤ animate3D
  window.dynamicGround = new THREE.Mesh(groundGeom, groundMat);
  
  window.dynamicGround.rotation.x = -Math.PI / 2;
  window.dynamicGround.position.y = -0.1; 
  window.dynamicGround.receiveShadow = true;
  window.dynamicGround.renderOrder = 0; 
  
  scene.add(window.dynamicGround);
}

// –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–ª—è OrbitControls
function animate3D() {
  requestAnimationFrame(animate3D);
  
  if (airplane3d) {
      // --- –ò–ù–¢–ï–†–ü–û–õ–Ø–¶–ò–Ø –°–ê–ú–û–õ–ï–¢–ê ---
      // –ï—Å–ª–∏ –∏–¥–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ, –ø–ª–∞–≤–Ω–æ –¥–≤–∏–≥–∞–µ–º —Å–∞–º–æ–ª–µ—Ç –∫ targetPlanePos
      // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç 0.3 –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±—ã—Å—Ç—Ä–æ–µ, –Ω–æ –ø–ª–∞–≤–Ω–æ–µ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ (—Å–≥–ª–∞–∂–∏–≤–∞–µ—Ç 32–ì—Ü —Ä—ã–≤–∫–∏)
      if (isPlaying) {
          airplane3d.position.lerp(targetPlanePos, 0.3);
          airplane3d.quaternion.slerp(targetPlaneQuat, 0.3);
      }
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã (–æ–Ω–∞ —Ç–µ–ø–µ—Ä—å —Å–ª–µ–¥–∏—Ç –∑–∞ –ü–õ–ê–í–ù–´–ú —Å–∞–º–æ–ª–µ—Ç–æ–º)
      if (orbitControls && camera3d) {
          updateCamera();
      }

      // –î–≤–∏–≥–∞–µ–º –∑–µ–º–ª—é –∑–∞ —Å–∞–º–æ–ª–µ—Ç–æ–º
      if (window.dynamicGround) {
          window.dynamicGround.position.x = airplane3d.position.x;
          window.dynamicGround.position.z = airplane3d.position.z;
      }
  }
  
  if (renderer && camera3d && scene) {
    updateCompass();
    renderer.render(scene, camera3d);
  }
}

function updateCompass() {
  if (!orbitControls) return;

  const compassEl = document.getElementById('compass-container');
  if (!compassEl) return;

  // 1. –£–≥–æ–ª –∫–∞–º–µ—Ä—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –æ—Å–∏ Z —Å—Ü–µ–Ω—ã (–≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö)
  // getAzimuthalAngle(): 0 = –∫–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ -Z (–≤–¥–æ–ª—å –ø–æ–ª–æ—Å—ã?)
  // –ù—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ, –Ω–æ –æ–±—ã—á–Ω–æ 0 = +Z.
  const camRad = orbitControls.getAzimuthalAngle();
  const camDeg = camRad * (180 / Math.PI);

  // 2. –£–≥–æ–ª "–°–µ–≤–µ—Ä–∞" –≤ —Å—Ü–µ–Ω–µ.
  // –í –≤–∞—à–µ–π —Å—Ü–µ–Ω–µ –æ—Å—å -Z (–∫—É–¥–∞ –ª–µ—Ç–∏—Ç —Å–∞–º–æ–ª–µ—Ç –ø—Ä–∏ Heading=RunwayHeading) 
  // —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∫—É—Ä—Å—É `selectedHeading`.
  // –ó–Ω–∞—á–∏—Ç, –°–µ–≤–µ—Ä (–∫—É—Ä—Å 0) –æ—Ç—Å—Ç–æ–∏—Ç –æ—Ç –æ—Å–∏ —Å—Ü–µ–Ω—ã –Ω–∞ `-selectedHeading`.
  
  // –ò—Ç–æ–≥–æ–≤—ã–π –ø–æ–≤–æ—Ä–æ—Ç –∫–æ–º–ø–∞—Å–∞:
  // –ú—ã –≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ç–∞–∫, —á—Ç–æ–±—ã –±—É–∫–≤–∞ N —É–∫–∞–∑—ã–≤–∞–ª–∞ –Ω–∞ —Å–µ–≤–µ—Ä.
  // Rotation = CameraAngle - RunwayHeading
  
  // –ü–æ–ø—Ä–∞–≤–∫–∞ –º–æ–∂–µ—Ç –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ —Å—Ü–µ–Ω—ã. 
  // –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ç–∞–∫—É—é —Ñ–æ—Ä–º—É–ª—É:
  let rotation = camDeg - selectedHeading;
  
  // –î–æ–±–∞–≤–ª—è–µ–º 180, –µ—Å–ª–∏ –∫–æ–º–ø–∞—Å –ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, –≥–¥–µ —É –≤–∞—Å –ø–µ—Ä–µ–¥)
  // –û–±—ã—á–Ω–æ –≤ Three.js 0 —Ä–∞–¥–∏–∞–Ω–æ–≤ - —ç—Ç–æ –æ—Å—å +Z (–Ω–∞ –∑—Ä–∏—Ç–µ–ª—è).
  // –ê –º—ã –ª–µ—Ç–∏–º –≤ -Z. –†–∞–∑–Ω–∏—Ü–∞ 180.
  rotation += 0; 

  compassEl.style.transform = `rotate(${rotation}deg)`;
}



function resize3D() {
  const canvas = document.getElementById('canvas-3d');
  const parent = canvas.parentElement;
  if (!parent) return;
  
  const w = parent.clientWidth;
  const h = parent.clientHeight;
  if (!renderer || !camera3d || !w || !h) return;
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π pixel ratio
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(w, h, false);
  
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
}

function createRunway() {
  const runwayLen = 3500;
  const runwayWidth = 60;
  
  // –ì–µ–æ–º–µ—Ç—Ä–∏—è –ø–æ–ª–æ—Å—ã
  const rwGeom = new THREE.PlaneGeometry(runwayWidth, runwayLen);
  const rwMat = new THREE.MeshLambertMaterial({ 
    color: 0x3a3a3a,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  runwayMesh = new THREE.Mesh(rwGeom, rwMat);
  runwayMesh.rotation.x = -Math.PI / 2;
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã –Ω–∞—á–∞–ª–æ (—Ç–æ—Ä–µ—Ü) –±—ã–ª–æ –Ω–∞ Z = 30 (–¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã),
  // –∞ –æ—Å—Ç–∞–ª—å–Ω–∞—è –ø–æ–ª–æ—Å–∞ —É—Ö–æ–¥–∏–ª–∞ –≤ –º–∏–Ω—É—Å.
  // –¶–µ–Ω—Ç—Ä –ø–æ–ª–æ—Å—ã –±—É–¥–µ—Ç –≤ Z = 30 - (3500/2) = -1720
  runwayMesh.position.set(0, 0, 30 - runwayLen / 2); 
  runwayMesh.receiveShadow = true;
  runwayMesh.renderOrder = 1;
  scene.add(runwayMesh);

  // –ú–∞—Ç–µ—Ä–∏–∞–ª —Ä–∞–∑–º–µ—Ç–∫–∏
  const lineMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è (—à—Ç—Ä–∏—Ö 30–º —á–µ—Ä–µ–∑ 30–º)
  // –†–∏—Å—É–µ–º –æ—Ç —Ç–æ—Ä—Ü–∞ (Z=30) –¥–æ –∫–æ–Ω—Ü–∞ (Z=-3470)
  for (let z = -60; z > (30 - runwayLen); z -= 60) {
    const segmentGeom = new THREE.PlaneGeometry(1.2, 30);
    const segment = new THREE.Mesh(segmentGeom, lineMat);
    segment.rotation.x = -Math.PI / 2;
    segment.position.set(0, 0.01, z - 15); // –¶–µ–Ω—Ç—Ä —Å–µ–≥–º–µ–Ω—Ç–∞
    segment.renderOrder = 2;
    scene.add(segment);
  }

  // –ü–æ—Ä–æ–≥ –í–ü–ü ("–ó–µ–±—Ä–∞") –Ω–∞ Z = 20 (—á—É—Ç—å –æ—Ç—Å—Ç—É–ø–∏–≤ –æ—Ç –∫—Ä–∞—è 30)
  const thresholdZ = 7.5;
  const stripeGeom = new THREE.PlaneGeometry(3.6, 45); // –ü–æ–ª–æ—Å–∫–∏ —à–∏—Ä–∏–Ω–æ–π 3.6–º, –¥–ª–∏–Ω–æ–π 45–º
  // 12 –ø–æ–ª–æ—Å –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç ICAO –¥–ª—è 60–º –ø–æ–ª–æ—Å—ã)
  for (let i = 0; i < 12; i++) {
    // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ç -27 –¥–æ +27
    const x = -27 + i * (54/11);
    const stripe = new THREE.Mesh(stripeGeom, lineMat);
    stripe.rotation.x = -Math.PI / 2;
    stripe.position.set(x, 0.01, thresholdZ);
    stripe.renderOrder = 2;
    scene.add(stripe);
  }

  // –ó–û–ù–ê –ü–†–ò–ó–ï–ú–õ–ï–ù–ò–Ø (Touchdown Zone)
  // –¢–æ—á–∫–∞ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è (TDZ) –æ–±—ã—á–Ω–æ –≤ 300–º (1000ft) –æ—Ç —Ç–æ—Ä—Ü–∞.
  // –¢–æ—Ä–µ—Ü Z=30. –ó–Ω–∞—á–∏—Ç TDZ Z = 30 - 300 = -270.
  // –í –Ω–∞—à–µ–º –∫–æ–¥–µ update3D –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ -215. –î–∞–≤–∞–π—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º.
  // –ü—É—Å—Ç—å —Ü–µ–ª–µ–≤–∞—è —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –±—É–¥–µ—Ç -270.
  // (–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å sceneTouchdownZ –≤ update3D!)
  
  const touchdownZ = -270; 

  // –ë–æ–ª—å—à–∏–µ –±–ª–æ–∫–∏ (Aiming Point) - –Ω–∞—á–∞–ª–æ –Ω–∞ 400–º (1312ft) –æ—Ç —Ç–æ—Ä—Ü–∞ –ø–æ ICAO, 
  // –Ω–æ —á–∞—Å—Ç–æ 300–º (1000ft). –û—Å—Ç–∞–≤–∏–º –Ω–∞ 300–º.
  const aimingBlockGeom = new THREE.PlaneGeometry(10, 45); // –®–∏—Ä–æ–∫–∏–µ –±–ª–æ–∫–∏
  [-12, 12].forEach(x => {
      const block = new THREE.Mesh(aimingBlockGeom, lineMat);
      block.rotation.x = -Math.PI / 2;
      block.position.set(x, 0.01, touchdownZ);
      block.renderOrder = 2;
      scene.add(block);
  });

  // –û—Å—Ç–∞–ª—å–Ω–∞—è —Ä–∞–∑–º–µ—Ç–∫–∞ –∑–æ–Ω—ã –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è (–ø–∞—Ä—ã –∏ —Ç—Ä–æ–π–∫–∏ –ø–æ–ª–æ—Å)
  // –†–∏—Å—É—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 150–º (500ft) –æ—Ç —Ç–æ—Ä—Ü–∞.
  // 150–º: Z = 30 - 150 = -120
  // 300–º: (—É–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–ª–∏ Aiming Point)
  // 450–º: Z = -420
  // 600–º: Z = -570
  // 750–º: Z = -720
  // 900–º: Z = -870

  const markGeom = new THREE.PlaneGeometry(3, 22);
  const marks = [
      { z: -120, count: 3 }, // –¢—Ä–∏ –ø–æ–ª–æ—Å–∫–∏
      { z: -420, count: 2 }, // –î–≤–µ
      { z: -570, count: 2 },
      { z: -720, count: 1 }, // –û–¥–Ω–∞
      { z: -870, count: 1 }
  ];

  marks.forEach(m => {
      for (let side = -1; side <= 1; side += 2) { // –õ–µ–≤–æ/–ü—Ä–∞–≤–æ
          for (let k = 0; k < m.count; k++) {
              // –°–º–µ—â–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã
              const offset = (k - (m.count-1)/2) * 5; 
              const x = side * (12 + offset + (m.count > 1 ? 5 : 0)); // –°–¥–≤–∏–≥–∞–µ–º –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
              // –£–ø—Ä–æ—â–µ–Ω–Ω–æ: –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞–≤–∏–º –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏
              const finalX = side * (9 + k*5 + 8); 
              
              const mark = new THREE.Mesh(markGeom, lineMat);
              mark.rotation.x = -Math.PI / 2;
              mark.position.set(finalX, 0.01, m.z);
              mark.renderOrder = 2;
              scene.add(mark);
          }
      }
  });

  // –ë–æ–∫–æ–≤—ã–µ –ª–∏–Ω–∏–∏ (Side stripes)
  const sideGeom = new THREE.PlaneGeometry(1.8, runwayLen);
  [-28.5, 28.5].forEach(x => {
    const side = new THREE.Mesh(sideGeom, lineMat);
    side.rotation.x = -Math.PI / 2;
    side.position.set(x, 0.01, 30 - runwayLen / 2);
    side.renderOrder = 2;
    scene.add(side);
  });

  // –ù–æ–º–µ—Ä –í–ü–ü
  createRunwayNumber(-40); // Z=50 (–ø–µ—Ä–µ–¥ –∑–µ–±—Ä–æ–π)
}


function createRunwayNumber(z) {
  const canvas = document.createElement('canvas');
  canvas.width = 512; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 180px Arial'; // —É–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–º–µ—Ä –í–ü–ü –∏–∑ selectedHeading
  const runwayNumber = Math.round(selectedHeading / 10) % 36;
  const displayNumber = runwayNumber === 0 ? 36 : runwayNumber;
  
  ctx.fillText(displayNumber.toString().padStart(2, '0'), 256, 128);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  
  const numMat = new THREE.MeshBasicMaterial({ 
    map: texture, 
    transparent: true,
    depthWrite: true,
    side: THREE.DoubleSide,
    polygonOffset: true,
    polygonOffsetFactor: -3,
    polygonOffsetUnits: -3
  });
  
  const numGeom = new THREE.PlaneGeometry(50, 25);
  
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –Ω–æ–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å
  const oldNumber = scene.getObjectByName('runwayNumber');
  if (oldNumber) scene.remove(oldNumber);
  
  const number = new THREE.Mesh(numGeom, numMat);
  number.rotation.x = -Math.PI / 2;
  number.position.set(0, 0.02, z); // —á—É—Ç—å –ø—Ä–∏–ø–æ–¥–Ω—è—Ç–æ –Ω–∞–¥ –ø–æ–ª–æ—Å–æ–π
  number.name = 'runwayNumber';
  number.renderOrder = 3; // —Ä–µ–Ω–¥–µ—Ä–∏–º –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
  scene.add(number);
}

function createGlideSlopeCorridor() {
  const corridorGroup = new THREE.Group();
  corridorGroup.visible = true;

  // –ì–õ–ò–°–°–ê–î–ê (—Ä–∞—Å—à–∏—Ä—è—é—â–∞—è—Å—è —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å)
  // –ì–ª–∏—Å—Å–∞–¥–∞ 3¬∞ –æ—Ç —Ç–æ—á–∫–∏ –Ω–∞ –≤—ã—Å–æ—Ç–µ ~300–º –¥–æ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const gsAngle = 3 * Math.PI / 180; // 3 –≥—Ä–∞–¥—É—Å–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö
  const locDevAngle = 0.8 * Math.PI / 180;
  // –¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –Ω–∞ z = -270 (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const touchdownZ = -270;
  const dist10NM = 18520; 
  // –ù–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã: –Ω–∞ –≤—ã—Å–æ—Ç–µ 300–º, —ç—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 300/tan(3¬∞) ‚âà 5730–º –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è
  const gsStartZ = touchdownZ + 18520;
  const gsEndZ = touchdownZ; // —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è
  const gsStartHeight = dist10NM * Math.tan(gsAngle); 
  const gsEndHeight = 0; // –≤—ã—Å–æ—Ç–∞ –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  
  const gsLength = gsStartZ - gsEndZ; // –¥–ª–∏–Ω–∞ –ø—Ä–æ–µ–∫—Ü–∏–∏ –Ω–∞ –∑–µ–º–ª—é
  const gsWidthStart = 2 * (dist10NM * Math.tan(locDevAngle));
  const gsWidthEnd = 60; // —à–∏—Ä–∏–Ω–∞ –≤ –∫–æ–Ω—Ü–µ (—à–∏—Ä–∏–Ω–∞ –ø–æ–ª–æ—Å—ã)
  
  // –°–æ–∑–¥–∞—ë–º —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω—É—é –≥–µ–æ–º–µ—Ç—Ä–∏—é
  const gsGeom = new THREE.BufferGeometry();
  
  // –í–µ—Ä—à–∏–Ω—ã —Ç—Ä–∞–ø–µ—Ü–∏–∏ (4 —É–≥–ª–∞)
  const vertices = new Float32Array([
    // –ù–∏–∂–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (—É —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è, z = 0 –≤ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
    -gsWidthEnd/2, -gsLength/2, 0,  // –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π
    gsWidthEnd/2, -gsLength/2, 0,   // –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π
    
    // –í–µ—Ä—Ö–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (–≤ –Ω–∞—á–∞–ª–µ –≥–ª–∏—Å—Å–∞–¥—ã, z = gsLength/2)
    -gsWidthStart/2, gsLength/2, 0, // –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
    gsWidthStart/2, gsLength/2, 0   // –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
  ]);
  
  // –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤, –æ–±—Ä–∞–∑—É—é—â–∏—Ö —Ç—Ä–∞–ø–µ—Ü–∏—é
  const indices = new Uint16Array([
    0, 1, 2,  // –ø–µ—Ä–≤—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
    1, 3, 2   // –≤—Ç–æ—Ä–æ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
  ]);
  
  gsGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  gsGeom.setIndex(new THREE.BufferAttribute(indices, 1));
  gsGeom.computeVertexNormals();
  
  const gsMat = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.05,
    side: THREE.DoubleSide,
    depthWrite: false
  });

  gsPlane = new THREE.Mesh(gsGeom, gsMat);
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≥–ª–∏—Å—Å–∞–¥—É
  const gsCenterZ = (gsStartZ + gsEndZ) / 2;
  const gsCenterHeight = (gsStartHeight + gsEndHeight) / 2;
  
  gsPlane.position.set(0, gsCenterHeight, gsCenterZ);
  gsPlane.rotation.x = Math.PI / 2 - gsAngle; // –Ω–∞–∫–ª–æ–Ω –Ω–∞ 3¬∞
  
  corridorGroup.add(gsPlane);

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è –≥–ª–∏—Å—Å–∞–¥—ã –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫—É—Ä—Å–∞
  const gsLineGeometry = new THREE.BufferGeometry();
  const gsLineVertices = new Float32Array([
    0, gsStartHeight, gsStartZ,  // –Ω–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã
    0, gsEndHeight, gsEndZ       // –∫–æ–Ω–µ—Ü –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  ]);
  gsLineGeometry.setAttribute('position', new THREE.BufferAttribute(gsLineVertices, 3));
  
  const gsLineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 3,
    transparent: true,
    opacity: 0.5
  });
  
  const gsLine = new THREE.Line(gsLineGeometry, gsLineMaterial);
  corridorGroup.add(gsLine);

  // –ë–æ–∫–æ–≤—ã–µ –ª–∏–Ω–∏–∏ —Ç—Ä–∞–ø–µ—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏—Ü
  const leftBorder = new THREE.BufferGeometry();
  const leftVertices = new Float32Array([
    -gsWidthEnd/2, gsEndHeight, gsEndZ,
    -gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  leftBorder.setAttribute('position', new THREE.BufferAttribute(leftVertices, 3));
  
  const borderMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 2,
    transparent: true,
    opacity: 0.2
  });
  
  const leftBorderLine = new THREE.Line(leftBorder, borderMaterial);
  corridorGroup.add(leftBorderLine);

  const rightBorder = new THREE.BufferGeometry();
  const rightVertices = new Float32Array([
    gsWidthEnd/2, gsEndHeight, gsEndZ,
    gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  rightBorder.setAttribute('position', new THREE.BufferAttribute(rightVertices, 3));
  
  const rightBorderLine = new THREE.Line(rightBorder, borderMaterial.clone());
  corridorGroup.add(rightBorderLine);

  scene.add(corridorGroup);
  locPlane = corridorGroup;
}

function createAirplane() {
  if (airplane3d) scene.remove(airplane3d);

  airplane3d = new THREE.Group();
  
  // –î–æ–±–∞–≤–ª—è–µ–º DoubleSide, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å "—á–µ—Ä–Ω—ã–º–∏" –≥—Ä–∞–Ω—è–º–∏
  const matWhite = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide }); 
  const matGrey = new THREE.MeshPhongMaterial({ color: 0xcccccc, side: THREE.DoubleSide });  
  const matBlue = new THREE.MeshPhongMaterial({ color: 0x0077be, side: THREE.DoubleSide });  
  const matDark = new THREE.MeshPhongMaterial({ color: 0x333333 });  
  const matMetal = new THREE.MeshPhongMaterial({ color: 0x999999 }); 

  const bodyRadius = 1.9;
  const bodyLength = 28.0; 
  const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
  wheelGeom.rotateX(Math.PI / 2);
  // === 1. –§–Æ–ó–ï–õ–Ø–ñ ===
  const bodyGeom = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyLength, 32);
  const body = new THREE.Mesh(bodyGeom, matWhite);
  body.rotation.z = Math.PI / 2;
  body.castShadow = true;
  airplane3d.add(body);

  // === 2. –ù–û–° ===
  const noseGeom = new THREE.SphereGeometry(bodyRadius, 32, 16);
  noseGeom.applyMatrix4(new THREE.Matrix4().makeScale(2.0, 1, 1)); 
  const nose = new THREE.Mesh(noseGeom, matWhite);
  nose.position.x = bodyLength / 2;
  airplane3d.add(nose);



  // === 3. –•–í–û–°–¢ ===
  const tailLen = 3.5;
  const tailGeom = new THREE.CylinderGeometry(0.6, bodyRadius, tailLen, 32);
  const tail = new THREE.Mesh(tailGeom, matWhite);
  tail.rotation.z = Math.PI / 2;
  tail.position.set(-bodyLength / 2 - tailLen / 2, 0, 0);
  airplane3d.add(tail);

  // === 4. –ö–†–´–õ–¨–Ø (–ß–µ—Å—Ç–Ω—ã–µ Shape –¥–ª—è –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω) ===
  // Shape —Ä–∏—Å—É–µ—Ç—Å—è –≤ XY.
  // X - –≤–¥–æ–ª—å —Ñ—é–∑–µ–ª—è–∂–∞ (–º–∏–Ω—É—Å = –Ω–∞–∑–∞–¥). Y - —Ä–∞–∑–º–∞—Ö.
  
  // –ü–†–ê–í–û–ï –ö–†–´–õ–û (Y < 0)
  const rWingShape = new THREE.Shape();
  rWingShape.moveTo(0, 0); 
  rWingShape.lineTo(-7, 0); 
  rWingShape.lineTo(-13, -16); // Y = -16 (–í–ø—Ä–∞–≤–æ)
  rWingShape.lineTo(-6, -16); 
  rWingShape.lineTo(0, 0); 

  const rWingGeom = new THREE.ExtrudeGeometry(rWingShape, { depth: 0.4, bevelEnabled: false });
  rWingGeom.translate(0, 0, -0.2); // –¶–µ–Ω—Ç—Ä –ø–æ Z

  const rWing = new THREE.Mesh(rWingGeom, matGrey);
  rWing.rotation.x = Math.PI / 2; // –ö–ª–∞–¥–µ–º –≤ –ø–ª–æ—Å–∫–æ—Å—Ç—å XZ
  rWing.rotation.z = 0.05; 
  rWing.position.set(4, -1.0, -1); 
  rWing.castShadow = true;
  airplane3d.add(rWing);

  // –õ–ï–í–û–ï –ö–†–´–õ–û (Y > 0)
  const lWingShape = new THREE.Shape();
  lWingShape.moveTo(0, 0); 
  lWingShape.lineTo(-7, 0); 
  lWingShape.lineTo(-13, 16); // Y = +16 (–í–ª–µ–≤–æ)
  lWingShape.lineTo(-6, 16); 
  lWingShape.lineTo(0, 0); 

  const lWingGeom = new THREE.ExtrudeGeometry(lWingShape, { depth: 0.4, bevelEnabled: false });
  lWingGeom.translate(0, 0, -0.2);

  const lWing = new THREE.Mesh(lWingGeom, matGrey);
  lWing.rotation.x = Math.PI / 2;
  lWing.rotation.z = -0.05; 
  lWing.position.set(4, -1.0, 1); 
  lWing.castShadow = true;
  airplane3d.add(lWing);


  // === 5. –ö–ò–õ–¨ ===
  const vShape = new THREE.Shape();
  vShape.moveTo(0, 0); 
  vShape.lineTo(-6, 0); 
  vShape.lineTo(-9, 7.5); 
  vShape.lineTo(-4, 7.5); 
  vShape.lineTo(0, 0);

  const vGeom = new THREE.ExtrudeGeometry(vShape, { depth: 0.4, bevelEnabled: false });
  vGeom.translate(0, 0, -0.2);

  const vTail = new THREE.Mesh(vGeom, matBlue);
  vTail.position.set(-10, 1.5, 0);
  vTail.castShadow = true;
  airplane3d.add(vTail);


  // === 6. –°–¢–ê–ë–ò–õ–ò–ó–ê–¢–û–†–´ (–ß–µ—Å—Ç–Ω—ã–µ Shape) ===
  
  // –ü–†–ê–í–´–ô (Y < 0)
  const rStabShape = new THREE.Shape();
  rStabShape.moveTo(0, 0);
  rStabShape.lineTo(-4, 0);
  rStabShape.lineTo(-6, -5.5);
  rStabShape.lineTo(-2.5, -5.5);
  rStabShape.lineTo(0, 0);

  const rStabGeom = new THREE.ExtrudeGeometry(rStabShape, { depth: 0.3, bevelEnabled: false });
  rStabGeom.translate(0, 0, -0.15);

  const rStab = new THREE.Mesh(rStabGeom, matGrey);
  rStab.rotation.x = Math.PI / 2;
  rStab.position.set(-12, 1.0, -0.5); 
  rStab.castShadow = true;
  airplane3d.add(rStab);

  // –õ–ï–í–´–ô (Y > 0)
  const lStabShape = new THREE.Shape();
  lStabShape.moveTo(0, 0);
  lStabShape.lineTo(-4, 0);
  lStabShape.lineTo(-6, 5.5);
  lStabShape.lineTo(-2.5, 5.5);
  lStabShape.lineTo(0, 0);

  const lStabGeom = new THREE.ExtrudeGeometry(lStabShape, { depth: 0.3, bevelEnabled: false });
  lStabGeom.translate(0, 0, -0.15);

  const lStab = new THREE.Mesh(lStabGeom, matGrey);
  lStab.rotation.x = Math.PI / 2;
  lStab.position.set(-12, 1.0, 0.5);
  lStab.castShadow = true;
  airplane3d.add(lStab);

    // ---- –ù–û–°–û–í–û–ï –®–ê–°–°–ò ----
    const nosePivot = new THREE.Group();
    nosePivot.name = 'nosePivot';
    nosePivot.position.set(13, 0, 0);   // –¢–û–ß–ö–ê –ö–†–ï–ü–õ–ï–ù–ò–Ø –ö –§–Æ–ó–ï–õ–Ø–ñ–£

    const noseStrut = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15, 0.15, 2.0),
      matMetal
    );
    noseStrut.position.set(0, -1.0, 0);    // –≤–Ω–∏–∑ –æ—Ç —à–∞—Ä–Ω–∏—Ä–∞
    noseStrut.name = 'noseStrut';

    const nWheel = new THREE.Mesh(wheelGeom, matDark);
    nWheel.position.set(0, -2.0, 0);
    nWheel.name = 'nWheel';

    nosePivot.add(noseStrut);
    nosePivot.add(nWheel);
    airplane3d.add(nosePivot);

    // ---- –õ–ï–í–û–ï –ì–õ–ê–í–ù–û–ï ----
    const mainPivotL = new THREE.Group();
    mainPivotL.name = 'mainPivotL';
    mainPivotL.position.set(-1, 0, 3.0); // –≤–µ—Ä—Ö –∫—Ä–µ–ø–ª–µ–Ω–∏—è –∫ —Ü–µ–Ω—Ç—Ä–æ–ø–ª–∞–Ω—É

    const mainStrutL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.2, 0.2, 2.5),
      matMetal
    );
    mainStrutL.position.set(0, -1.25, 0);
    mainStrutL.name = 'mainStrutL';

    const mWheelL = new THREE.Mesh(wheelGeom, matDark);
    mWheelL.position.set(0, -2.5, 0);
    mWheelL.name = 'mWheelL';

    mainPivotL.add(mainStrutL);
    mainPivotL.add(mWheelL);
    airplane3d.add(mainPivotL);

    // ---- –ü–†–ê–í–û–ï –ì–õ–ê–í–ù–û–ï ----
    const mainPivotR = mainPivotL.clone();
    mainPivotR.name = 'mainPivotR';
    mainPivotR.position.set(-1, 0, -3.0);
    mainPivotR.getObjectByName('mainStrutL').name = 'mainStrutR';
    mainPivotR.getObjectByName('mWheelL').name    = 'mWheelR';
    airplane3d.add(mainPivotR);

  // –§–ò–ù–ê–õ
  airplane3d.rotation.y = Math.PI / 2;
  const gearHeight = 4.2;
  airplane3d.position.set(0, gearHeight, 0);

  scene.add(airplane3d);
}




	function toggleGsCorridor() {
	  gsVisible = document.getElementById("chk-gs").checked;
	  if (locPlane) locPlane.visible = gsVisible;
	  if (gsPlane) gsPlane.visible = gsVisible;
	  if (renderer && camera3d) renderer.render(scene, camera3d);
	}

  function updatePathVisibility() {
  if (!trailGroup) return;

  // 1. –û–±—â–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å
  trailGroup.visible = (pathMode !== 'none');

  // 2. –ï—Å–ª–∏ —Ä–µ–∂–∏–º –∏–∑–º–µ–Ω–∏–ª—Å—è –Ω–∞ —Ö–æ–¥—É, –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å DrawRange
  // (–≤—ã–∑–æ–≤–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ range –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ)
  updateTrailDrawRange(); 
}

function updateGearDeploy(f) {
  if (!airplane3d) return;

  const nosePivot  = airplane3d.getObjectByName('nosePivot');
  const mainPivotL = airplane3d.getObjectByName('mainPivotL');
  const mainPivotR = airplane3d.getObjectByName('mainPivotR');
  if (!nosePivot || !mainPivotL || !mainPivotR) return;

  // f: 0 = —É–±—Ä–∞–Ω–æ, 1 = –≤—ã–ø—É—â–µ–Ω–æ

  // –ù–æ—Å–æ–≤–∞—è: –ø—Ä—è—á–µ—Ç—Å—è –±–ª–∏–∂–µ –∫ –Ω–æ—Å—É –∏ –≤—ã—Ö–æ–¥–∏—Ç —Å–ø–µ—Ä–µ–¥–∏ –Ω–∞–∑–∞–¥ -> –≤—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Y
  const noseAngle = THREE.MathUtils.degToRad(90 * (1 - f)); // 90¬∞ –≤–¥–æ–ª—å –ø–æ–ª—ë—Ç–∞ (—É–±—Ä–∞–Ω–æ) -> 0¬∞ –≤–Ω–∏–∑

  nosePivot.rotation.set(0, 0, 0);
  nosePivot.rotation.z = noseAngle;

  // –ì–ª–∞–≤–Ω—ã–µ: –ø—Ä—è—á—É—Ç—Å—è –≤ —Ü–µ–Ω—Ç—Ä–æ–ø–ª–∞–Ω –∏ –≤—ã—Ö–æ–¥—è—Ç –∫ –∫—Ä—ã–ª—å—è–º -> –≤–æ–∫—Ä—É–≥ –æ—Å–∏ X (–≤–¥–æ–ª—å —Ñ—é–∑–µ–ª—è–∂–∞)
  const mainAngle = THREE.MathUtils.degToRad(90 * (1 - f)); // 90¬∞ –ø–æ–¥ —Ñ—é–∑–µ–ª—è–∂–µ–º -> 0¬∞ –≤–Ω–∏–∑

  mainPivotL.rotation.set(0, 0, 0);
  mainPivotR.rotation.set(0, 0, 0);
  mainPivotL.rotation.x =  mainAngle;  // –æ—Ç –∫—Ä—ã–ª–∞ –∫ —Ü–µ–Ω—Ç—Ä—É
  mainPivotR.rotation.x = -mainAngle;  // —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ
}

const GEAR_ORIG = {
  noseStrutY: -2.5,
  noseWheelY: -3.5,
  mainStrutY: -2.5,
  mainWheelY: -3.8,
};

const MAX_COMP_M   = 0.8;   // —Ö–æ–¥ —Å—Ç–æ–π–∫–∏
const START_COMP_H = 1.5;   // –∫–æ–ª—ë—Å–∞ 1.5 –º –Ω–∞–¥ –∑–µ–º–ª—ë–π ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º —Å–∂–∞—Ç–∏–µ
const FULL_COMP_H  = 0.0;   // –∫–æ–ª—ë—Å–∞ –Ω–∞ –∑–µ–º–ª–µ ‚Äî –ø–æ–ª–Ω–æ–µ —Å–∂–∞—Ç–∏–µ

function updateGearCompressionByWheel(wheelHeightM) {
  if (!airplane3d) return;

  const noseStrut  = airplane3d.getObjectByName('noseStrut');
  const mainStrutL = airplane3d.getObjectByName('mainStrutL');
  const mainStrutR = airplane3d.getObjectByName('mainStrutR');
  const nWheel     = airplane3d.getObjectByName('nWheel');
  const mWheelL    = airplane3d.getObjectByName('mWheelL');
  const mWheelR    = airplane3d.getObjectByName('mWheelR');
  if (!noseStrut || !mainStrutL || !mainStrutR || !nWheel || !mWheelL || !mWheelR) return;

  let k = 0;
  if (wheelHeightM <= START_COMP_H && wheelHeightM >= FULL_COMP_H) {
    k = (START_COMP_H - wheelHeightM) / (START_COMP_H - FULL_COMP_H);   // 0..1
  } else if (wheelHeightM < FULL_COMP_H) {
    k = 1;
  }

  const dy = MAX_COMP_M * k;

  noseStrut.position.y  = GEAR_ORIG.noseStrutY  + dy * 0.5;
  mainStrutL.position.y = GEAR_ORIG.mainStrutY  + dy * 0.5;
  mainStrutR.position.y = GEAR_ORIG.mainStrutY  + dy * 0.5;

  nWheel.position.y  = GEAR_ORIG.noseWheelY  + dy;
  mWheelL.position.y = GEAR_ORIG.mainWheelY + dy;
  mWheelR.position.y = GEAR_ORIG.mainWheelY + dy;

  return dy;  // –≤–∞–∂–Ω–æ: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫—É—é –∫–æ–º–ø—Ä–µ—Å—Å–∏—é
}

function update3D(d) {
  if (!airplane3d) return;

  const sceneTouchdownZ = -270;
  const xPos = d.xPos;
  const zPos = sceneTouchdownZ + d.zPos;
  const gearHeight = 4.2;

  // --- –®–ê–°–°–ò (–æ—Å—Ç–∞–≤–ª—è–µ–º –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
  if (typeof d.gearDownCmd === 'number') {
    targetGearFrac = d.gearDownCmd ? 1 : 0;
  }
  const step = 1 / GEAR_TRANSITION_FRAMES;
  if (gearFrac < targetGearFrac) gearFrac = Math.min(gearFrac + step, targetGearFrac);
  else if (gearFrac > targetGearFrac) gearFrac = Math.max(gearFrac - step, targetGearFrac);
  updateGearDeploy(gearFrac);

  let hFt = d.integratedHeightFt;
  if (typeof hFt !== 'number') hFt = d.radioAltitude || 0;
  
  // –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π —ç—Ç—É —Å—Ç—Ä–æ–∫—É, –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –∑–∞–ø—Ä–µ—Ç–∏—Ç—å —É—Ö–æ–¥ –ø–æ–¥ –∑–µ–º–ª—é –≤–∏–∑—É–∞–ª—å–Ω–æ:
  // if (hFt < 0) hFt = 0; 
  
  const wheelHeightM = hFt * 0.3048;
  const dy = updateGearCompressionByWheel(wheelHeightM) || 0;
  let centerHeightM = wheelHeightM + gearHeight - dy;

  const minCenter = gearHeight - MAX_COMP_M;
  if (centerHeightM < minCenter) centerHeightM = minCenter;

  // --- 1. –ó–ê–ü–ò–°–´–í–ê–ï–ú –¶–ï–õ–ï–í–£–Æ –ü–û–ó–ò–¶–ò–Æ ---
  // –í–º–µ—Å—Ç–æ airplane3d.position.set(...)
  targetPlanePos.set(xPos, centerHeightM, zPos);


  // --- 2. –ó–ê–ü–ò–°–´–í–ê–ï–ú –¶–ï–õ–ï–í–û–ï –í–†–ê–©–ï–ù–ò–ï ---
  const runwayHeading = selectedHeading || 0;
  let planeHeading = d.heading || 0;

  planeHeading = (planeHeading % 360 + 360) % 360;
  const rwHdgNorm = (runwayHeading % 360 + 360) % 360;

  let headingDiff = planeHeading - rwHdgNorm;
  if (headingDiff > 180)  headingDiff -= 360;
  if (headingDiff < -180) headingDiff += 360;

  const yaw = Math.PI / 2 - THREE.MathUtils.degToRad(headingDiff);
  const pitch = THREE.MathUtils.degToRad(d.pitch);
  const roll = THREE.MathUtils.degToRad(d.roll);

  const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), roll);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitch);
  const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

  // –°–æ–±–∏—Ä–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
  const tempQuat = new THREE.Quaternion().copy(qYaw);
  tempQuat.multiply(qPitch);
  tempQuat.multiply(qRoll);
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ü–µ–ª—å
  targetPlaneQuat.copy(tempQuat);

  // --- –í–ê–ñ–ù–û: –ï—Å–ª–∏ –º—ã –ù–ï –≤ —Ä–µ–∂–∏–º–µ Play (–ø–∞—É–∑–∞/—Å–∫—Ä–∞–±–±–∏–Ω–≥), –ø—Ä–∏–º–µ–Ω—è–µ–º –º–≥–Ω–æ–≤–µ–Ω–Ω–æ ---
  // –ß—Ç–æ–±—ã –ø—Ä–∏ —Ä—É—á–Ω–æ–º –ø–µ—Ä–µ–º–∞—Ç—ã–≤–∞–Ω–∏–∏ —Å–∞–º–æ–ª–µ—Ç –Ω–µ "–ø–ª—ã–ª"
  if (!isPlaying) {
     airplane3d.position.copy(targetPlanePos);
     airplane3d.quaternion.copy(targetPlaneQuat);
  }
}

function updateCamera() {
  if (!airplane3d || !orbitControls || !camera3d) return;

  const targetPos = airplane3d.position;

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (–ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫)
  if (!isCameraInitialized) {
    smoothedTarget.copy(targetPos);
    orbitControls.target.copy(targetPos);
    
    // –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ "–¥–µ—Ñ–æ–ª—Ç–Ω–∞—è", —Å—Ç–∞–≤–∏–º –µ–µ –∫—Ä–∞—Å–∏–≤–æ —Å–±–æ–∫—É
    // (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è - —É–±–µ—Ä–∏ if)
    if (camera3d.position.lengthSq() < 100 || (camera3d.position.x === 0 && camera3d.position.z === 100)) {
        camera3d.position.copy(targetPos).add(new THREE.Vector3(-50, 20, 50));
    }
    
    isCameraInitialized = true;
    orbitControls.update();
    return;
  }

  // –°—á–∏—Ç–∞–µ–º —Ç–µ–∫—É—â–∏–π –æ—Ñ—Ñ—Å–µ—Ç –∫–∞–º–µ—Ä—ã –æ—Ç –µ—ë —Ü–µ–ª–∏ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –º—ã—à—å—é)
  const offset = new THREE.Vector3().copy(camera3d.position).sub(orbitControls.target);

  if (isDynamicCamera) {
    // –î–ò–ù–ê–ú–ò–ö–ê: Target –ª–µ–Ω–∏–≤–æ –ø–æ–ª–∑—ë—Ç –∑–∞ —Å–∞–º–æ–ª–µ—Ç–æ–º
    // 0.05 - —Å–∏–ª–∞ –∏–Ω–µ—Ä—Ü–∏–∏ (—á–µ–º –º–µ–Ω—å—à–µ, —Ç–µ–º —Å–∏–ª—å–Ω–µ–µ –æ—Ç—Å—Ç–∞–µ—Ç)
    smoothedTarget.lerp(targetPos, 0.05);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–µ–Ω–∏–≤—ã–π —Ç–∞—Ä–≥–µ—Ç
    orbitControls.target.copy(smoothedTarget);
    
    // –°—Ç–∞–≤–∏–º –∫–∞–º–µ—Ä—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ª–µ–Ω–∏–≤–æ–≥–æ —Ç–∞—Ä–≥–µ—Ç–∞
    camera3d.position.copy(smoothedTarget).add(offset);
    
  } else {
    // –û–ë–´–ß–ù–´–ô: Target –∂–µ—Å—Ç–∫–æ –ø—Ä–∏–≤—è–∑–∞–Ω
    orbitControls.target.copy(targetPos);
    camera3d.position.copy(targetPos).add(offset);
    
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º, —á—Ç–æ–±—ã –ø—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ –Ω–µ –ø—Ä—ã–≥–∞–ª–æ
    smoothedTarget.copy(targetPos);
  }

  orbitControls.update();
}

// ========================================
// PFD - –ê–î–ê–ü–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø
// ========================================

function initPFD() {
  pfdCanvas = document.getElementById('canvas-pfd');
  pfdCtx = pfdCanvas.getContext('2d');
  resizePFD();
  window.addEventListener('resize', resizePFD);
  drawPFD(null);
}

function resizePFD() {
  const rect = pfdCanvas.parentElement.getBoundingClientRect();
  pfdCanvas.width = rect.width;
  pfdCanvas.height = rect.height;
}

// PFD - –≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (–∞–¥–∞–ø—Ç–∏–≤–Ω–∞—è)
function drawPFD(data) {
  const ctx = pfdCtx;
  const w = pfdCanvas.width;
  const h = pfdCanvas.height;
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);
  
  if (!data) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '18px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö', w / 2, h / 2);
    return;
  }
  
  const cx = w / 2;
  const cy = h / 2;
  
  // –ë–∞–∑–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ 600px
  const scale = Math.min(w, h) / 600;
  
  // Top bar

  
  // DME –∏ Wind - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
  const margin = Math.max(10, w * 0.02);
  const topOffset = Math.max(40, h * 0.08);
  drawDME(ctx, margin, topOffset, data, scale);
  drawWindCompact(ctx, w - margin - 100 * scale, topOffset, data, scale);
  
  // Horizon - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä
  const horizonSize = Math.min(w * 0.35, h * 0.4, 250 * scale);
  drawAttitudeFull(ctx, cx, cy, horizonSize, data, scale);
  
  // Speed tape - —Å–ª–µ–≤–∞
  const tapeWidth = Math.max(50, w * 0.11);
  const tapeHeight = Math.min(h * 0.5, 300 * scale);
  drawSpeedTapeFull(ctx, tapeWidth * 0.7, cy, tapeWidth * 0.75, tapeHeight, data, scale);
  
  // Altitude tape - —Å–ø—Ä–∞–≤–∞
  const altTapeWidth = Math.max(60, w * 0.13);
  drawAltitudeTapeFull(ctx, w - altTapeWidth * 1.2, cy, altTapeWidth * 0.7, tapeHeight, data, scale);
  
  // Vertical speed - –∫—Ä–∞–π–Ω—è—è –ø—Ä–∞–≤–∞—è
  const vsWidth = Math.max(25, w * 0.05);
  const vsHeight = Math.min(h * 0.4, 240 * scale);
  drawVerticalSpeedFull(ctx, w - vsWidth * 0.7, cy, vsWidth, vsHeight, data, scale);
  
  // Heading tape - –≤–Ω–∏–∑—É
  const headingY = h - Math.max(70, h * 0.14);
  const headingWidth = Math.min(w * 0.6, 420 * scale);
  const headingHeight = Math.max(50, h * 0.11);
  drawHeadingFull(ctx, cx, headingY, headingWidth, headingHeight, data, scale);
  
  // Radio altitude - –Ω–∞–¥ heading
  const raY = headingY - Math.max(25, h * 0.06);
  drawRadioHeight(ctx, cx, raY, data, scale);
  
  // Status - –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
  drawStatus(ctx, margin, h - margin - 10, data, scale);
}

function drawTopBar(ctx, w, data, scale = 1) {
  ctx.fillStyle = '#4a5568';
  ctx.fillRect(0, 0, w, 30 * scale);
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#10b981';
  ctx.fillText('SINGLE CH', w / 2, 20 * scale);
}

function drawDME(ctx, x, y, data, scale = 1) {
  const distNM = (data.dmeFileNM ?? data.distanceToThresholdCalcNM ?? 0);
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e0e0e0';
  ctx.textAlign = 'left';
  ctx.fillText('DME', x, y);
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.fillStyle = '#10b981';
  ctx.fillText(distNM.toFixed(1), x, y + 18 * scale);
}

function drawWindCompact(ctx, x, y, data, scale = 1) {
  const windDir = data.windDirection || 0;
  const windSpd = Math.round(data.windSpeed || 0);
  const heading = data.heading || 0;
  
  if (windSpd < 1) return;
  
  let relativeDir = windDir - heading;
  while (relativeDir > 180) relativeDir -= 360;
  while (relativeDir < -180) relativeDir += 360;
  
  const arrowAngle = relativeDir;
  const arrowSize = 11 * scale;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((arrowAngle * Math.PI) / 180);
  ctx.strokeStyle = '#0ea5e9';
  ctx.fillStyle = '#0ea5e9';
  ctx.lineWidth = 2 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -arrowSize);
  ctx.lineTo(0, arrowSize);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, arrowSize);
  ctx.lineTo(-4 * scale, arrowSize - 5 * scale);
  ctx.lineTo(4 * scale, arrowSize - 5 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  
  ctx.fillStyle = '#0ea5e9';
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'left';
  const absDir = Math.round(windDir % 360);
  ctx.fillText(`${absDir.toString().padStart(3, '0')}/${windSpd}KT`, x + 16 * scale, y + 5 * scale);
}

function drawAttitudeFull(ctx, cx, cy, size, data, scale = 1) {
  const pitch = -data.pitch;
  const roll = data.roll;
  
  ctx.save();
  const r = size / 2;
  ctx.beginPath();
  ctx.rect(cx - r, cy - r, size, size);
  ctx.clip();
  
  ctx.translate(cx, cy);
  ctx.rotate((-roll * Math.PI) / 180);
  
  const pitchScale = 10 * scale;
  const offset = pitch * pitchScale;
  
  // Sky
  ctx.fillStyle = '#3b82f6';
  ctx.fillRect(-size, -size - offset, size * 2, size);
  
  // Ground
  ctx.fillStyle = '#92400e';
  ctx.fillRect(-size, -offset, size * 2, size);
  
  // Horizon line
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(-size, -offset);
  ctx.lineTo(size, -offset);
  ctx.stroke();
  
  // Pitch lines
  ctx.font = `bold ${Math.round(14 * scale)}px monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  
  // Major lines (10¬∞)
  for (let a = -30; a <= 30; a += 10) {
    if (a === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 65 * scale;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2.5 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
    
    const label = Math.abs(a).toString();
    ctx.fillText(label, -lineW - 22 * scale, y + 5 * scale);
    ctx.fillText(label, lineW + 22 * scale, y + 5 * scale);
  }
  
  // Medium lines (5¬∞)
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  for (let a = -30; a <= 30; a += 5) {
    if (a === 0 || a % 10 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 42 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  // Short lines (2.5¬∞)
  ctx.strokeStyle = '#aaaaaa';
  ctx.lineWidth = 1.5 * scale;
  for (let a = -30; a <= 30; a += 2.5) {
    if (a === 0 || a % 5 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 25 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Aircraft reference symbol
  ctx.strokeStyle = '#fbbf24';
  ctx.fillStyle = '#fbbf24';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - 65 * scale, cy);
  ctx.lineTo(cx - 23 * scale, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 23 * scale, cy);
  ctx.lineTo(cx + 65 * scale, cy);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(cx, cy - 5 * scale);
  ctx.lineTo(cx - 8 * scale, cy + 6 * scale);
  ctx.lineTo(cx + 8 * scale, cy + 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(cx, cy, 3 * scale, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  
  // Roll indicator
  drawRollIndicatorFull(ctx, cx, cy - r - 12 * scale, r * 0.92, roll, scale);
  
  // GS and LOC indicators
  drawGSIndicator(ctx, cx + r + 28 * scale, cy, size * 0.4, data.gsDeviation, scale);
  drawLOCIndicator(ctx, cx, cy + r + 28 * scale, size * 0.4, data.locDeviation, scale);
}

function drawRollIndicatorFull(ctx, cx, cy, radius, roll, scale = 1) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.strokeStyle = '#ffffff';
  ctx.fillStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  
  const marks = [
    { angle: -60, len: 13 * scale, label: '60' },
    { angle: -45, len: 13 * scale, label: '45' },
    { angle: -30, len: 13 * scale, label: '30' },
    { angle: -20, len: 8 * scale, label: null },
    { angle: -10, len: 8 * scale, label: '10' },
    { angle: 0, len: 13 * scale, label: '0' },
    { angle: 10, len: 8 * scale, label: '10' },
    { angle: 20, len: 8 * scale, label: null },
    { angle: 30, len: 13 * scale, label: '30' },
    { angle: 45, len: 13 * scale, label: '45' },
    { angle: 60, len: 13 * scale, label: '60' }
  ];
  
  marks.forEach(m => {
    const rad = (m.angle * Math.PI) / 180;
    const x1 = Math.sin(rad) * radius;
    const y1 = -Math.cos(rad) * radius;
    const x2 = Math.sin(rad) * (radius + m.len);
    const y2 = -Math.cos(rad) * (radius + m.len);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    
    if (m.label) {
      const labelRadius = radius + m.len + 11 * scale;
      const lx = Math.sin(rad) * labelRadius;
      const ly = -Math.cos(rad) * labelRadius;
      ctx.fillText(m.label, lx, ly + 4 * scale);
    }
  });
  
  // Roll pointer
  ctx.rotate((roll * Math.PI) / 180);
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -radius);
  ctx.lineTo(-8 * scale, -radius - 13 * scale);
  ctx.lineTo(8 * scale, -radius - 13 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  

  // Roll value text
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
  ctx.fillText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
}

function drawGSIndicator(ctx, x, cy, height, gsDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(x, cy - height / 2);
  ctx.lineTo(x, cy + height / 2);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotY = cy + (i * height) / 5;
    ctx.beginPath();
    ctx.arc(x, dotY, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (gsDeviation !== null && gsDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, gsDeviation));
    const gy = cy + (clamped * height) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x - 8 * scale, gy);
    ctx.lineTo(x, gy - 6 * scale);
    ctx.lineTo(x + 8 * scale, gy);
    ctx.lineTo(x, gy + 6 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawLOCIndicator(ctx, cx, y, width, locDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - width / 2, y);
  ctx.lineTo(cx + width / 2, y);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotX = cx + (i * width) / 5;
    ctx.beginPath();
    ctx.arc(dotX, y, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (locDeviation !== null && locDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, locDeviation));
    const lx = cx + (clamped * width) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(lx, y - 8 * scale);
    ctx.lineTo(lx + 6 * scale, y);
    ctx.lineTo(lx, y + 8 * scale);
    ctx.lineTo(lx - 6 * scale, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawSpeedTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const speed = data.airspeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Speed tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'right';
  const step = 20;
  const pixelsPerKnot = 3.5 * scale;
  
  for (let s = Math.floor((speed - step) / step) * step - 100; s <= speed + 100; s += step) {
    if (s < 40) continue;
    const sy = y - (s - speed) * pixelsPerKnot;
    if (sy < y - h / 2 || sy > y + h / 2) continue;
    
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x + w / 2 - 16 * scale, sy);
    ctx.lineTo(x + w / 2, sy);
    ctx.stroke();
    ctx.fillText(s.toString(), x + w / 2 - 20 * scale, sy + 4 * scale);
  }
  ctx.restore();
  
  // Current speed box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(18 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(speed), x, y);
  ctx.textBaseline = 'alphabetic';
  
  // Ground speed
  const groundSpeed = data.groundSpeed || 0;
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const gsText = Math.round(groundSpeed).toString();
  ctx.strokeText(gsText, x, y + h / 2 + 15 * scale);
  ctx.fillText(gsText, x, y + h / 2 + 15 * scale);
  ctx.font = `${Math.round(10 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('GS', x, y + h / 2 + 26 * scale);
}

function drawAltitudeTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const alt = data.altitude;
  const selectedAlt = (data.selectedAlt !== undefined && data.selectedAlt !== null) ? data.selectedAlt : 0;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Selected altitude
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(selectedAlt.toString(), x, y - h / 2 - 8 * scale);
  
  // Altitude tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'left';
  const step = 100;
  const pixelsPerFoot = 1.1 * scale;
  
  for (let a = Math.floor((alt - step) / step) * step - 1000; a <= alt + 1000; a += step) {
    if (a < 0) continue;
    const ay = y - (a - alt) * pixelsPerFoot;
    if (ay < y - h / 2 || ay > y + h / 2) continue;
    
    if (a % 200 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 16 * scale, ay);
      ctx.stroke();
      ctx.fillText(a.toString(), x - w / 2 + 19 * scale, ay + 4 * scale);
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 1 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 10 * scale, ay);
      ctx.stroke();
    }
  }
  ctx.restore();
  
  // Current altitude box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(17 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(alt), x, y);
  ctx.textBaseline = 'alphabetic';
}

function drawVerticalSpeedFull(ctx, x, y, w, h, data, scale = 1) {
  const vs = data.verticalSpeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w, y - h / 2, w, h);
  
  const maxVS = 2000;
  const vsScale = h / (maxVS * 2);
  const clamped = Math.max(-maxVS, Math.min(maxVS, vs));
  const posY = y - clamped * vsScale;
  
  ctx.fillStyle = '#10b981';
  ctx.beginPath();
  ctx.moveTo(x - w + 3 * scale, posY);
  ctx.lineTo(x - 3 * scale, posY);
  ctx.lineTo(x - w / 2, posY - 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.font = `${Math.round(9 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.textAlign = 'center';
  
  [-2, -1, 0, 1, 2].forEach(val => {
    const my = y - (val * 1000) * vsScale;
    if (my >= y - h / 2 && my <= y + h / 2) {
      ctx.fillText(val, x - w / 2, my + 3 * scale);
    }
  });
  
  // VS value
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const vsText = Math.round(vs).toString();
  ctx.strokeText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.fillText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.font = `${Math.round(8 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('FPM', x - w / 2, y + h / 2 + 24 * scale);
}

function drawHeadingFull(ctx, cx, y, w, h, data, scale = 1) {
  const hdg = data.heading;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(cx - w / 2, y, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(cx - w / 2, y, w, h);
  
  // Selected heading
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(selectedHeading.toString().padStart(3, '0'), cx - w / 2 + 8 * scale, y + h - 8 * scale);
  
  // Current heading box
  const boxW = 75 * scale;
  const boxH = 28 * scale; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –≤—ã—Å–æ—Ç–∞
  ctx.fillStyle = '#000';
  ctx.fillRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  ctx.strokeStyle = '#fbbf24';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  
  ctx.fillStyle = '#fbbf24';
  ctx.font = `bold ${Math.round(20 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle'; // –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
  ctx.fillText(Math.round(hdg).toString().padStart(3, '0'), cx, y + 3 * scale + boxH / 2);
  ctx.textBaseline = 'alphabetic'; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
  
  // Heading tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(cx - w / 2, y + 20 * scale, w, h - 20 * scale);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  const pxPerDeg = 4.5 * scale;
  
  for (let a = 0; a < 360; a += 5) {
    let diff = hdg - a;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;
    
    const hx = cx - diff * pxPerDeg;
    if (hx < cx - w / 2 || hx > cx + w / 2) continue;
    
    if (a % 30 === 0) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 18 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
      
      const labels = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.fillText((labels[a] || (a / 10).toString()), hx, y + h - 21 * scale);
    } else if (a % 10 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.2 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 11 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 0.8 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 8 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    }
  }
  
  // Selected heading marker
  let diffSel = hdg - selectedHeading;
  if (diffSel > 180) diffSel -= 360;
  if (diffSel < -180) diffSel += 360;
  const selX = cx - diffSel * pxPerDeg;
  
  if (selX >= cx - w / 2 && selX <= cx + w / 2) {
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(selX, y + 56 * scale);
    ctx.lineTo(selX - 8 * scale, y + 44 * scale);
    ctx.lineTo(selX + 8 * scale, y + 44 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Current heading pointer
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx, y + 56 * scale);
  ctx.lineTo(cx - 8 * scale, y + 44 * scale);
  ctx.lineTo(cx + 8 * scale, y + 44 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}


function drawRadioHeight(ctx, x, y, data, scale = 1) {
  const radioAlt = Math.round(data.radioAltitude || 0);
  ctx.font = `bold ${Math.round(24 * scale)}px monospace`;
  ctx.fillStyle = '#fbbf24';
  ctx.textAlign = 'center';
  ctx.fillText(`RA ${radioAlt}`, x, y);
}

function drawStatus(ctx, x, y, d, scale = 1) {
  ctx.fillStyle = '#e5e7eb';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(d.onGround ? 'GROUND' : 'AIRBORNE', x, y);
}

// ================================================================
// –ó–ê–ì–†–£–ó–ö–ê –ò –î–ê–ù–ù–´–ï
// ================================================================
function loadFile() {
  document.getElementById("file-input").click();
}
document.getElementById("file-input").addEventListener("change", handleFile);

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById('loading').style.display = 'flex';
  const reader = new FileReader();

  reader.onload = (ev) => {
    try {
      const data = new Uint8Array(ev.target.result);
      const workbook = XLSX.read(data, {type: 'array'});
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet, {defval: null});

      if (jsonData.length === 0) {
        throw new Error("–§–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö.");
      }

      const columns = Object.keys(jsonData[0]);
      console.log(`–ù–∞–π–¥–µ–Ω–æ —Å—Ç–æ–ª–±—Ü–æ–≤: ${columns.length}`);

      // 1. –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è: –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ -> –û–±—ä–µ–∫—Ç –º–∞—Å—Å–∏–≤–æ–≤
      let processedData = {};
      columns.forEach(col => {
        processedData[col] = jsonData.map(row => row[col]);
      });

      // 2. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã
      let timeKey = columns.find(c => ['time', 'Time', 'TIME', '–í—Ä–µ–º—è'].includes(c));
      if (!timeKey) timeKey = columns[0];
      
      const timeArray = processedData[timeKey];
      if (!timeArray || timeArray.length === 0) throw new Error("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∏");

      const firstTime = timeArray[0];
      let count = 0;
      for (let i = 0; i < timeArray.length; i++) {
        if (timeArray[i] === firstTime) count++;
        else break;
      }
      const origHz = count || 1;
      console.log(`–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∏—Å—Ö–æ–¥–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞: ${origHz} –ì—Ü`);

      // 3. –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –í–´–°–û–¢–´
      const hcorKey = columns.find(c => c.startsWith('Hcor1') || c.startsWith('Hcor'));
      const vsKey = columns.find(c => ['Vy', 'VS', 'VerticalSpeed'].includes(c));
      const timeData = processedData[timeKey]; // –ú–∞—Å—Å–∏–≤ –≤—Ä–µ–º–µ–Ω–∏

      if (hcorKey && processedData[hcorKey]) {
          console.log(`–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã—Å–æ—Ç—ã ${hcorKey}...`);
          
          // –®–ê–ì 1: –§–∏–∑–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (—É–¥–∞–ª–µ–Ω–∏–µ –≤—ã–±—Ä–æ—Å–æ–≤ –ø—Ä–æ—Ç–∏–≤ —Ñ–∏–∑–∏–∫–∏)
          if (vsKey && processedData[vsKey]) {
              console.log(`–ü—Ä–∏–º–µ–Ω—è—é Smart VS Filter...`);
              processedData[hcorKey] = filterAltitudeByVS(
                  processedData[hcorKey], 
                  processedData[vsKey], 
                  timeData
              );
          }
          
          // –®–ê–ì 2: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å—Ç—É–ø–µ–Ω–µ–∫ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –º–æ–º–µ–Ω—Ç—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è)
          processedData[hcorKey] = filterRepeats(processedData[hcorKey]);
      }

      // 4. –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–ø—É—Å–∫–æ–≤
      columns.forEach(col => {
          if (col !== timeKey) {
              processedData[col] = fillGaps(processedData[col]);
          }
      });

      // 5. –†–µ—Å–µ–º–ø–ª–∏–Ω–≥ –¥–æ 32 –ì—Ü
      const targetHz = 32;
      let finalData = {}; 

      if (origHz === targetHz) {
          console.log(`–ß–∞—Å—Ç–æ—Ç–∞ —É–∂–µ ${targetHz} –ì—Ü, –∫–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ.`);
          columns.forEach(col => {
              if (col !== timeKey) {
                  finalData[`i.${col}`] = processedData[col];
              }
          });
      } else {
          console.log(`–†–µ—Å–µ–º–ø–ª–∏–Ω–≥ —Å ${origHz} –ì—Ü –¥–æ ${targetHz} –ì—Ü...`);
          columns.forEach(col => {
              if (col !== timeKey) {
                  const originalArray = processedData[col];
                  const sampleVal = originalArray.find(v => v !== null && v !== undefined);
                  const isNumeric = (typeof sampleVal === 'number');
                  finalData[`i.${col}`] = resampleArray(originalArray, origHz, targetHz, isNumeric);
              }
          });
      }

      // 6. –°–ë–û–†–ö–ê flightData
      const firstKey = Object.keys(finalData)[0];
      const length = finalData[firstKey].length;
      
      flightData = [];
      
      const getVal = (colName, idx) => {
          let key = `i.${colName}`;
          if (finalData[key]) return finalData[key][idx];
          const prefixKey = Object.keys(finalData).find(k => k.startsWith(`i.${colName}`));
          if (prefixKey) return finalData[prefixKey][idx];
          const suffixKey = Object.keys(finalData).find(k => k.endsWith(`.${colName}`));
          if (suffixKey) return finalData[suffixKey][idx];
          return 0;
      };
      
      const getValNullable = (colName, idx) => {
           let key = `i.${colName}`;
           if (finalData[key]) return finalData[key][idx];
           const prefixKey = Object.keys(finalData).find(k => k.startsWith(`i.${colName}`));
           if (prefixKey) return finalData[prefixKey][idx];
           const suffixKey = Object.keys(finalData).find(k => k.endsWith(`.${colName}`));
           if (suffixKey) return finalData[suffixKey][idx];
           return null;
      };

      for (let i = 0; i < length; i++) {
        const d = {};
        d.timestamp = i * (1000 / targetHz); 
        
        d.pitch = getVal('PITCH', i);
        if (d.pitch === 0) d.pitch = getVal('Pitch', i);

        d.roll = getVal('ROLL', i);
        if (d.roll === 0) d.roll = getVal('Roll', i);

        d.heading = getVal('HDN', i);
        if (d.heading === 0) d.heading = getVal('Heading', i);

        d.airspeed = getVal('Vcom', i);
        if (d.airspeed === 0) d.airspeed = getVal('IAS', i);
          
        d.verticalSpeed = getVal('Vy', i);
        if (d.verticalSpeed === 0) d.verticalSpeed = getVal('VS', i);

        d.radioAltitude = getVal('Hg', i);
        if (d.radioAltitude === 0) d.radioAltitude = getVal('RA', i);

        d.altitude = getVal('Hcor1', i);
        if (d.altitude === 0) d.altitude = getVal('Hcor', i);
        
        d.windSpeed = getVal('Vw', i);
        d.windDirection = getVal('Wdir', i);
        if (d.windDirection === 0) d.windDirection = getVal('Wdirr', i);

        d.locDeviation = getValNullable('LOCdev', i);
        d.gsDeviation = getValNullable('GSdev', i);
        
        const hsel = getValNullable('Hsel', i);

        d.selectedAlt = (hsel !== null) ? Math.round(hsel / 100) * 100 : 0;

        d.distanceToThresholdNM = getValNullable('DMEl', i);
        if (d.distanceToThresholdNM === null) d.distanceToThresholdNM = getValNullable('DME', i);
        
        d.dmeFileNM = getValNullable('DMEl', i);
        if (d.dmeFileNM === null) d.dmeFileNM = getValNullable('DME', i); // fallback
        
        

        d.groundSpeed = getVal('Vgr', i);
        
        if (d.groundSpeed === 0 && d.windSpeed > 0 && d.airspeed > 0) {
            const hdgRad = (d.heading * Math.PI) / 180;
            const tasX = d.airspeed * Math.sin(hdgRad);
            const tasY = d.airspeed * Math.cos(hdgRad);
            const windRad = ((d.windDirection + 180) * Math.PI) / 180;
            const windX = d.windSpeed * Math.sin(windRad);
            const windY = d.windSpeed * Math.cos(windRad);
            d.groundSpeed = Math.sqrt(Math.pow(tasX + windX, 2) + Math.pow(tasY + windY, 2));
        }
        
        // –£–º–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ OnGround (—Å—Ç—Ä–æ–∫–∏/—á–∏—Å–ª–∞)
        let agVal = getVal('Air/Gr', i);
        if (!agVal) agVal = getVal('AirGr', i); 
        
        if (agVal && typeof agVal === 'string') {
            d.onGround = agVal.toLowerCase().includes('ground');
        } else {
             d.onGround = (agVal > 0.5);
        }

    // LGlv.dn: "gear up" / "not up" –∏–ª–∏ –ø—É—Å—Ç–æ
    let gearStr = getValNullable('LGlv.dn', i);

if (gearStr === null || gearStr === undefined || gearStr === '') {
    // –µ—Å–ª–∏ —è—á–µ–π–∫–∞ –ø—É—Å—Ç–∞—è ‚Äî –ø—Ä–æ—Å—Ç–æ –¥–µ—Ä–∂–∏–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    if (i === 0) {
        d.gearDownCmd = 1; // —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: –≤—ã–ø—É—â–µ–Ω–æ
    } else {
        d.gearDownCmd = flightData[i - 1].gearDownCmd;
    }
} else if (typeof gearStr === 'string') {
    const s = gearStr.toLowerCase().trim();
    // 1 = –≤—ã–ø—É—â–µ–Ω–æ, 0 = —É–±—Ä–∞–Ω–æ
    if (s.includes('gear up'))      d.gearDownCmd = 0;
    else if (s.includes('not up'))  d.gearDownCmd = 1;
    else                            d.gearDownCmd = (i > 0 ? flightData[i - 1].gearDownCmd : 1);
} else {
    // –Ω–∞ —Å–ª—É—á–∞–π —á–∏—Å–µ–ª/–¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤
    d.gearDownCmd = (i > 0 ? flightData[i - 1].gearDownCmd : 1);
}


        flightData.push(d);
      }
      



  

        
      // –ü–û–ò–°–ö –ò –£–°–¢–ê–ù–û–í–ö–ê –ö–£–†–°–ê –ü–û–õ–û–°–´ (HDNsel –∏–ª–∏ –ê–≤—Ç–æ-—Ä–∞—Å—á–µ—Ç)
      // 1. –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —è–≤–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä HDNsel
      const hdnSelKey = Object.keys(finalData).find(k => k.includes('HDNsel') || k.includes('HDN.sel'));
      let foundHdn = false;
      
      if (hdnSelKey) {
          const val = finalData[hdnSelKey][0];
           if (val && val !== 0) {
              selectedHeading = Math.round(val);
              foundHdn = true;
           }
      }

      // 2. –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –≤—ã—á–∏—Å–ª—è–µ–º –ø–æ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞—Ö–æ–¥–∞
      if (!foundHdn && flightData.length > 0) {
        console.log("Auto-detecting Runway Heading from final approach...");
        let touchdownIdx = flightData.findIndex(d => d.radioAltitude !== null && d.radioAltitude <= -4);
        if (touchdownIdx === -1) touchdownIdx = flightData.length - 1;
        let minRA = Infinity;
        let touchdownIndex = -1;
        const fps = 32;
        const endWindow = Math.max(0, touchdownIdx - 5 * fps);
        const startWindow = Math.max(0, touchdownIdx - 30 * fps);
        
        for (let i = 0; i < processedData.length; i++) {
    const ra = processedData[i].radioAltitude;
    if (ra !== null && ra < minRA) {
        minRA = ra;
        touchdownIndex = i;
    }
}

// –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Ç–æ—á–∫—É –∫–∞—Å–∞–Ω–∏—è
let touchdownBaro = 0;
if (touchdownIndex !== -1) {
    // –ë–µ—Ä–µ–º –±–∞—Ä–æ–≤—ã—Å–æ—Ç—É –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è (–ø–ª—é—Å –ø–æ–ø—Ä–∞–≤–∫–∞ –Ω–∞ –≤—ã—Å–æ—Ç—É —à–∞—Å—Å–∏, –µ—Å–ª–∏ RA ~ 0)
    // –ï—Å–ª–∏ –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è RA = 0, —Ç–æ TouchdownBaro = Baro[i]
    // –ï—Å–ª–∏ –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è RA = -2 (–æ–±–∂–∞—Ç–∏–µ), –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º.
    // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –≤–æ–∑—å–º–µ–º –ø—Ä–æ—Å—Ç–æ Baro –≤ —Ç–æ—á–∫–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π RA.
    touchdownBaro = processedData[touchdownIndex].altitude; // –ë–∞—Ä–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è (–≤ —Ñ—É—Ç–∞—Ö)
}

// –°–æ—Ö—Ä–∞–Ω—è–µ–º —ç—Ç—É –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É –≤ –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ
// –õ—É—á—à–µ –∑–∞–ø–∏—Å–∞—Ç—å –≤ –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä "–≤—ã—Å–æ—Ç—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–æ—Ä—Ü–∞" (RelativeHeight)
for (let i = 0; i < processedData.length; i++) {
    const d = processedData[i];
    // –í—ã—Å–æ—Ç–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞—Å–∞–Ω–∏—è (–≤ —Ñ—É—Ç–∞—Ö)
    d.relativeHeight = d.altitude - touchdownBaro; 
    
    // –ù–æ! –ë–∞—Ä–æ–≤—ã—Å–æ—Ç–∞ –º–æ–∂–µ—Ç "–≥—É–ª—è—Ç—å". 
    // –õ—É—á—à–µ —Å–∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å:
    // –ï—Å–ª–∏ RA < 50 -> –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å RA (–¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –∫–∞—Å–∞–Ω–∏—è)
    // –ï—Å–ª–∏ RA > 200 -> –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Baro (–¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª–µ—Ç–∞)
    // –ú–µ–∂–¥—É 50 –∏ 200 -> –õ–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è (Mix)
    
    let ra = d.radioAltitude;
    if (ra === null) ra = d.relativeHeight; // –§–æ–ª–±—ç–∫
    
    // –°–º–µ—à–∏–≤–∞–Ω–∏–µ (Weight)
    // 0 = —Ç–æ–ª—å–∫–æ Baro, 1 = —Ç–æ–ª—å–∫–æ RA
    let weight = 0;
    
    if (ra < 50) {
        weight = 1; // –ß–∏—Å—Ç—ã–π RA —É –∑–µ–º–ª–∏ (—Ç–æ—á–Ω–æ—Å—Ç—å)
    } else if (ra > 200) {
        weight = 0; // –ß–∏—Å—Ç–∞—è Baro-Relative –Ω–∞–≤–µ—Ä—Ö—É (–ø–ª–∞–≤–Ω–æ—Å—Ç—å)
    } else {
        // –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –æ—Ç 50 (1) –¥–æ 200 (0)
        weight = 1 - (ra - 50) / (150); 
    }
    
    // –§–∏–Ω–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –¥–ª—è 3D (–≤ —Ñ—É—Ç–∞—Ö)
    // d.relativeHeight –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–º–Ω–æ–≥–æ –Ω–µ—Ç–æ—á–Ω–æ–π, –µ—Å–ª–∏ –¥–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—è–ª–æ—Å—å, –Ω–æ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ–π –ø–æ—Å–∞–¥–∫–∏ –ø–æ–π–¥–µ—Ç.
    // –í–∞–∂–Ω–æ: relativeHeight –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å > 0.
    
    const finalH_ft = (ra * weight) + (d.relativeHeight * (1 - weight));
    
    d.final3DHeightMeters = finalH_ft * 0.3048;
}


        if (endWindow > startWindow) {
            let sinSum = 0;
            let cosSum = 0;
            let count = 0;
            
            for (let i = startWindow; i < endWindow; i++) {
                const d = flightData[i];
                if (d.groundSpeed > 50) {
                    let track = d.heading;
                    if (d.windSpeed > 0 && d.airspeed > 0) {
                       const hdgRad = (d.heading * Math.PI) / 180;
                       const windRad = ((d.windDirection + 180) * Math.PI) / 180;
                       const vAirX = d.airspeed * Math.sin(hdgRad);
                       const vAirY = d.airspeed * Math.cos(hdgRad);
                       const vWindX = d.windSpeed * Math.sin(windRad);
                       const vWindY = d.windSpeed * Math.cos(windRad);
                       track = (Math.atan2(vAirX + vWindX, vAirY + vWindY) * 180) / Math.PI;
                       if (track < 0) track += 360;
                    }
                    
                    const r = (track * Math.PI) / 180;
                    sinSum += Math.sin(r);
                    cosSum += Math.cos(r);
                    count++;
                }
            }
            
            if (count > 0) {
                const avgRad = Math.atan2(sinSum, cosSum);
                let avgDeg = (avgRad * 180) / Math.PI;
                if (avgDeg < 0) avgDeg += 360;
                selectedHeading = parseFloat(avgDeg.toFixed(2)); 
                console.log(`Detected RWY HDG: ${selectedHeading}¬∞ (based on ${count} samples)`);
            }
        }
      }
      

      // –û–±–Ω–æ–≤–ª—è–µ–º UI —Å –Ω–∞–π–¥–µ–Ω–Ω—ã–º –∫—É—Ä—Å–æ–º
      document.getElementById('input-hdg').value = selectedHeading;
      createRunwayNumber(-40); 
      
      calculateDistanceAndHeight(); // –ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥ (–≥—Ä—É–±—ã–π)

  // –ü–æ–ø—ã—Ç–∫–∞ —É—Ç–æ—á–Ω–∏—Ç—å –ø–æ LOC
    if (refineRunwayHeadingUsingLOC()) {
        console.log("Runway Heading refined by LOC. Recalculating path...");
        calculateDistanceAndHeight(); // –í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥ (—Ç–æ—á–Ω—ã–π)
    }
    recomputeIntegratedHeightFromVS();
// // --- –ò–ù–¢–ï–ì–†–ò–†–û–í–ê–ù–ò–ï –í–ï–†–¢–ò–ö–ê–õ–¨–ù–û–ô –°–ö–û–†–û–°–¢–ò ---
// if (flightData && flightData.length > 0) {
//   const dt = 1 / 32;

//   // 1. –ò—â–µ–º –∫–∞–¥—Ä –ø–µ—Ä–≤–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è RA <= -2 (–µ—Å–ª–∏ –µ—Å—Ç—å)
//   let touchIndex = -1;
//   for (let i = 0; i < flightData.length; i++) {
//     const ra = flightData[i].radioAltitude;
//     if (ra !== null && ra <= -2) {
//       touchIndex = i;
//       break;
//     }
//   }

//   // 2. –ë–∞–∑–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
//   const baseIndex = (touchIndex !== -1) ? touchIndex : 0;

//   // 3. –ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞–ª–∞
//   flightData[baseIndex].integratedHeightFt = 0;

//   // 4. –ù–∞–∑–∞–¥ –æ—Ç baseIndex: H[i] = H[i+1] - VS[curr] * dt
//   for (let i = baseIndex - 1; i >= 0; i--) {
//     const curr = flightData[i];
//     const next = flightData[i + 1];
//     if (!curr || !next) continue;

//     const vsFPS = -(curr.verticalSpeed || 0) / 60; // —Ñ—Ç/—Å
//     curr.integratedHeightFt = (next.integratedHeightFt || 0) + vsFPS * dt;
//   }

//   // 5. –í–ø–µ—Ä—ë–¥ –æ—Ç baseIndex: H[i] = H[i-1] + VS[prev] * dt
//   for (let i = baseIndex + 1; i < flightData.length; i++) {
//     const curr = flightData[i];
//     const prev = flightData[i - 1];
//     if (!curr || !prev) continue;

//     const vsFPS = (prev.verticalSpeed || 0) / 60;
//     curr.integratedHeightFt = (prev.integratedHeightFt || 0) + vsFPS * dt;
//   }
// }

      totalFrames = flightData.length;
      currentFrame = 0;
      enableControls();
      updateAllViews();
      rebuildTrail();
      updateTrailDrawRange();
      console.log(`${totalFrames} –∫–∞–¥—Ä–æ–≤ (${(totalFrames/FPS).toFixed(1)}—Å)`);

    } catch (err) {
      console.error(err);
      alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ' + err.message);
    } finally {
      document.getElementById('loading').style.display = 'none';
    }
  };

  reader.readAsArrayBuffer(file);
}

// <!-- function interpolateData(data) { -->
//   <!-- if (data.length < 2) return data; -->
//   <!-- const t0 = data[0].timestamp; -->
//   <!-- const t1 = data[data.length - 1].timestamp; -->
//   <!-- const total = t1 - t0; -->
//   <!-- const frames = Math.ceil(total / FRAME_MS); -->
//   <!-- const out = []; -->
//   <!-- for (let i = 0; i < frames; i++) { -->
//     <!-- const t = t0 + i * FRAME_MS; -->
//     <!-- let j2 = data.findIndex(d => d.timestamp >= t); -->
//     <!-- if (j2 === -1) { out.push({ ...data[data.length - 1], timestamp: t }); continue; } -->
//     <!-- if (j2 === 0) { out.push({ ...data[0], timestamp: t }); continue; } -->
//     <!-- const j1 = j2 - 1; -->
//     <!-- const d1 = data[j1], d2 = data[j2]; -->
//     <!-- const k = (t - d1.timestamp) / (d2.timestamp - d1.timestamp); -->
  
// <!-- out.push({ -->
//   <!-- timestamp: t, -->
//   <!-- pitch: lerp(d1.pitch, d2.pitch, k), -->
//   <!-- roll: lerp(d1.roll, d2.roll, k), -->
//   <!-- heading: lerpAngle(d1.heading, d2.heading, k), -->
//   <!-- airspeed: lerp(d1.airspeed, d2.airspeed, k), -->
//   <!-- groundSpeed: lerp(d1.groundSpeed, d2.groundSpeed, k), -->
//   <!-- verticalSpeed: lerp(d1.verticalSpeed, d2.verticalSpeed, k), -->
//   <!-- locDeviation: mixOpt(d1.locDeviation, d2.locDeviation, k), -->
//   <!-- gsDeviation: mixOpt(d1.gsDeviation, d2.gsDeviation, k), -->
//   <!-- windSpeed: lerp(d1.windSpeed, d2.windSpeed, k), -->
//   <!-- windDirection: lerpAngle(d1.windDirection, d2.windDirection, k), -->
//   <!-- onGround: d1.onGround || d2.onGround, -->
//   <!-- radioAltitude: lerp(d1.radioAltitude, d2.radioAltitude, k), -->
//   <!-- altitude: lerp(d1.altitude || 0, d2.altitude || 0, k), -->
//   <!-- distanceFromTouchdown: lerp(d1.distanceFromTouchdown || 0, d2.distanceFromTouchdown || 0, k), -->
//   <!-- // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º DME, –µ—Å–ª–∏ –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ null -->
//   <!-- distanceToThresholdNM: (d1.distanceToThresholdNM !== null && d2.distanceToThresholdNM !== null) -->
//     <!-- ? lerp(d1.distanceToThresholdNM, d2.distanceToThresholdNM, k) -->
//     <!-- : (d1.distanceToThresholdNM !== null ? d1.distanceToThresholdNM : d2.distanceToThresholdNM) -->
// <!-- }); -->

//   <!-- } -->
//   <!-- return out; -->
// <!-- } -->


// ================================================================
// –†–ê–°–ß–ï–¢ –î–ò–°–¢–ê–ù–¶–ò–ò, –í–ï–ö–¢–û–†–û–í –ò –ö–û–†–†–ï–ö–¶–ò–ò –í–´–°–û–¢–´ / –ò–ù–¢–ï–ì–†–ê–õ–ê
// ================================================================
function calculateDistanceAndHeight() {

  // --- –ú–ê–†–ö–ï–†–´ "–ù–ê –ó–ï–ú–õ–ï" –ü–û RA ---
  let hasTouched = false;
  for (let i = 0; i < flightData.length; i++) {
    const d  = flightData[i];
    const ra = d.radioAltitude;

    if (!hasTouched) {
      // –î–æ –ø–µ—Ä–≤–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è
      d.raGround = (ra !== null && ra <= -4);
      if (d.raGround) hasTouched = true;
    } else {
      // –ü–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –∫–∞—Å–∞–Ω–∏—è –¥–µ—Ä–∂–∏–º "–Ω–∞ –∑–µ–º–ª–µ", –ø–æ–∫–∞ RA —Å–Ω–æ–≤–∞ –Ω–µ —Å—Ç–∞–Ω–µ—Ç > 0
      if (ra !== null && ra > 0) {
        d.raGround = false; // –æ—Ç—Ä—ã–≤ / —Å–Ω–æ–≤–∞ –≤ –≤–æ–∑–¥—É—Ö–µ
      } else {
        d.raGround = true;  // –≤—Å—ë –µ—â—ë –Ω–∞ –∑–µ–º–ª–µ
      }
    }
  }

  if (flightData.length === 0) return;

  console.log("–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—á–µ—Ç (–ß–∏—Å—Ç–∞—è —Ñ–∏–∑–∏–∫–∞ + –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ RadioAlt)...");

  // --- –ü–û–ò–°–ö –¢–û–ß–ö–ò –ö–ê–°–ê–ù–ò–Ø –î–õ–Ø –ì–û–†–ò–ó–û–ù–¢–ê–õ–¨–ù–û–ô –ö–ò–ù–ï–ú–ê–¢–ò–ö–ò ---
  // 1. –ü–æ–∏—Å–∫ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è (—Å—Ç—Ä–æ–≥–æ –ø–æ –≤—ã—Å–æ—Ç–µ <= 4 —Ñ—É—Ç–∞)
  let touchdownIndex = flightData.findIndex(
    d => d.radioAltitude !== null && d.radioAltitude <= 4
  );

  // Fallback
  if (touchdownIndex === -1) {
    touchdownIndex = flightData.findIndex(d => d.onGround);
  }

  // --- –õ–û–ì–ò–ö–ê stickyOnGround / everTouched / everLiftedAfterTouch ---
  let everTouched = false;
  let everLiftedAfterTouch = false;
  let altitudeBias = 0;

  for (let i = 0; i < flightData.length; i++) {
    const d  = flightData[i];
    const ra = d.radioAltitude;

    if (ra !== null && ra <= -4) {
      // –ü–µ—Ä–≤–æ–µ —Ä–µ–∞–ª—å–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ
      everTouched = true;
    }

    if (everTouched && ra !== null && ra > 0) {
      // –ü–æ—Å–ª–µ –∫–∞—Å–∞–Ω–∏—è RA —Å–Ω–æ–≤–∞ > 0 ‚Äî –∑–Ω–∞—á–∏—Ç –±—ã–ª –æ—Ç—Ä—ã–≤
      everLiftedAfterTouch = true;
    }

    if (!everTouched) {
      d.stickyOnGround = false;
    } else if (everTouched && !everLiftedAfterTouch) {
      d.stickyOnGround = true;
    } else {
      d.stickyOnGround = (ra !== null && ra <= -2);
    }
  }

  // --- –í–´–ë–û–† TOUCHDOWN / –ú–ò–ù–ò–ú–£–ú RA –î–õ–Ø –ì–û–†–ò–ó–û–ù–¢–ê–õ–ò ---
  let zPosCorrection = 0; // –°–º–µ—â–µ–Ω–∏–µ –ø–æ Z (–≤ –º–µ—Ç—Ä–∞—Ö)

  if (touchdownIndex === -1) {
    // –ë–ê–ó–û–í–´–ô –í–ê–†–ò–ê–ù–¢: –ø–æ—Å–∞–¥–∫–∏ –Ω–µ—Ç (–ø—Ä–æ—Ö–æ–¥/—É—Ö–æ–¥)
    let minAlt     = Infinity;
    let minAltIndex = -1;

    flightData.forEach((d, i) => {
      const ra = (d.radioAltitude !== null) ? d.radioAltitude : 9999;
      if (ra < minAlt) {
        minAlt      = ra;
        touchdownIndex = i;   // "—Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è" = —Ç–æ—á–∫–∞ –º–∏–Ω–∏–º—É–º–∞ RA
        minAltIndex    = i;
      }
    });

    if (touchdownIndex !== -1) {
      // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –±–∞—Ä–æ–≤—ã—Å–æ—Ç—ã –∫–∞–∫ —Ä–∞–Ω—å—à–µ
      altitudeBias =
        flightData[touchdownIndex].altitude -
        (flightData[touchdownIndex].radioAltitude || 0);

      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ DME (–µ—Å–ª–∏ –µ—Å—Ç—å)
      const dMin  = flightData[minAltIndex];
      const dmeVal = dMin.distanceToThresholdNM;

      if (dmeVal !== null && dmeVal !== undefined && dmeVal > 0) {
        console.log(`–ü–æ—Å–∞–¥–∫–∏ –Ω–µ—Ç. –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ DME: ${dmeVal} NM`);
        zPosCorrection = dmeVal * 1852; // –º
      }
    }
  } else {
    // –°–õ–£–ß–ê–ô –° –ü–û–°–ê–î–ö–û–ô
    // –ò—â–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –±–∞—Ä–æ-–≤—ã—Å–æ—Ç—É –Ω–∞ –ø—Ä–æ–±–µ–≥–µ –∏ –ø–æ –Ω–µ–π –¥–µ–ª–∞–µ–º –Ω–æ–ª—å
    let minAltOnGround = Infinity;
    for (let i = touchdownIndex; i < flightData.length; i++) {
      const ra = flightData[i].radioAltitude;
      if (ra === null) continue;
      if (ra <= 0) { // —Å—á–∏—Ç–∞–µ–º –∑–µ–º–ª—ë–π RA <= 0
        const alt = flightData[i].altitude;
        if (alt !== null && alt < minAltOnGround) {
          minAltOnGround = alt;
        }
      }
    }
    if (minAltOnGround !== Infinity) {
      altitudeBias = minAltOnGround;
    } else {
      altitudeBias = flightData[touchdownIndex].altitude;
    }
  }

// --- –ö–û–†–†–ï–ö–¶–ò–Ø –ë–ê–†–û–í–´–°–û–¢–´ ---
flightData.forEach(d => {
  d.correctedAltitude = d.altitude - altitudeBias;
  // –ù–ï —Ç—Ä–æ–≥–∞–µ–º d.integratedHeightFt
});

// --- –ü–†–ò–í–Ø–ó–ö–ê –ò–ù–¢–ï–ì–†–ê–õ–ê VS –ö RA ---
// –∏—â–µ–º –∫–∞–¥—Ä –∫–∞—Å–∞–Ω–∏—è (RA <= -2) –∏ –∫–∞–¥—Ä –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π RA
let touchIdxForInt = -1;
let minRA = Infinity;
let minRAIndex = -1;

for (let i = 0; i < flightData.length; i++) {
  const d  = flightData[i];
  const ra = d.radioAltitude;

  if (ra !== null) {
    if (ra <= -2 && touchIdxForInt === -1) {
      touchIdxForInt = i;             // –±—ã–ª–∞ —Ä–µ–∞–ª—å–Ω–∞—è –ø–æ—Å–∞–¥–∫–∞
    }
    if (ra < minRA) {
      minRA      = ra;
      minRAIndex = i;                  // –º–∏–Ω–∏–º—É–º RA (–¥–ª—è –ø—Ä–æ–ª—ë—Ç–∞)
    }
  }
}

let refIndex = -1;
if (touchIdxForInt !== -1) {
  // –°–õ–£–ß–ê–ô –° –ü–û–°–ê–î–ö–û–ô: –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∏–Ω—Ç–µ–≥—Ä–∞–ª –∫ RA –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è (–∑–µ–º–ª—è)
  refIndex = touchIdxForInt;
} else if (minRAIndex !== -1) {
  // –ë–ï–ó –ü–û–°–ê–î–ö–ò: –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π RA
  refIndex = minRAIndex;
}

if (refIndex !== -1) {
  const ref    = flightData[refIndex];
  const raRef  = (typeof ref.radioAltitude === 'number') ? ref.radioAltitude : 0;
  const intRef = (typeof ref.integratedHeightFt === 'number') ? ref.integratedHeightFt : 0;

  // —Ö–æ—Ç–∏–º: integratedHeightFt(refIndex) == raRef
  const delta = intRef - raRef;

  for (let i = 0; i < flightData.length; i++) {
    const d = flightData[i];
    if (typeof d.integratedHeightFt === 'number') {
      d.integratedHeightFt = d.integratedHeightFt - delta;
    }
  }
}



  // --- –†–ê–°–ß–ï–¢ –í–ï–ö–¢–û–†–û–í –í–ï–¢–†–ê / TRACK ---
  flightData.forEach(d => {
    let rawTrack = d.heading;
    let aerodynamiDrift = 0;

    if (d.airspeed > 10 && d.windSpeed && d.windDirection) {
      const hdgRad  = (d.heading * Math.PI) / 180;
      const windRad = ((d.windDirection + 180) * Math.PI) / 180;

      const vAirX  = d.airspeed * Math.sin(hdgRad);
      const vAirY  = d.airspeed * Math.cos(hdgRad);
      const vWindX = d.windSpeed * Math.sin(windRad);
      const vWindY = d.windSpeed * Math.cos(windRad);

      const vGroundX = vAirX + vWindX;
      const vGroundY = vAirY + vWindY;

      let trackWithWind = (Math.atan2(vGroundX, vGroundY) * 180) / Math.PI;
      if (trackWithWind < 0) trackWithWind += 360;

      let diff = trackWithWind - d.heading;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;
      aerodynamiDrift = diff;
    }

    let windFactor = 0;
    const isOnGroundReal = d.raGround;

    if (!isOnGroundReal) {
      windFactor = 1.0;
    } else {
      const speed = d.airspeed;
      const upperSpeed = 130;
      const lowerSpeed = 80;

      if (speed >= upperSpeed) {
        windFactor = 1.0;
      } else if (speed <= lowerSpeed) {
        windFactor = 0.0;
      } else {
        windFactor = (speed - lowerSpeed) / (upperSpeed - lowerSpeed);
      }
    }

    const finalDrift = aerodynamiDrift * windFactor;
    rawTrack = d.heading + finalDrift;

    if (rawTrack >= 360) rawTrack -= 360;
    if (rawTrack < 0) rawTrack += 360;

    d.targetTrack      = rawTrack;
    d.isCalculatedGround = (windFactor < 0.5);
  });

  // --- –°–ì–õ–ê–ñ–ò–í–ê–ù–ò–ï –¢–†–ï–ö–ê (–ò–ù–ï–†–¶–ò–Ø) ---
  let currentVecX = Math.sin(flightData[0].targetTrack * Math.PI / 180);
  let currentVecY = Math.cos(flightData[0].targetTrack * Math.PI / 180);

  const inertiaFactor = 0.05;

  for (let i = 0; i < flightData.length; i++) {
    const d = flightData[i];

    const effectiveInertia = d.isCalculatedGround ? 0.2 : inertiaFactor;

    const targetRad = d.targetTrack * Math.PI / 180;
    const targetX   = Math.sin(targetRad);
    const targetY   = Math.cos(targetRad);

    currentVecX += (targetX - currentVecX) * effectiveInertia;
    currentVecY += (targetY - currentVecY) * effectiveInertia;

    const len = Math.sqrt(currentVecX**2 + currentVecY**2);
    currentVecX /= len;
    currentVecY /= len;

    let smoothedTrack = (Math.atan2(currentVecX, currentVecY) * 180) / Math.PI;
    if (smoothedTrack < 0) smoothedTrack += 360;

    d.smoothedTrack = smoothedTrack;
  }
  const touchdownOffset = -100;
  // --- –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –ü–û–ó–ò–¶–ò–ò ---
flightData[touchdownIndex].xPos = 0;
flightData[touchdownIndex].zPos = zPosCorrection - touchdownOffset;
flightData[touchdownIndex].distanceFromTouchdown = (zPosCorrection - touchdownOffset) * 3.28084;

  const calculateStep = (dataPoint, dtSeconds) => {
    const gsMps    = (dataPoint.groundSpeed || 0) * 0.514444;
    let trackToUse = dataPoint.smoothedTrack; // targetTrack –∏–ª–∏ smoothedTrack

    let trackDelta = trackToUse - selectedHeading;
    if (trackDelta > 180) trackDelta -= 360;
    if (trackDelta < -180) trackDelta += 360;

    const trackRad = (trackDelta * Math.PI) / 180;

    const distStep = gsMps * dtSeconds;
    return {
      dX: distStep * Math.sin(trackRad),
      dZ: distStep * Math.cos(trackRad),
    };
  };

  // –ù–ê–ó–ê–î
  for (let i = touchdownIndex - 1; i >= 0; i--) {
    const curr = flightData[i];
    const next = flightData[i + 1];
    const dt   = (next.timestamp - curr.timestamp) / 1000;
    const step = calculateStep(curr, dt);

    curr.xPos = next.xPos - step.dX;
    curr.zPos = next.zPos + step.dZ;
    curr.distanceFromTouchdown = curr.zPos * 3.28084;
  }

  // –í–ü–ï–†–ï–î
  for (let i = touchdownIndex + 1; i < flightData.length; i++) {
    const curr = flightData[i];
    const prev = flightData[i - 1];
    const dt   = (curr.timestamp - prev.timestamp) / 1000;
    const step = calculateStep(prev, dt);

    curr.xPos = prev.xPos + step.dX;
    curr.zPos = prev.zPos - step.dZ;
    curr.distanceFromTouchdown = curr.zPos * 3.28084;
  }

  // –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–æ —Ç–æ—Ä—Ü–∞
  flightData.forEach(d => {
    const distToThrMeters = d.zPos - 300;
    d.distanceToThresholdNM = distToThrMeters / 1852;
  });

  pathMeta.totalDistanceNM = Math.max(
    ...flightData.map(d => d.distanceToThresholdNM)
  );

  rebuildTrail();
  updateTrailDrawRange();
}


function recomputeIntegratedHeightFromVS() {
  if (!flightData || !flightData.length) return;

  const dt = 1 / 32; // 32 –ì—Ü

  // ---- 1. –ß–ò–°–¢–´–ô –ò–ù–¢–ï–ì–†–ê–õ VS ----
  flightData[0].integratedHeightFt = 0;

  for (let i = 1; i < flightData.length; i++) {
    const prev = flightData[i - 1];
    const curr = flightData[i];
    const vsFPS = (prev.verticalSpeed || 0) / 60; // ft/s
    curr.integratedHeightFt = (prev.integratedHeightFt || 0) + vsFPS * dt;
  }

  // ---- 2. –ü–û–ò–°–ö –û–ü–û–†–ù–û–ì–û –ö–ê–î–†–ê –ü–û RA ----
  let touchIdx = -1;
  let minRA = Infinity;
  let minRAIndex = -1;

  for (let i = 0; i < flightData.length; i++) {
    const ra = flightData[i].radioAltitude;
    if (ra !== null && ra !== undefined) {
      if (ra <= -2 && touchIdx === -1) {
        touchIdx = i; // –ø–µ—Ä–≤–∞—è —Ä–µ–∞–ª—å–Ω–∞—è –ø–æ—Å–∞–¥–∫–∞
      }
      if (ra < minRA) {
        minRA = ra;
        minRAIndex = i; // –º–∏–Ω–∏–º—É–º RA
      }
    }
  }

  // –µ—Å–ª–∏ –Ω–µ—Ç –≤–æ–æ–±—â–µ –Ω–∏ –æ–¥–Ω–æ–≥–æ RA ‚Äî –ø—Ä–æ—Å—Ç–æ –≤—ã—Ö–æ–¥–∏–º, –æ—Å—Ç–∞–≤–ª—è–µ–º –∏–Ω—Ç–µ–≥—Ä–∞–ª –∫–∞–∫ –µ—Å—Ç—å
  if (minRAIndex === -1 && touchIdx === -1) return;

  // –æ–ø–æ—Ä–Ω—ã–π –∫–∞–¥—Ä:
  //   –µ—Å–ª–∏ –±—ã–ª–∞ –ø–æ—Å–∞–¥–∫–∞ ‚Üí –∫–∞–¥—Ä –∫–∞—Å–∞–Ω–∏—è
  //   –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ ‚Üí –∫–∞–¥—Ä –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π RA
  const refIndex = (touchIdx !== -1) ? touchIdx : minRAIndex;
  const ref      = flightData[refIndex];

  const raRef  = (typeof ref.radioAltitude === 'number') ? ref.radioAltitude : 0;
  const intRef = (typeof ref.integratedHeightFt === 'number') ? ref.integratedHeightFt : 0;

  // —Ö–æ—Ç–∏–º: integratedHeightFt(refIndex) == raRef
  const delta = intRef - raRef;

  for (let i = 0; i < flightData.length; i++) {
    const d = flightData[i];
    if (typeof d.integratedHeightFt === 'number') {
      d.integratedHeightFt = d.integratedHeightFt - delta;
    }
  }

  console.log('VS integration done. Ref index =', refIndex,
              'RA_ref =', raRef, 'delta =', delta);
}


    function refineRunwayHeadingUsingLOC() {
    // 1. –ò—â–µ–º –≤–∞–ª–∏–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ LOC
    // –ù–∞–º –Ω—É–∂–Ω—ã —Ç–æ—á–∫–∏, –≥–¥–µ –º—ã –≤ –≤–æ–∑–¥—É—Ö–µ, –Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –∏ –Ω–µ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ
    // –ò –≥–¥–µ LOCdev —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ: –≤—ã—Å–æ—Ç–∞ > 500ft, —É–¥–∞–ª–µ–Ω–∏–µ < 10nm, LOCdev –ø–æ—á—Ç–∏ 0
    let bestIdx = -1;
    let minLocDev = Infinity;

    for (let i = 0; i < flightData.length; i++) {
        const d = flightData[i];
        if (d.radioAltitude && d.radioAltitude > 500 && d.distanceToThresholdNM < 8 && d.locDeviation !== null) {
            if (Math.abs(d.locDeviation) < minLocDev) {
                minLocDev = Math.abs(d.locDeviation);
                bestIdx = i;
            }
        }
    }

    if (bestIdx !== -1 && minLocDev < 0.05) { // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ—á–Ω–æ–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –æ—Å–∏ (0.05 —Ç–æ—á–∫–∏)
        const d = flightData[bestIdx];
        
        // –í —Ç–µ–∫—É—â–µ–π —Å–∏—Å—Ç–µ–º–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –ø–æ —Å—Ç–∞—Ä–æ–º—É Heading)
        // —Å–∞–º–æ–ª—ë—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ—á–∫–µ (d.xPos, d.zPos).
        // –ê –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ –æ—Å–∏ (X=0), —Ç–∞–∫ –∫–∞–∫ LOCdev=0.
        
        // –ó–Ω–∞—á–∏—Ç, –≤—Å—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—è –ø–æ–≤–µ—Ä–Ω—É—Ç–∞ –Ω–µ–≤–µ—Ä–Ω–æ.
        // –£–≥–æ–ª –æ—à–∏–±–∫–∏:
        // atan2(x, z) –¥–∞–µ—Ç —É–≥–æ–ª, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π —Ç–æ—á–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –æ—Ç –æ—Å–∏ Z.
        // –ù–∞–º –Ω—É–∂–Ω–æ –ø–æ–≤–µ—Ä–Ω—É—Ç—å –æ—Å—å Z —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω–∞ –ø—Ä–æ—à–ª–∞ —á–µ—Ä–µ–∑ —ç—Ç—É —Ç–æ—á–∫—É.
        
        const errorAngleRad = Math.atan2(d.xPos, d.zPos);
        const errorAngleDeg = errorAngleRad * 180 / Math.PI;

        console.log(`LOC Auto-Correction: Found LOC capture at index ${bestIdx}.`);
        console.log(`Current X: ${d.xPos.toFixed(1)}, Z: ${d.zPos.toFixed(1)}`);
        console.log(`Correction Angle: ${errorAngleDeg.toFixed(2)} degrees`);

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ü–∏—é
        // –ï—Å–ª–∏ xPos > 0 (—Å–ø—Ä–∞–≤–∞), –∑–Ω–∞—á–∏—Ç –æ—Å—å –ø–æ–ª–æ—Å—ã "–ª–µ–≤–µ–µ", —á–µ–º –º—ã –¥—É–º–∞–ª–∏?
        // –ò–ª–∏ –º—ã "–ø—Ä–∞–≤–µ–µ".
        // –ü–æ–≤–æ—Ä–æ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–∞ —É–≥–æ–ª alpha:
        // X' = X cos a - Z sin a
        // –ù–∞–º –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã X' —Å—Ç–∞–ª 0.
        
        // –ü—Ä–æ—â–µ: –º—ã –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –æ—à–∏–±–∫—É –∫ selectedHeading.
        // –ï—Å–ª–∏ –º—ã —Å–ø—Ä–∞–≤–∞ (X>0), –∑–Ω–∞—á–∏—Ç —Ä–µ–∞–ª—å–Ω—ã–π –∫—É—Ä—Å –ø–æ–ª–æ—Å—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å "–ø—Ä–∞–≤–µ–µ" (–±–æ–ª—å—à–µ), 
        // —á—Ç–æ–±—ã –æ—Å—å –ø–æ–≤–µ—Ä–Ω—É–ª–∞—Å—å –∫ –Ω–∞–º? –ù–µ—Ç, –Ω–∞–æ–±–æ—Ä–æ—Ç.
        // –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º –∑–Ω–∞–∫–æ–º. 
        // –ï—Å–ª–∏ selectedHeading=90, –º—ã –ª–µ—Ç–∏–º –Ω–∞ –≤–æ—Å—Ç–æ–∫.
        // X > 0 (–º—ã —é–∂–Ω–µ–µ –æ—Å–∏).
        // LOC –≥–æ–≤–æ—Ä–∏—Ç "—Ç—ã –Ω–∞ –æ—Å–∏". –ó–Ω–∞—á–∏—Ç –æ—Å—å –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –Ω–∞—Å (—é–∂–Ω–µ–µ).
        // –ó–Ω–∞—á–∏—Ç –∫—É—Ä—Å –ø–æ–ª–æ—Å—ã –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ (—Å–∫–∞–∂–µ–º 95).
        
        // –§–æ—Ä–º—É–ª–∞: NewHeading = OldHeading + ErrorAngleDeg
        const newHeading = selectedHeading - errorAngleDeg;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –∏ UI
        selectedHeading = parseFloat(newHeading.toFixed(2));
        document.getElementById('input-hdg').value = selectedHeading;
        
        console.log(`New Runway Heading: ${selectedHeading}`);
        
        // –í–ê–ñ–ù–û: –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á–µ—Ç —Ñ–∏–∑–∏–∫–∏ —Å –Ω–æ–≤—ã–º –∫—É—Ä—Å–æ–º
        // –ß—Ç–æ–±—ã –Ω–µ –∑–∞—Ü–∏–∫–ª–∏—Ç—å—Å—è, –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å —Ñ–ª–∞–≥ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –≤—ã–∑–≤–∞—Ç—å –æ–¥–∏–Ω —Ä–∞–∑
        return true; // Correction applied
    }
    
    return false; // No correction
}



    function updatePath() {
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ
  if (pathLine) {
    scene.remove(pathLine);
    pathLine = null;
  }
  
  // –£–¥–∞–ª—è–µ–º –Ω–æ–≤–æ–µ –∏ –°–†–ê–ó–£ –°–¢–†–û–ò–ú –ó–ê–ù–û–í–û, —Ç.–∫. –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã d.xPos/zPos —É–∂–µ –ø–µ—Ä–µ—Å—á–∏—Ç–∞–Ω—ã
  if (trailGroup) {
      scene.remove(trailGroup);
      trailGroup = null;
  }
  
  // –°—Ç—Ä–æ–∏–º –ø—É—Ç—å –∑–∞–Ω–æ–≤–æ —Å –Ω–æ–≤—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
  rebuildTrail();
  updateTrailDrawRange();
}


function updateTrailDrawRange() {
  if (!trailLine || !trailWall) return;

  let count;
  
  if (pathMode === 'full') {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –í–°–ï —Ç–æ—á–∫–∏ (–ø–æ–ª–Ω–∞—è –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞)
    // –£ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –µ—Å—Ç—å –∞—Ç—Ä–∏–±—É—Ç position, –±–µ—Ä–µ–º –µ–≥–æ –¥–ª–∏–Ω—É
    count = trailLine.geometry.attributes.position.count;
  } else {
    // –†–µ–∂–∏–º 'trail' (–∏–ª–∏ 'none', –Ω–æ —Ç–æ–≥–¥–∞ –≥—Ä—É–ø–ø–∞ —Å–∫—Ä—ã—Ç–∞)
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–æ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞
    count = Math.max(2, currentFrame + 1);
  }

  // –ü—Ä–∏–º–µ–Ω—è–µ–º count
  trailLine.geometry.setDrawRange(0, count);

  const segCount = Math.max(0, count - 1);
  trailWall.geometry.setDrawRange(0, segCount * 6);

  // –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏
  if (trailDividers && trailDividers.userData.vertFrames) {
      if (pathMode === 'full') {
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏
          trailDividers.geometry.setDrawRange(0, Infinity);
      } else {
          // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫–∞–¥—Ä–∞–º (–∫–∞–∫ –¥–µ–ª–∞–ª–∏ —Ä–∞–Ω—å—à–µ)
          const frames = trailDividers.userData.vertFrames;
          let visibleCount = 0;
          for (let k = 0; k < frames.length; k++) {
              if (frames[k] <= currentFrame) visibleCount++;
              else break;
          }
          trailDividers.geometry.setDrawRange(0, visibleCount);
      }
  }
}


function rebuildTrail() {
  if (!scene || flightData.length < 2) return;

  if (trailGroup) {
      scene.remove(trailGroup);
      // –û—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
      if (trailLine) { trailLine.geometry.dispose(); trailLine.material.dispose(); }
      if (trailWall) { trailWall.geometry.dispose(); trailWall.material.dispose(); }
      if (trailDividers) { trailDividers.geometry.dispose(); trailDividers.material.dispose(); }
  }

  trailGroup = new THREE.Group();
  trailGroup.visible = showPath;

  const sceneTouchdownZ = -270; 
  const n = flightData.length;

  // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–æ–≤ (—Å—Ä–∞–∑—É –≤—ã–¥–µ–ª—è–µ–º –ø–∞–º—è—Ç—å)
  const linePos = new Float32Array(n * 3);
  const wallPos = new Float32Array(n * 2 * 3);
  
  // –î–ª—è —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π —Å–ª–æ–∂–Ω–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å —Ç–æ—á–Ω–æ–µ —á–∏—Å–ª–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Å—Å–∏–≤, –Ω–æ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ
  const divVerts = []; 

  for (let i = 0; i < n; i++) {
    const d = flightData[i];
    const x = d.xPos;
    const z = sceneTouchdownZ + d.zPos;
    
    // –†–∞—Å—á–µ—Ç –≤—ã—Å–æ—Ç—ã (–∫–∞–∫ –≤ update3D)
    let yVal = 4.2; // gearHeight
    if (!d.raGround) {
        const altMeters = (d.integratedHeightFt || 0) * 0.3048;
        yVal = Math.max(2, altMeters);
    }

    // --- –õ–ò–ù–ò–Ø ---
    linePos[i * 3 + 0] = x;
    linePos[i * 3 + 1] = yVal;
    linePos[i * 3 + 2] = z;

    // --- –°–¢–ï–ù–ê ---
    // –ù–∏–∑ (–∑–µ–º–ª—è)
    wallPos[(i * 2 + 0) * 3 + 0] = x;
    wallPos[(i * 2 + 0) * 3 + 1] = 0;
    wallPos[(i * 2 + 0) * 3 + 2] = z;
    // –í–µ—Ä—Ö (–ø—É—Ç—å)
    wallPos[(i * 2 + 1) * 3 + 0] = x;
    wallPos[(i * 2 + 1) * 3 + 1] = yVal;
    wallPos[(i * 2 + 1) * 3 + 2] = z;
  }

  // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é –ª–∏–Ω–∏–∏
  const lineGeom = new THREE.BufferGeometry();
  lineGeom.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
  lineGeom.setDrawRange(0, 0);
  const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9 });
  trailLine = new THREE.Line(lineGeom, lineMat);
  trailGroup.add(trailLine);

  // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —Å—Ç–µ–Ω—ã
  const idx = new Uint32Array((n - 1) * 6);
  let p = 0;
  for (let i = 0; i < n - 1; i++) {
    const a = i * 2 + 0;     
    const b = i * 2 + 1;     
    const c = (i + 1) * 2 + 0; 
    const d = (i + 1) * 2 + 1; 
    idx[p++] = a; idx[p++] = b; idx[p++] = c;
    idx[p++] = b; idx[p++] = d; idx[p++] = c;
  }
  const wallGeom = new THREE.BufferGeometry();
  wallGeom.setAttribute('position', new THREE.BufferAttribute(wallPos, 3));
  wallGeom.setIndex(new THREE.BufferAttribute(idx, 1));
  wallGeom.computeVertexNormals();
  wallGeom.setDrawRange(0, 0);
  const wallMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.12, side: THREE.DoubleSide, depthWrite: false });
  trailWall = new THREE.Mesh(wallGeom, wallMat);
  trailGroup.add(trailWall);

  // --- –†–ê–ó–î–ï–õ–ò–¢–ï–õ–ò ---
  let nextMark = 1000;
  let acc = 0;

  const divIndices = []; // –ù–æ–≤—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –∏–Ω–¥–µ–∫—Å–æ–≤ –∫–∞–¥—Ä–æ–≤

  for (let i = 1; i < n; i++) {
    const x0 = linePos[(i-1)*3+0];
    const y0 = linePos[(i-1)*3+1]; // –í—ã—Å–æ—Ç–∞ –≤ –ø—Ä–µ–¥. —Ç–æ—á–∫–µ
    const z0 = linePos[(i-1)*3+2];
    
    const x1 = linePos[i*3+0];
    const y1 = linePos[i*3+1];     // –í—ã—Å–æ—Ç–∞ –≤ —Ç–µ–∫—É—â–µ–π —Ç–æ—á–∫–µ
    const z1 = linePos[i*3+2];

    const dx = x1 - x0;
    const dz = z1 - z0;
    const seg = Math.hypot(dx, dz);

    if (seg < 0.001) continue; // –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å

    while (acc + seg >= nextMark) {
      const t = (nextMark - acc) / seg;
      const xm = x0 + dx * t;
      const zm = z0 + dz * t;
      const ym = y0 + (y1 - y0) * t; // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –≤—ã—Å–æ—Ç—É

      divVerts.push(xm, 0, zm);
      divVerts.push(xm, ym, zm);
     // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞ (i) –¥–ª—è –æ–±–µ–∏—Ö –≤–µ—Ä—à–∏–Ω
      divIndices.push(i, i); 

      nextMark += 1000;
      
      // –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ (–µ—Å–ª–∏ seg –æ–≥—Ä–æ–º–Ω—ã–π)
      if (divVerts.length > 1000000) break; 
    }
    acc += seg;
  }

  if (divVerts.length > 0) {
      const divGeom = new THREE.BufferGeometry();
      divGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(divVerts), 3));
      divGeom.setDrawRange(0, 0);
      const divMat = new THREE.LineBasicMaterial({ color: 0x7CFF7C, transparent: true, opacity: 0.35 });
      trailDividers = new THREE.LineSegments(divGeom, divMat);
      trailDividers.userData.vertFrames = divIndices; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ userData
      trailGroup.add(trailDividers);
  } else {
      trailDividers = null;
  }

  scene.add(trailGroup);
}



function lerp(a, b, t) { return a + (b - a) * t; }
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return (a + diff * t + 360) % 360;
}
function mixOpt(a, b, t) {
  if (a != null && b != null) return lerp(a, b, t);
  return a != null ? a : b;
}

// ================================================================
// –í–û–°–ü–†–û–ò–ó–í–ï–î–ï–ù–ò–ï
// ================================================================
function enableControls() {
  ["btn-play","btn-stop","btn-b10","btn-b1","btn-f1","btn-f10"].forEach(id=>{
    document.getElementById(id).disabled = false;
  });
  document.getElementById("timeline").disabled = false;
}
function togglePlay() { isPlaying ? pause() : play(); }

function play() {
  if (!flightData.length) return;

  isPlaying = true;
  document.getElementById("btn-play").textContent = "‚è∏ Pause";

  if (timerId) clearInterval(timerId);
  timerId = setInterval(() => {
    // currentFrame += playbackSpeed;
    // currentFrame = Math.round(currentFrame);
        currentFrame += playbackSpeed; 
    if (currentFrame >= totalFrames) {
      currentFrame = totalFrames - 1;
      pause();
    }

    updateAllViews();
  }, FRAME_MS);
}
function pause() {
  isPlaying = false;
  document.getElementById("btn-play").textContent = "‚ñ∂Ô∏è Play";
  if (timerId) { clearInterval(timerId); timerId = null; }
}
function stopPlayback() {
  pause();
  currentFrame = 0;
  pathPoints = []; // –û—á–∏—Å—Ç–∫–∞ –ø—É—Ç–∏
  if (pathLine) {
    scene.remove(pathLine);
    pathLine = null;
  }
  updateAllViews();
}
function skipTime(sec) {
  if (!flightData.length) return;
  const frames = sec * FPS;
  currentFrame = Math.max(0, Math.min(totalFrames - 1, currentFrame + frames));
  updateAllViews();
}
function setSpeedFromInput() {
  const input = document.getElementById('speed-input');
  let val = parseFloat(input.value);
  
  if (isNaN(val) || val < 0.03125) val = 0.03125;
  
  playbackSpeed = val;
}

// –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∫–Ω–æ–ø–∫–∞–º–∏ +/-
function changeSpeedBy(direction) { // direction: +1 –∏–ª–∏ -1
  const input = document.getElementById('speed-input');
  let current = parseFloat(input.value) || 1;

  let newVal;

  if (direction > 0) { // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ (+)
      if (current < 0.25) {
          // –ï—Å–ª–∏ —Å–æ–≤—Å–µ–º –º–∞–ª–æ, —Å—Ä–∞–∑—É –ø—Ä—ã–≥–∞–µ–º –Ω–∞ 0.25
          newVal = 0.25;
      } else {
          // –ò—â–µ–º —Å–ª–µ–¥—É—é—â–µ–µ —á–∏—Å–ª–æ –∫—Ä–∞—Ç–Ω–æ–µ 0.25
          // Math.floor(current / 0.25) * 0.25 + 0.25
          // –ü—Ä–∏–º–µ—Ä: 0.3 -> floor(1.2) = 1 -> 0.25 + 0.25 = 0.5
          newVal = (Math.floor(current / 0.25) + 1) * 0.25;
      }
  } else { // –£–º–µ–Ω—å—à–µ–Ω–∏–µ (-)
      if (current <= 0.25) {
          // –ï—Å–ª–∏ 0.25 –∏–ª–∏ –º–µ–Ω—å—à–µ, –ø–∞–¥–∞–µ–º –Ω–∞ –º–∏–Ω–∏–º—É–º
          newVal = 0.03125;
      } else {
          let step = Math.ceil(current / 0.25);
          if (step * 0.25 === current) step--; // –ï—Å–ª–∏ –º—ã —Ä–æ–≤–Ω–æ –Ω–∞ —Å–µ—Ç–∫–µ, —à–∞–≥ –Ω–∞–∑–∞–¥
          newVal = step * 0.25;
      }
  }
  
  // –ó–∞—â–∏—Ç–∞ –º–∏–Ω–∏–º—É–º–∞
  if (newVal < 0.03125) newVal = 0.03125;
  
  // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (—É–±–∏—Ä–∞–µ–º —Ö–≤–æ—Å—Ç—ã —Ç–∏–ø–∞ 0.750000001)
  newVal = parseFloat(newVal.toFixed(5));
  
  input.value = newVal;
  playbackSpeed = newVal;
}

function initTimeline() {
  const tl = document.getElementById("timeline");
  tl.addEventListener("input", (e) => {
    if (!flightData.length) return;
    const v = parseFloat(e.target.value) / 100;
    currentFrame = Math.floor(v * (totalFrames - 1));
    updateAllViews();
  });
}

function updateTimelineLabel() {
  if (!flightData || !flightData.length) return;

  // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º currentFrame –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω
  if (currentFrame < 0) currentFrame = 0;
  if (currentFrame >= flightData.length) currentFrame = flightData.length - 1;

  const d = flightData[currentFrame];
  if (!d) return;

  const ms = d.timestamp || 0;
  const totalMs = flightData[flightData.length - 1].timestamp || 0;

  const fmt = (t) => {
    const sec = Math.floor(t / 1000);
    const m = Math.floor(sec / 60).toString().padStart(2, '0');
    const s = (sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  };

  document.getElementById('time-label').textContent =
    `${fmt(ms)} / ${fmt(totalMs)}`;
}


function initPathControls() {
  const btns = document.querySelectorAll('.path-btn');
  console.log("Found path buttons:", btns.length); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
  
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      // 1. –í–∏–∑—É–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ
      btns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // 2. –õ–æ–≥–∏–∫–∞
      pathMode = btn.dataset.mode;
      console.log("Path mode set to:", pathMode);
      
      updatePathVisibility(); // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    });
  });
}

// ================================================================
// –û–ë–ù–û–í–õ–ï–ù–ò–ï –í–°–ï–• –í–ò–î–û–í
// ================================================================
function updateAllViews() {
  if (!flightData || !flightData.length) return;

  // –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∏–Ω–¥–µ–∫—Å
  let idx = Math.floor(currentFrame);
  if (idx < 0) idx = 0;
  if (idx >= flightData.length) idx = flightData.length - 1;

  const d = flightData[idx];
  if (!d) return;

  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –≤–∏–¥—ã
  drawPFD(d);
  update3D(d);
  updateTrailDrawRange();
  updateDebugPanel();

  // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–ª–∞–π–Ω (–µ—Å–ª–∏ –ø–æ–ª–∑—É–Ω–æ–∫ —Å–µ–π—á–∞—Å –Ω–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞—é—Ç)
  const tl = document.getElementById("timeline");
  if (tl && !tl.matches(':active')) {
    tl.value = (idx / (totalFrames - 1 || 1)) * 100;
  }

  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å —Ç–∞–π–º–ª–∞–π–Ω–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç d.timestamp)
  updateTimelineLabel();

  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
  const timeEl = document.getElementById("current-time");
  if (timeEl) {
    const sec = idx / FPS;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    timeEl.textContent = `${m}:${s.toString().padStart(2, "0")}`;
  }

  
}

function initSelectedHeading() {
  const input = document.getElementById('input-hdg');
  input.step = "0.01"; 

  input.addEventListener('change', (e) => {
    const val = parseFloat(e.target.value);
    if (!isNaN(val)) {
      console.log(`New Runway Heading set: ${val}`);
      selectedHeading = val; // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
      
      // –ò–°–ü–û–õ–¨–ó–£–ï–ú createRunwayNumber, –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–±–æ—Ç–∞–µ—Ç
      createRunwayNumber(-40);
      
      // –ü–µ—Ä–µ—Å—á–µ—Ç —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
      calculateDistanceAndHeight(); 
      updatePath();
      updateAllViews(); 
    }
  });
}



function updateRunwayNumber() {
  // 1. –í—ã—á–∏—Å–ª—è–µ–º —Ü–∏—Ñ—Ä—É –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ selectedHeading
  // –ï—Å–ª–∏ heading 0 (–Ω–µ –∑–∞–¥–∞–Ω), —Ä–∏—Å—É–µ–º –¥–µ—Ñ–æ–ª—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä 36 –∏–ª–∏ –ø—É—Å—Ç–æ–π)
  let headingToUse = selectedHeading || 260; // –î–µ—Ñ–æ–ª—Ç 260 (26), –µ—Å–ª–∏ 0
  let numberMesh;
  let num = Math.round(headingToUse / 10);
  if (num === 0) num = 36; 
  if (num > 36) num -= 36; // –ù–∞ —Å–ª—É—á–∞–π —Å—Ç—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π > 360
  
  const text = num.toString().padStart(2, '0');
  console.log(`Updating Runway Number to: ${text} (Hdg: ${headingToUse})`);

  // 2. –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–µ—à
  if (numberMesh) {
    scene.remove(numberMesh);
    if (numberMesh.material.map) numberMesh.material.map.dispose();
    if (numberMesh.material) numberMesh.material.dispose();
    if (numberMesh.geometry) numberMesh.geometry.dispose();
  }

  // 3. –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = 'rgba(0,0,0,0)'; 
  ctx.clearRect(0, 0, 256, 256);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 140px Arial'; // –ß—É—Ç—å –º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –≤–ª–µ–∑–∞–ª–æ
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // –ü–æ–≤–æ—Ä–æ—Ç —Ü–∏—Ñ—Ä—ã (—á—Ç–æ–±—ã —á–∏—Ç–∞–ª–∞—Å—å –ø—Ä–∏ –ø–æ–¥–ª–µ—Ç–µ)
  ctx.translate(128, 128);
  ctx.rotate(-Math.PI / 2); 
  ctx.fillText(text, 0, 0);

  const tex = new THREE.CanvasTexture(canvas);
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

  const geom = new THREE.PlaneGeometry(12, 12);
  const mat = new THREE.MeshBasicMaterial({ 
    map: tex, 
    transparent: true,
    opacity: 0.9
  });
  
  numberMesh = new THREE.Mesh(geom, mat);
  numberMesh.rotation.x = -Math.PI / 2;
  
  // 4. –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
  numberMesh.position.set(0, 0.05, -40); // Z = -40
  numberMesh.renderOrder = 3;

  scene.add(numberMesh);
}

function roundTo4(num) {
    if (typeof num !== 'number') return num;
    return Math.round(num * 10000) / 10000;
}

function filterRepeats(arr) {
    if (!arr || arr.length === 0) return arr;
    const newArr = [...arr];
    let lastUniqueVal = null; 
    for (let i = 0; i < newArr.length; i++) {
        const val = newArr[i];
        if (val === null || val === undefined) continue;
        if (i === 0) {
            lastUniqueVal = val;
            continue;
        }
        if (val === lastUniqueVal) {
            newArr[i] = null;
        } else {
            lastUniqueVal = val;
        }
    }
    return newArr;
}

function fillGaps(arr) {
    const newArr = [...arr];
    const len = newArr.length;
    for (let i = 0; i < len; i++) {
        if (newArr[i] === null || newArr[i] === undefined) {
            let prevIdx = i - 1;
            while (prevIdx >= 0 && (newArr[prevIdx] === null || newArr[prevIdx] === undefined)) prevIdx--;
            let nextIdx = i + 1;
            while (nextIdx < len && (newArr[nextIdx] === null || newArr[nextIdx] === undefined)) nextIdx++;
            const prevVal = (prevIdx >= 0) ? newArr[prevIdx] : null;
            const nextVal = (nextIdx < len) ? newArr[nextIdx] : null;
            if (prevVal !== null && nextVal !== null && typeof prevVal === 'number' && typeof nextVal === 'number') {
                const totalSteps = nextIdx - prevIdx;
                const stepVal = (nextVal - prevVal) / totalSteps;
                const currentStep = i - prevIdx;
                newArr[i] = roundTo4(prevVal + (stepVal * currentStep));
            } else if (prevVal === null && nextVal !== null) {
                newArr[i] = nextVal;
            } else if (prevVal !== null && nextVal === null) {
                newArr[i] = prevVal;
            }
        }
    }
    return newArr;
}

function resampleArray(data, srcFreq, destFreq, isNumeric) {
    const ratio = destFreq / srcFreq;
    const srcLen = data.length;
    const destLen = Math.floor(srcLen * ratio);
    const result = new Array(destLen);
    for (let i = 0; i < destLen; i++) {
        const srcIndex = i / ratio;
        const p0 = Math.floor(srcIndex);
        const p1 = Math.min(p0 + 1, srcLen - 1);
        const t = srcIndex - p0;
        const val0 = data[p0];
        const val1 = data[p1];
        if (isNumeric) {
            const v0 = (val0 !== null && val0 !== undefined) ? val0 : 0;
            const v1 = (val1 !== null && val1 !== undefined) ? val1 : 0;
            
            // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: –µ—Å–ª–∏ —Ä–∞–∑–Ω–∏—Ü–∞ > 300, —Å—á–∏—Ç–∞–µ–º —ç—Ç–æ –ø–µ—Ä–µ—Ö–æ–¥–æ–º —É–≥–ª–∞ —á–µ—Ä–µ–∑ 0/360
            if (Math.abs(v1 - v0) > 300) {
                 let diff = v1 - v0;
                 // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–Ω–∏—Ü—É –ø–æ –∫—Ä–∞—Ç—á–∞–π—à–µ–º—É –ø—É—Ç–∏
                 if (diff > 180) diff -= 360;
                 else if (diff < -180) diff += 360;
                 
                 // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º –∏ –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ 0..360
                 let val = v0 + diff * t;
                 if (val < 0) val += 360;
                 if (val >= 360) val -= 360;
                 
                 result[i] = roundTo4(val);
            } else {
                 // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ª–∏–Ω–µ–π–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è
                 result[i] = roundTo4(v0 + (v1 - v0) * t);
            }
        } else {
            result[i] = val0;
        }
    }
    return result;
}

/**
 * –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –≤—ã—Å–æ—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏.
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: –µ—Å–ª–∏ –æ–Ω–æ —Å–∏–ª—å–Ω–æ –æ—Ç–∫–ª–æ–Ω—è–µ—Ç—Å—è –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ (Alt_prev + VS*dt),
 * –æ–Ω–æ –ø–æ–º–µ—á–∞–µ—Ç—Å—è –∫–∞–∫ null.
 */
function filterAltitudeByVS(altArray, vsArray, timeArray) {
    if (!altArray || !vsArray || !timeArray) return altArray;
    
    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é
    const cleanAlt = [...altArray];
    const len = cleanAlt.length;
    
    // –ò—â–µ–º –ø–µ—Ä–≤–æ–µ –≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    let lastValidIdx = cleanAlt.findIndex(v => v !== null && v !== undefined);
    if (lastValidIdx === -1) return cleanAlt;
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º—É –º–∞—Å—Å–∏–≤—É
    for (let i = lastValidIdx + 1; i < len; i++) {
        const currAlt = cleanAlt[i];
        
        // –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if (currAlt === null || currAlt === undefined) continue;
        
        // –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞
        const prevAlt = cleanAlt[lastValidIdx];
        const dt = (timeArray[i] - timeArray[lastValidIdx]) / 1000; // —Å–µ–∫
        
        // –ë–µ—Ä–µ–º VS –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞ (–∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤–∞–ª–∏–¥–Ω–æ–≥–æ, –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –ø—É—Å—Ç)
        // –ï—Å–ª–∏ VS –Ω–µ—Ç, —Å—á–∏—Ç–∞–µ–º 0
        let vs = vsArray[i];
        if (vs === null || vs === undefined) vs = vsArray[lastValidIdx] || 0;
        
        // –ü—Ä–æ–≥–Ω–æ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—ã—Å–æ—Ç—ã: (ft/min / 60) * sec
        const predictedDelta = (vs / 60) * dt;
        const predictedAlt = prevAlt + predictedDelta;
        
        // –î–æ–ø—É—Å—Ç–∏–º–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ.
        // –£ Hcor1 —à–∞–≥ 32 —Ñ—É—Ç–∞. –ü–ª—é—Å —à—É–º. –ü–ª—é—Å –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç—å VS.
        // –†–∞–∑—Ä–µ—à–∞–µ–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –Ω–∞ 64 —Ñ—É—Ç–∞ (2 —à–∞–≥–∞ –∫–≤–∞–Ω—Ç–æ–≤–∞–Ω–∏—è) + 50% –æ—Ç —Ä–∞—Å—á–µ—Ç–Ω–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        const margin = 64 + Math.abs(predictedDelta * 0.5);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞: –ù–∞—Å–∫–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞?
        // –û—Å–æ–±—ã–π —Å–ª—É—á–∞–π: –ï—Å–ª–∏ VS –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è (—Å–Ω–∏–∂–µ–Ω–∏–µ), –∞ –≤—ã—Å–æ—Ç–∞ –í–´–†–û–°–õ–ê -> —ç—Ç–æ —è–≤–Ω–∞—è –æ—à–∏–±–∫–∞ (–µ—Å–ª–∏ —Ä–æ—Å—Ç > 10 —Ñ—É—Ç–æ–≤)
        // –ù–æ —É—á–∏—Ç—ã–≤–∞–µ–º, —á—Ç–æ –ø—Ä–∏ VS ~ 0 –º–æ–∂–µ—Ç –±—ã—Ç—å —à—É–º.
        
        let isValid = true;
        
        if (vs < -100 && (currAlt - prevAlt) > 10) {
            // –Ø–≤–Ω–æ–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–µ: —Å–Ω–∏–∂–µ–Ω–∏–µ > 100fpm, –∞ –≤—ã—Å–æ—Ç–∞ –≤—ã—Ä–æ—Å–ª–∞
            isValid = false;
            // console.log(`Anomaly at ${i}: Climbing while descending. Prev: ${prevAlt}, Curr: ${currAlt}, VS: ${vs}`);
        } else if (Math.abs(currAlt - predictedAlt) > margin) {
            // –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
            isValid = false;
        }
        
        if (isValid) {
            lastValidIdx = i; // –¢–æ—á–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞, —Ç–µ–ø–µ—Ä—å –æ—Ç—Å—á–∏—Ç—ã–≤–∞–µ–º –æ—Ç –Ω–µ—ë
        } else {
            cleanAlt[i] = null; // –£–¥–∞–ª—è–µ–º –≤—ã–±—Ä–æ—Å
        }
    }
    
    return cleanAlt;
}

// ================================================================
// DEBUG –§–£–ù–ö–¶–ò–ò 
// ================================================================

let isDebugVisible = false;

function toggleDebug() {
  isDebugVisible = !isDebugVisible;
  const panel = document.getElementById('debug-panel');
  const btn = document.getElementById('btn-debug');
  
  if (!panel) return;

  if (isDebugVisible) {
    panel.style.display = 'flex';
    if (btn) btn.classList.add('active');
    updateDebugPanel(); // –°—Ä–∞–∑—É –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
  } else {
    panel.style.display = 'none';
    if (btn) btn.classList.remove('active');
  }
}

function updateDebugPanel() {
  if (!isDebugVisible) return;
  if (!flightData || flightData.length === 0) return;

  const content = document.getElementById('debug-content');
  if (!content) return;

  // –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∏–Ω–¥–µ–∫—Å
  let idx = Math.floor(currentFrame);
  if (idx < 0) idx = 0;
  if (idx >= flightData.length) idx = flightData.length - 1;

  const d = flightData[idx];
  if (!d) return;

  const keys = Object.keys(d).sort();
  let html = '';

  keys.forEach(key => {
    const rawVal = d[key];
    let displayVal = rawVal;
    let valClass = 'debug-val';

    if (rawVal === null || rawVal === undefined) {
      displayVal = 'null';
      valClass += ' null';
    } else if (typeof rawVal === 'boolean') {
      displayVal = rawVal ? 'TRUE' : 'FALSE';
    } else if (typeof rawVal === 'number') {
      if (key === 'timestamp') {
        displayVal = (rawVal / 1000).toFixed(2) + ' s';
      } else {
        displayVal = Number.isInteger(rawVal) ? rawVal : parseFloat(rawVal.toFixed(4));
      }
    }

    html += `
      <div class="debug-row">
        <span class="debug-key">${key}</span>
        <span class="${valClass}">${displayVal}</span>
      </div>
    `;
  });

  content.innerHTML = html;
}

// –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ/–ø–∞—É–∑–∞ –ø–æ –ø—Ä–æ–±–µ–ª—É
window.addEventListener('keydown', (e) => {
  // –∏–≥–Ω–æ—Ä, –µ—Å–ª–∏ —Ñ–æ–∫—É—Å –≤ –∏–Ω–ø—É—Ç–µ/–ø–æ–ª–µ –≤–≤–æ–¥–∞
  const tag = (e.target.tagName || '').toLowerCase();
  if (tag === 'input' || tag === 'textarea') return;

  if (e.code === 'Space' || e.key === ' ') {
    e.preventDefault();    // –Ω–µ –ø—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
    togglePlay();          // —Ç–∞ –∂–µ –ª–æ–≥–∏–∫–∞, —á—Ç–æ —É –∫–Ω–æ–ø–∫–∏ Play
  }
});

</script>
</body>
</html>
