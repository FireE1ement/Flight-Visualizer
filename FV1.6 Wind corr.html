<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Flight Visualizer - B737 NG PFD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: #0f172a;
      color:#fff;
      overflow:auto;
    }
    #app {
      width:100vw;
      min-height:100vh;
      display:flex;
      flex-direction:column;
    }
    header {
      padding:12px 20px;
      background:#020617;
      border-bottom:1px solid #1e293b;
      display:flex;
      align-items:center;
      gap:12px;
    }
    header h1 { font-size:20px; font-weight:600; }
    
    #content {
      flex:1;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding:10px;
      min-height:0;
    }
    .panel {
      background:#020617;
      border:1px solid #1e293b;
      border-radius:8px;
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .panel-title {
      font-size:13px;
      padding:6px 12px;
      border-bottom:1px solid #1e293b;
      background:#030712;
      text-transform:uppercase;
      letter-spacing:0.05em;
      color:#94a3b8;
      font-weight:600;
    }
    .panel-body {
      flex:1;
      position:relative;
      display:flex;
      flex-direction:column;
    }
    
    /* PFD –≤—Å–µ–≥–¥–∞ —Å–ª–µ–≤–∞ */
    #panel-pfd {
      grid-column:1;
      grid-row:1;
    }
    
    /* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ */
    #panel-views {
      grid-column:2;
      grid-row:1;
    }
    
    /* –í–∫–ª–∞–¥–∫–∏ */
    .tabs {
      display:flex;
      background:#030712;
      border-bottom:1px solid #1e293b;
    }
    .tab-btn {
      flex:1;
      padding:8px 12px;
      background:transparent;
      border:none;
      border-right:1px solid #1e293b;
      color:#94a3b8;
      font-size:12px;
      cursor:pointer;
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:0.05em;
      font-weight:600;
    }
    .tab-btn:last-child { border-right:none; }
    .tab-btn:hover { background:#1e293b; }
    .tab-btn.active {
      background:#1e40af;
      color:#fff;
    }
    
    .tab-content {
      display:none;
      flex:1;
      position:relative;
    }
    .tab-content.active {
      display:flex;
    }
    
    canvas {
      width:100%;
      height:100%;
      display:block;
    }

    #controls {
      padding:10px 16px;
      border-top:1px solid #1e293b;
      background:#020617;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }
    button {
      background:#1e293b;
      color:#e2e8f0;
      border:1px solid #334155;
      border-radius:5px;
      padding:6px 12px;
      font-size:13px;
      cursor:pointer;
      transition:all 0.2s;
      font-weight:500;
    }
    button:hover { border-color:#60a5fa; background:#334155; }
    button:disabled { opacity:0.3; cursor:not-allowed; }
    button.active {
      background:#1d4ed8;
      border-color:#60a5fa;
      color:#fff;
    }
    #file-input { display:none; }
    #timeline {
      flex:1;
      appearance:none;
      height:7px;
      background:#1e293b;
      border-radius:999px;
      outline:none;
      min-width:200px;
    }
    #timeline::-webkit-slider-thumb {
      appearance:none;
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      box-shadow:0 0 8px rgba(96,165,250,0.6);
      cursor:pointer;
    }
    #timeline::-moz-range-thumb {
      width:16px; height:16px;
      border-radius:50%;
      background:#60a5fa;
      border:none;
      cursor:pointer;
    }
    .time-label {
      font-family:"Consolas","Courier New",monospace;
      font-size:13px;
      min-width:100px;
      text-align:right;
      color:#cbd5e1;
    }
    #loading {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.8);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100;
    }
    #loading-inner {
      background:#020617;
      border:1px solid #475569;
      border-radius:10px;
      padding:20px 32px;
      text-align:center;
      font-size:15px;
    }
    #loading-inner div {
      width:40px; height:40px;
      border-radius:50%;
      border:4px solid #475569;
      border-top-color:#60a5fa;
      margin:0 auto 12px;
      animation:spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform:rotate(360deg); }
    }
    .toggle-label {
      display:flex; align-items:center; gap:6px;
      font-size:13px;
      color:#cbd5e1;
    }
    input[type="checkbox"] {
      width:16px; height:16px;
      cursor:pointer;
    }
    .control-group {
      display:flex;
      gap:6px;
      align-items:center;
    }
    .divider {
      width:1px;
      height:24px;
      background:#334155;
      margin:0 4px;
    }
    @media(max-width:1200px){
      #content {
        grid-template-columns:1fr;
        grid-template-rows: auto auto;
      }
      #panel-pfd { grid-column:1; grid-row:1; min-height:400px; }
      #panel-views { grid-column:1; grid-row:2; min-height:400px; }
    }
	
/* –ü–†–ê–í–ê–Ø DEBUG –ü–ê–ù–ï–õ–¨ */
/* –ü–†–ê–í–ê–Ø DEBUG –ü–ê–ù–ï–õ–¨ (–û–±–Ω–æ–≤–ª–µ–Ω–æ) */
#debug-panel {
  display: none;
  position: fixed;
  top: 60px;
  right: 20px;
  width: auto;
  min-width: 200px; /* –°–¥–µ–ª–∞–ª —á—É—Ç—å —É–∂–µ */
  max-width: 350px;
  
  /* –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –í–´–°–û–¢–ê –ò –°–ö–†–û–õ–õ */
  max-height: calc(100vh - 100px); /* –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ —ç–∫—Ä–∞–Ω–∞ */
  display: flex; /* Flex –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–∫—Ä–æ–ª–ª–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ */
  flex-direction: column;
  
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: -5px 5px 15px rgba(0,0,0,0.5);
  z-index: 900;
  color: #cbd5e1;
  font-family: "Consolas", "Courier New", monospace;
  font-size: 11px; /* –ß—É—Ç—å –º–µ–Ω—å—à–µ —à—Ä–∏—Ñ—Ç */
}

#debug-header {
  padding: 6px 10px; /* –ö–æ–º–ø–∞–∫—Ç–Ω–µ–µ */
  background: #1e293b;
  border-bottom: 1px solid #334155;
  border-radius: 8px 8px 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0; /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ —Å–∂–∏–º–∞–µ—Ç—Å—è */
}

#debug-content {
  padding: 5px 10px;
  overflow-y: auto; /* –í–ï–†–¢–ò–ö–ê–õ–¨–ù–´–ô –°–ö–†–û–õ–õ –¢–û–õ–¨–ö–û –ó–î–ï–°–¨ */
  flex-grow: 1; /* –ó–∞–Ω–∏–º–∞–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ –º–µ—Å—Ç–æ */
}

/* –°–∫—Ä–æ–ª–ª–±–∞—Ä –¥–ª—è Webkit (Chrome, Safari) - —á—Ç–æ–±—ã –±—ã–ª —Ç–æ–Ω–∫–∏–º */
#debug-content::-webkit-scrollbar {
  width: 6px;
}
#debug-content::-webkit-scrollbar-track {
  background: #0f172a;
}
#debug-content::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 3px;
}

.debug-row {
  display: flex;
  justify-content: space-between;
  padding: 1px 0; /* –ú–ò–ù–ò–ú–ê–õ–¨–ù–´–ô –û–¢–°–¢–£–ü –ú–ï–ñ–î–£ –°–¢–†–û–ö–ê–ú–ò */
  border-bottom: 1px solid #1e293b;
  line-height: 1.2; /* –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏ */
}
.debug-row:last-child {
  border-bottom: none;
}

.debug-key { color: #94a3b8; }
.debug-val { color: #60a5fa; font-weight: bold; text-align: right; padding-left: 10px; }
.debug-val.null { color: #ef4444; }
	
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>‚úàÔ∏è Flight Visualizer ‚Äì B737 NG PFD & Trajectory</h1>
  </header>

  <div id="content">
    <!-- PFD —Å–ª–µ–≤–∞ -->
    <div class="panel" id="panel-pfd">
      <div class="panel-title">Primary Flight Display</div>
      <div class="panel-body">
        <canvas id="canvas-pfd"></canvas>
      </div>
    </div>

    <!-- –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å —Å –≤–∫–ª–∞–¥–∫–∞–º–∏ -->
    <div class="panel" id="panel-views">
      <div class="tabs">
        <button class="tab-btn active" data-tab="tab-3d">3D –°–∞–º–æ–ª—ë—Ç</button>

      </div>
      <div class="panel-body">
        <div class="tab-content active" id="tab-3d">
          <canvas id="canvas-3d"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div id="controls">
 <!-- –ù–û–í–û–ï: –ø–æ–ª–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫—É—Ä—Å–∞ -->
  <label style="color:#cbd5e1; font-size:13px; display:flex; align-items:center; gap:6px;">
    RWY HDG:
    <input type="number" id="input-hdg" min="0" max="360" value="0" 
           style="width:70px; padding:4px 8px; background:#1e293b; border:1px solid #475569; 
                  border-radius:4px; color:#e879f9; font-size:14px; font-weight:bold; text-align:center;">
  </label>
	<div class="divider"></div>

<button id="btn-debug" class="debug-btn" onclick="toggleDebug()">üêû Debug</button>


	<div class="divider"></div>
  <div class="divider"></div>

    <button id="btn-load" onclick="loadFile()">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª</button>
    <input type="file" id="file-input" accept=".xlsx,.xls">

    <div class="divider"></div>

    <button id="btn-play" onclick="togglePlay()" disabled>‚ñ∂Ô∏è Play</button>
    <button id="btn-stop" onclick="stopPlayback()" disabled>‚èπ Stop</button>

    <div class="divider"></div>

    <button onclick="skipTime(-10)" id="btn-b10" disabled>‚èÆ -10s</button>
    <button onclick="skipTime(-1)"  id="btn-b1"  disabled>‚è™ -1s</button>
    <input type="range" id="timeline" min="0" max="100" value="0" disabled>
    <button onclick="skipTime(1)"  id="btn-f1"  disabled>+1s ‚è©</button>
    <button onclick="skipTime(10)" id="btn-f10" disabled>+10s ‚è≠</button>

    <span class="time-label" id="time-label">00:00 / 00:00</span>

    <div class="divider"></div>

    <label class="toggle-label">
      <input type="checkbox" id="chk-gs" checked onchange="toggleGsCorridor()">
      <span>–ö—É—Ä—Å/–≥–ª–∏—Å—Å–∞–¥–∞ (3D)</span>
    </label>

    <label class="toggle-label">
  	<input type="checkbox" id="chk-path" onchange="togglePath()">
 	 <span>–ü—É—Ç—å</span>
    </label>

    <div class="divider"></div>

    <span style="color:#cbd5e1; font-size:13px;">–°–∫–æ—Ä–æ—Å—Ç—å:</span>
    <div class="control-group">
      <button onclick="setSpeed(0.5)">0.5√ó</button>
      <button onclick="setSpeed(1)" class="active" id="speed-1x">1√ó</button>
      <button onclick="setSpeed(2)">2√ó</button>
      <button onclick="setSpeed(4)">4√ó</button>
    </div>
  </div>
</div>

<div id="loading">
  <div id="loading-inner">
    <div></div>
    <div>–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö‚Ä¶</div>
  </div>
</div>

<!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ Debug -->
<div id="debug-panel">
  <div id="debug-header">
    <span id="debug-title">üêû Live Data</span>
    <button onclick="toggleDebug()" style="background:none; border:none; color:#fff; cursor:pointer; font-size:16px;">&times;</button>
  </div>
  <div id="debug-content">
    <!-- –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
    <div style="padding:10px; text-align:center; color:#64748b;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>
  </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script> 

// ================================================================
// –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï
// ================================================================
const FPS = 32;
const FRAME_MS = 1000 / FPS;
const GS_ANGLE_DEG = 3; // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –≥–ª–∏—Å—Å–∞–¥–∞
const HEIGHT_PER_NM = 300; // ft –Ω–∞ 1 –º–æ—Ä—Å–∫—É—é –º–∏–ª—é –ø—Ä–∏ 3¬∞

let selectedHeading = 263;
let flightData = [];
let totalFrames = 0;
let currentFrame = 0;
let isPlaying = false;
let playbackSpeed = 1;
let timerId = null;

let lastWindUpdateMs = 0;
let cachedWindDir = 0;
let cachedWindSpd = 0;

// three.js
let scene, renderer, camera3d, airplane3d, runwayMesh, gsPlane, locPlane;
let gsVisible = true;
let orbitControls;
let pathLine = null;
let pathPoints = [];
let showPath = false;

// canvas
let pfdCanvas, pfdCtx;
let sideCanvas, sideCtx;
let topCanvas, topCtx;

// –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø—É—Ç–∏
let pathMeta = {
  totalDistanceNM: 10, // –±—É–¥–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
};

// ================================================================
// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
// ================================================================
window.addEventListener("load", () => {
  init3D();
  initPFD();
  initTimeline();
  initTabs();
  initSelectedHeading();
  document.getElementById('debug-panel').style.display = 'none';
  isDebugVisible = false;
});

// -------------------------------------------------
// –í–∫–ª–∞–¥–∫–∏
// -------------------------------------------------
function initTabs() {
  const btns = document.querySelectorAll(".tab-btn");
  btns.forEach(btn => {
    btn.addEventListener("click", () => {
      const target = btn.dataset.tab;
      btns.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));
      document.getElementById(target).classList.add("active");
      
      // –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∫–ª–∞–¥–∫–∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º, –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
      if (flightData.length) {
        resize3D();
        resizeSide();
        resizeTop();
        updateAllViews();
      }
    });
  });
}

// -------------------------------------------------
// 3D —Å—Ü–µ–Ω–∞
// -------------------------------------------------
// ================================================================
// 3D –°–¶–ï–ù–ê - –ü–û–õ–ù–ê–Ø –ü–ï–†–ï–î–ï–õ–ö–ê
// ================================================================

function init3D() {
  const canvas = document.getElementById("canvas-3d");
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —Ç–µ–Ω–∏
  resize3D();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏: —Ç—É–º–∞–Ω –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 2000–º, –ø–æ–ª–Ω–∞—è –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–∞ 8000–º
  scene.fog = new THREE.Fog(0x87ceeb, 2000, 8000);

  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(500, 800, 300); // –ø–æ–¥–Ω–∏–º–∞–µ–º –≤—ã—à–µ –∏ –¥–∞–ª—å—à–µ
  sun.castShadow = true;
  
  // –£–í–ï–õ–ò–ß–ï–ù–ê –æ–±–ª–∞—Å—Ç—å —Ç–µ–Ω–µ–π –¥–ª—è –ø–æ–∫—Ä—ã—Ç–∏—è –≤—Å–µ–π –ø–æ–ª–æ—Å—ã
  sun.shadow.camera.left = -2000;
  sun.shadow.camera.right = 2000;
  sun.shadow.camera.top = 2000;
  sun.shadow.camera.bottom = -2000;
  sun.shadow.camera.near = 100;
  sun.shadow.camera.far = 3000;
  sun.shadow.mapSize.width = 4096; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ç–µ–Ω–µ–π
  sun.shadow.mapSize.height = 4096;
  sun.shadow.bias = -0.0001; // —É—Å—Ç—Ä–∞–Ω—è–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Ç–µ–Ω–µ–π
  
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));

camera3d = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 20000);
  camera3d.position.set(0, 50, 100);

  // OrbitControls –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
orbitControls = new THREE.OrbitControls(camera3d, canvas);
orbitControls.enableDamping = false;
orbitControls.enablePan = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
orbitControls.minDistance = 10;
orbitControls.maxDistance = 1000;
orbitControls.maxPolarAngle = Math.PI / 2 + 0.3;
orbitControls.autoRotate = false;  // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–ø–æ–≤–æ—Ä–æ—Ç



  createGround();
  createRunway();
  createGlideSlopeCorridor();
  createAirplane();

  window.addEventListener("resize", resize3D);

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º resize –ø–æ—Å–ª–µ –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
  // —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–æ–ª—É—á–∏–ª —Å–≤–æ–∏ —Ä–∞–∑–º–µ—Ä—ã
    setTimeout(() => {
    resize3D();
  }, 100);

  // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è controls
  animate3D();
}

function createGround() {
  // –ó–µ–º–ª—è: –î–µ–ª–∞–µ–º –ø–æ–º–µ–Ω—å—à–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä 10x10 –∫–º), —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –±—É–¥–µ—Ç –µ–∑–¥–∏—Ç—å –∑–∞ –Ω–∞–º–∏
  const groundGeom = new THREE.PlaneGeometry(15000, 15000);
  const groundMat = new THREE.MeshLambertMaterial({ 
    color: 0x228b22,
    depthWrite: false 
  });
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é (–∏–ª–∏ —Å–≤–æ–π—Å—Ç–≤–æ window), —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –≤ animate3D
  window.dynamicGround = new THREE.Mesh(groundGeom, groundMat);
  
  window.dynamicGround.rotation.x = -Math.PI / 2;
  window.dynamicGround.position.y = -0.1; 
  window.dynamicGround.receiveShadow = true;
  window.dynamicGround.renderOrder = 0; 
  
  scene.add(window.dynamicGround);
}

// –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–ª—è OrbitControls
function animate3D() {
  requestAnimationFrame(animate3D);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã
  if (airplane3d && orbitControls && camera3d) {
    updateCamera();

    // === –î–û–ë–ê–í–õ–ï–ù–û: –î–≤–∏–≥–∞–µ–º –∑–µ–º–ª—é –∑–∞ —Å–∞–º–æ–ª–µ—Ç–æ–º ===
    if (window.dynamicGround) {
        window.dynamicGround.position.x = airplane3d.position.x;
        window.dynamicGround.position.z = airplane3d.position.z;
    }
    // =============================================
  }
  
  if (renderer && camera3d && scene) {
    renderer.render(scene, camera3d);
  }
}



function resize3D() {
  const canvas = document.getElementById('canvas-3d');
  const parent = canvas.parentElement;
  if (!parent) return;
  
  const w = parent.clientWidth;
  const h = parent.clientHeight;
  if (!renderer || !camera3d || !w || !h) return;
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π pixel ratio
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(w, h, false);
  
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
}

function createRunway() {
  const runwayLen = 3500;
  const runwayWidth = 60;
  
  // –ì–µ–æ–º–µ—Ç—Ä–∏—è –ø–æ–ª–æ—Å—ã
  const rwGeom = new THREE.PlaneGeometry(runwayWidth, runwayLen);
  const rwMat = new THREE.MeshLambertMaterial({ 
    color: 0x3a3a3a,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  runwayMesh = new THREE.Mesh(rwGeom, rwMat);
  runwayMesh.rotation.x = -Math.PI / 2;
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã –Ω–∞—á–∞–ª–æ (—Ç–æ—Ä–µ—Ü) –±—ã–ª–æ –Ω–∞ Z = 30 (–¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã),
  // –∞ –æ—Å—Ç–∞–ª—å–Ω–∞—è –ø–æ–ª–æ—Å–∞ —É—Ö–æ–¥–∏–ª–∞ –≤ –º–∏–Ω—É—Å.
  // –¶–µ–Ω—Ç—Ä –ø–æ–ª–æ—Å—ã –±—É–¥–µ—Ç –≤ Z = 30 - (3500/2) = -1720
  runwayMesh.position.set(0, 0, 30 - runwayLen / 2); 
  runwayMesh.receiveShadow = true;
  runwayMesh.renderOrder = 1;
  scene.add(runwayMesh);

  // –ú–∞—Ç–µ—Ä–∏–∞–ª —Ä–∞–∑–º–µ—Ç–∫–∏
  const lineMat = new THREE.MeshBasicMaterial({ 
    color: 0xffffff,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è (—à—Ç—Ä–∏—Ö 30–º —á–µ—Ä–µ–∑ 30–º)
  // –†–∏—Å—É–µ–º –æ—Ç —Ç–æ—Ä—Ü–∞ (Z=30) –¥–æ –∫–æ–Ω—Ü–∞ (Z=-3470)
  for (let z = -60; z > (30 - runwayLen); z -= 60) {
    const segmentGeom = new THREE.PlaneGeometry(1.2, 30);
    const segment = new THREE.Mesh(segmentGeom, lineMat);
    segment.rotation.x = -Math.PI / 2;
    segment.position.set(0, 0.01, z - 15); // –¶–µ–Ω—Ç—Ä —Å–µ–≥–º–µ–Ω—Ç–∞
    segment.renderOrder = 2;
    scene.add(segment);
  }

  // –ü–æ—Ä–æ–≥ –í–ü–ü ("–ó–µ–±—Ä–∞") –Ω–∞ Z = 20 (—á—É—Ç—å –æ—Ç—Å—Ç—É–ø–∏–≤ –æ—Ç –∫—Ä–∞—è 30)
  const thresholdZ = 7.5;
  const stripeGeom = new THREE.PlaneGeometry(3.6, 45); // –ü–æ–ª–æ—Å–∫–∏ —à–∏—Ä–∏–Ω–æ–π 3.6–º, –¥–ª–∏–Ω–æ–π 45–º
  // 12 –ø–æ–ª–æ—Å –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç ICAO –¥–ª—è 60–º –ø–æ–ª–æ—Å—ã)
  for (let i = 0; i < 12; i++) {
    // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ç -27 –¥–æ +27
    const x = -27 + i * (54/11);
    const stripe = new THREE.Mesh(stripeGeom, lineMat);
    stripe.rotation.x = -Math.PI / 2;
    stripe.position.set(x, 0.01, thresholdZ);
    stripe.renderOrder = 2;
    scene.add(stripe);
  }

  // –ó–û–ù–ê –ü–†–ò–ó–ï–ú–õ–ï–ù–ò–Ø (Touchdown Zone)
  // –¢–æ—á–∫–∞ –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è (TDZ) –æ–±—ã—á–Ω–æ –≤ 300–º (1000ft) –æ—Ç —Ç–æ—Ä—Ü–∞.
  // –¢–æ—Ä–µ—Ü Z=30. –ó–Ω–∞—á–∏—Ç TDZ Z = 30 - 300 = -270.
  // –í –Ω–∞—à–µ–º –∫–æ–¥–µ update3D –º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ -215. –î–∞–≤–∞–π—Ç–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º.
  // –ü—É—Å—Ç—å —Ü–µ–ª–µ–≤–∞—è —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –±—É–¥–µ—Ç -270.
  // (–ù–µ –∑–∞–±—É–¥—å—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å sceneTouchdownZ –≤ update3D!)
  
  const touchdownZ = -270; 

  // –ë–æ–ª—å—à–∏–µ –±–ª–æ–∫–∏ (Aiming Point) - –Ω–∞—á–∞–ª–æ –Ω–∞ 400–º (1312ft) –æ—Ç —Ç–æ—Ä—Ü–∞ –ø–æ ICAO, 
  // –Ω–æ —á–∞—Å—Ç–æ 300–º (1000ft). –û—Å—Ç–∞–≤–∏–º –Ω–∞ 300–º.
  const aimingBlockGeom = new THREE.PlaneGeometry(10, 45); // –®–∏—Ä–æ–∫–∏–µ –±–ª–æ–∫–∏
  [-12, 12].forEach(x => {
      const block = new THREE.Mesh(aimingBlockGeom, lineMat);
      block.rotation.x = -Math.PI / 2;
      block.position.set(x, 0.01, touchdownZ);
      block.renderOrder = 2;
      scene.add(block);
  });

  // –û—Å—Ç–∞–ª—å–Ω–∞—è —Ä–∞–∑–º–µ—Ç–∫–∞ –∑–æ–Ω—ã –ø—Ä–∏–∑–µ–º–ª–µ–Ω–∏—è (–ø–∞—Ä—ã –∏ —Ç—Ä–æ–π–∫–∏ –ø–æ–ª–æ—Å)
  // –†–∏—Å—É—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 150–º (500ft) –æ—Ç —Ç–æ—Ä—Ü–∞.
  // 150–º: Z = 30 - 150 = -120
  // 300–º: (—É–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–ª–∏ Aiming Point)
  // 450–º: Z = -420
  // 600–º: Z = -570
  // 750–º: Z = -720
  // 900–º: Z = -870

  const markGeom = new THREE.PlaneGeometry(3, 22);
  const marks = [
      { z: -120, count: 3 }, // –¢—Ä–∏ –ø–æ–ª–æ—Å–∫–∏
      { z: -420, count: 2 }, // –î–≤–µ
      { z: -570, count: 2 },
      { z: -720, count: 1 }, // –û–¥–Ω–∞
      { z: -870, count: 1 }
  ];

  marks.forEach(m => {
      for (let side = -1; side <= 1; side += 2) { // –õ–µ–≤–æ/–ü—Ä–∞–≤–æ
          for (let k = 0; k < m.count; k++) {
              // –°–º–µ—â–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ –≥—Ä—É–ø–ø—ã
              const offset = (k - (m.count-1)/2) * 5; 
              const x = side * (12 + offset + (m.count > 1 ? 5 : 0)); // –°–¥–≤–∏–≥–∞–µ–º –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
              // –£–ø—Ä–æ—â–µ–Ω–Ω–æ: –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞–≤–∏–º –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏
              const finalX = side * (9 + k*5 + 8); 
              
              const mark = new THREE.Mesh(markGeom, lineMat);
              mark.rotation.x = -Math.PI / 2;
              mark.position.set(finalX, 0.01, m.z);
              mark.renderOrder = 2;
              scene.add(mark);
          }
      }
  });

  // –ë–æ–∫–æ–≤—ã–µ –ª–∏–Ω–∏–∏ (Side stripes)
  const sideGeom = new THREE.PlaneGeometry(1.8, runwayLen);
  [-28.5, 28.5].forEach(x => {
    const side = new THREE.Mesh(sideGeom, lineMat);
    side.rotation.x = -Math.PI / 2;
    side.position.set(x, 0.01, 30 - runwayLen / 2);
    side.renderOrder = 2;
    scene.add(side);
  });

  // –ù–æ–º–µ—Ä –í–ü–ü
  createRunwayNumber(-40); // Z=50 (–ø–µ—Ä–µ–¥ –∑–µ–±—Ä–æ–π)
}


function createRunwayNumber(z) {
  const canvas = document.createElement('canvas');
  canvas.width = 512; // —É–≤–µ–ª–∏—á–µ–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 180px Arial'; // —É–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–º–µ—Ä –í–ü–ü –∏–∑ selectedHeading
  const runwayNumber = Math.round(selectedHeading / 10) % 36;
  const displayNumber = runwayNumber === 0 ? 36 : runwayNumber;
  
  ctx.fillText(displayNumber.toString().padStart(2, '0'), 256, 128);
  
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;
  
  const numMat = new THREE.MeshBasicMaterial({ 
    map: texture, 
    transparent: true,
    depthWrite: true,
    side: THREE.DoubleSide,
    polygonOffset: true,
    polygonOffsetFactor: -3,
    polygonOffsetUnits: -3
  });
  
  const numGeom = new THREE.PlaneGeometry(50, 25);
  
  // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –Ω–æ–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å
  const oldNumber = scene.getObjectByName('runwayNumber');
  if (oldNumber) scene.remove(oldNumber);
  
  const number = new THREE.Mesh(numGeom, numMat);
  number.rotation.x = -Math.PI / 2;
  number.position.set(0, 0.02, z); // —á—É—Ç—å –ø—Ä–∏–ø–æ–¥–Ω—è—Ç–æ –Ω–∞–¥ –ø–æ–ª–æ—Å–æ–π
  number.name = 'runwayNumber';
  number.renderOrder = 3; // —Ä–µ–Ω–¥–µ—Ä–∏–º –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
  scene.add(number);
}

function createGlideSlopeCorridor() {
  const corridorGroup = new THREE.Group();
  corridorGroup.visible = true;

  // –ì–õ–ò–°–°–ê–î–ê (—Ä–∞—Å—à–∏—Ä—è—é—â–∞—è—Å—è —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω–∞—è –ø–ª–æ—Å–∫–æ—Å—Ç—å)
  // –ì–ª–∏—Å—Å–∞–¥–∞ 3¬∞ –æ—Ç —Ç–æ—á–∫–∏ –Ω–∞ –≤—ã—Å–æ—Ç–µ ~300–º –¥–æ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const gsAngle = 3 * Math.PI / 180; // 3 –≥—Ä–∞–¥—É—Å–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö
  
  // –¢–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –Ω–∞ z = -215 (–±–æ–ª—å—à–∏–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏)
  const touchdownZ = -215;
  
  // –ù–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã: –Ω–∞ –≤—ã—Å–æ—Ç–µ 300–º, —ç—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ 300/tan(3¬∞) ‚âà 5730–º –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è
  const gsStartZ = touchdownZ + 5730; // ‚âà 5515
  const gsEndZ = touchdownZ; // —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è
  const gsStartHeight = 300; // –Ω–∞—á–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ 300–º
  const gsEndHeight = 0; // –≤—ã—Å–æ—Ç–∞ –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  
  const gsLength = gsStartZ - gsEndZ; // –¥–ª–∏–Ω–∞ –ø—Ä–æ–µ–∫—Ü–∏–∏ –Ω–∞ –∑–µ–º–ª—é
  const gsWidthStart = 300; // —à–∏—Ä–∏–Ω–∞ –≤ –Ω–∞—á–∞–ª–µ (—Ä–∞—Å—à–∏—Ä–µ–Ω–∞)
  const gsWidthEnd = 60; // —à–∏—Ä–∏–Ω–∞ –≤ –∫–æ–Ω—Ü–µ (—à–∏—Ä–∏–Ω–∞ –ø–æ–ª–æ—Å—ã)
  
  // –°–æ–∑–¥–∞—ë–º —Ç—Ä–∞–ø–µ—Ü–∏–µ–≤–∏–¥–Ω—É—é –≥–µ–æ–º–µ—Ç—Ä–∏—é
  const gsGeom = new THREE.BufferGeometry();
  
  // –í–µ—Ä—à–∏–Ω—ã —Ç—Ä–∞–ø–µ—Ü–∏–∏ (4 —É–≥–ª–∞)
  const vertices = new Float32Array([
    // –ù–∏–∂–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (—É —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è, z = 0 –≤ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
    -gsWidthEnd/2, -gsLength/2, 0,  // –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π
    gsWidthEnd/2, -gsLength/2, 0,   // –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π
    
    // –í–µ—Ä—Ö–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã (–≤ –Ω–∞—á–∞–ª–µ –≥–ª–∏—Å—Å–∞–¥—ã, z = gsLength/2)
    -gsWidthStart/2, gsLength/2, 0, // –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
    gsWidthStart/2, gsLength/2, 0   // –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
  ]);
  
  // –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤, –æ–±—Ä–∞–∑—É—é—â–∏—Ö —Ç—Ä–∞–ø–µ—Ü–∏—é
  const indices = new Uint16Array([
    0, 1, 2,  // –ø–µ—Ä–≤—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
    1, 3, 2   // –≤—Ç–æ—Ä–æ–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
  ]);
  
  gsGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  gsGeom.setIndex(new THREE.BufferAttribute(indices, 1));
  gsGeom.computeVertexNormals();
  
  const gsMat = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.05,
    side: THREE.DoubleSide,
    depthWrite: false
  });

  gsPlane = new THREE.Mesh(gsGeom, gsMat);
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≥–ª–∏—Å—Å–∞–¥—É
  const gsCenterZ = (gsStartZ + gsEndZ) / 2;
  const gsCenterHeight = (gsStartHeight + gsEndHeight) / 2;
  
  gsPlane.position.set(0, gsCenterHeight, gsCenterZ);
  gsPlane.rotation.x = Math.PI / 2 - gsAngle; // –Ω–∞–∫–ª–æ–Ω –Ω–∞ 3¬∞
  
  corridorGroup.add(gsPlane);

  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è –≥–ª–∏—Å—Å–∞–¥—ã –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫—É—Ä—Å–∞
  const gsLineGeometry = new THREE.BufferGeometry();
  const gsLineVertices = new Float32Array([
    0, gsStartHeight, gsStartZ,  // –Ω–∞—á–∞–ª–æ –≥–ª–∏—Å—Å–∞–¥—ã
    0, gsEndHeight, gsEndZ       // –∫–æ–Ω–µ—Ü –≤ —Ç–æ—á–∫–µ –∫–∞—Å–∞–Ω–∏—è
  ]);
  gsLineGeometry.setAttribute('position', new THREE.BufferAttribute(gsLineVertices, 3));
  
  const gsLineMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 3,
    transparent: true,
    opacity: 0.5
  });
  
  const gsLine = new THREE.Line(gsLineGeometry, gsLineMaterial);
  corridorGroup.add(gsLine);

  // –ë–æ–∫–æ–≤—ã–µ –ª–∏–Ω–∏–∏ —Ç—Ä–∞–ø–µ—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏ –≥—Ä–∞–Ω–∏—Ü
  const leftBorder = new THREE.BufferGeometry();
  const leftVertices = new Float32Array([
    -gsWidthEnd/2, gsEndHeight, gsEndZ,
    -gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  leftBorder.setAttribute('position', new THREE.BufferAttribute(leftVertices, 3));
  
  const borderMaterial = new THREE.LineBasicMaterial({ 
    color: 0xff00ff, 
    linewidth: 2,
    transparent: true,
    opacity: 0.2
  });
  
  const leftBorderLine = new THREE.Line(leftBorder, borderMaterial);
  corridorGroup.add(leftBorderLine);

  const rightBorder = new THREE.BufferGeometry();
  const rightVertices = new Float32Array([
    gsWidthEnd/2, gsEndHeight, gsEndZ,
    gsWidthStart/2, gsStartHeight, gsStartZ
  ]);
  rightBorder.setAttribute('position', new THREE.BufferAttribute(rightVertices, 3));
  
  const rightBorderLine = new THREE.Line(rightBorder, borderMaterial.clone());
  corridorGroup.add(rightBorderLine);

  scene.add(corridorGroup);
  locPlane = corridorGroup;
}

function createAirplane() {
  if (airplane3d) scene.remove(airplane3d);

  airplane3d = new THREE.Group();
  
  // –î–æ–±–∞–≤–ª—è–µ–º DoubleSide, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å "—á–µ—Ä–Ω—ã–º–∏" –≥—Ä–∞–Ω—è–º–∏
  const matWhite = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide }); 
  const matGrey = new THREE.MeshPhongMaterial({ color: 0xcccccc, side: THREE.DoubleSide });  
  const matBlue = new THREE.MeshPhongMaterial({ color: 0x0077be, side: THREE.DoubleSide });  
  const matDark = new THREE.MeshPhongMaterial({ color: 0x333333 });  
  const matMetal = new THREE.MeshPhongMaterial({ color: 0x999999 }); 

  const bodyRadius = 1.9;
  const bodyLength = 28.0; 

  // === 1. –§–Æ–ó–ï–õ–Ø–ñ ===
  const bodyGeom = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyLength, 32);
  const body = new THREE.Mesh(bodyGeom, matWhite);
  body.rotation.z = Math.PI / 2;
  body.castShadow = true;
  airplane3d.add(body);

  // === 2. –ù–û–° ===
  const noseGeom = new THREE.SphereGeometry(bodyRadius, 32, 16);
  noseGeom.applyMatrix4(new THREE.Matrix4().makeScale(2.0, 1, 1)); 
  const nose = new THREE.Mesh(noseGeom, matWhite);
  nose.position.x = bodyLength / 2;
  airplane3d.add(nose);



  // === 3. –•–í–û–°–¢ ===
  const tailLen = 3.5;
  const tailGeom = new THREE.CylinderGeometry(0.6, bodyRadius, tailLen, 32);
  const tail = new THREE.Mesh(tailGeom, matWhite);
  tail.rotation.z = Math.PI / 2;
  tail.position.set(-bodyLength / 2 - tailLen / 2, 0, 0);
  airplane3d.add(tail);

  // === 4. –ö–†–´–õ–¨–Ø (–ß–µ—Å—Ç–Ω—ã–µ Shape –¥–ª—è –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω) ===
  // Shape —Ä–∏—Å—É–µ—Ç—Å—è –≤ XY.
  // X - –≤–¥–æ–ª—å —Ñ—é–∑–µ–ª—è–∂–∞ (–º–∏–Ω—É—Å = –Ω–∞–∑–∞–¥). Y - —Ä–∞–∑–º–∞—Ö.
  
  // –ü–†–ê–í–û–ï –ö–†–´–õ–û (Y < 0)
  const rWingShape = new THREE.Shape();
  rWingShape.moveTo(0, 0); 
  rWingShape.lineTo(-7, 0); 
  rWingShape.lineTo(-13, -16); // Y = -16 (–í–ø—Ä–∞–≤–æ)
  rWingShape.lineTo(-6, -16); 
  rWingShape.lineTo(0, 0); 

  const rWingGeom = new THREE.ExtrudeGeometry(rWingShape, { depth: 0.4, bevelEnabled: false });
  rWingGeom.translate(0, 0, -0.2); // –¶–µ–Ω—Ç—Ä –ø–æ Z

  const rWing = new THREE.Mesh(rWingGeom, matGrey);
  rWing.rotation.x = Math.PI / 2; // –ö–ª–∞–¥–µ–º –≤ –ø–ª–æ—Å–∫–æ—Å—Ç—å XZ
  rWing.rotation.z = 0.05; 
  rWing.position.set(4, -1.0, -1); 
  rWing.castShadow = true;
  airplane3d.add(rWing);

  // –õ–ï–í–û–ï –ö–†–´–õ–û (Y > 0)
  const lWingShape = new THREE.Shape();
  lWingShape.moveTo(0, 0); 
  lWingShape.lineTo(-7, 0); 
  lWingShape.lineTo(-13, 16); // Y = +16 (–í–ª–µ–≤–æ)
  lWingShape.lineTo(-6, 16); 
  lWingShape.lineTo(0, 0); 

  const lWingGeom = new THREE.ExtrudeGeometry(lWingShape, { depth: 0.4, bevelEnabled: false });
  lWingGeom.translate(0, 0, -0.2);

  const lWing = new THREE.Mesh(lWingGeom, matGrey);
  lWing.rotation.x = Math.PI / 2;
  lWing.rotation.z = -0.05; 
  lWing.position.set(4, -1.0, 1); 
  lWing.castShadow = true;
  airplane3d.add(lWing);


  // === 5. –ö–ò–õ–¨ ===
  const vShape = new THREE.Shape();
  vShape.moveTo(0, 0); 
  vShape.lineTo(-6, 0); 
  vShape.lineTo(-9, 7.5); 
  vShape.lineTo(-4, 7.5); 
  vShape.lineTo(0, 0);

  const vGeom = new THREE.ExtrudeGeometry(vShape, { depth: 0.4, bevelEnabled: false });
  vGeom.translate(0, 0, -0.2);

  const vTail = new THREE.Mesh(vGeom, matBlue);
  vTail.position.set(-10, 1.5, 0);
  vTail.castShadow = true;
  airplane3d.add(vTail);


  // === 6. –°–¢–ê–ë–ò–õ–ò–ó–ê–¢–û–†–´ (–ß–µ—Å—Ç–Ω—ã–µ Shape) ===
  
  // –ü–†–ê–í–´–ô (Y < 0)
  const rStabShape = new THREE.Shape();
  rStabShape.moveTo(0, 0);
  rStabShape.lineTo(-4, 0);
  rStabShape.lineTo(-6, -5.5);
  rStabShape.lineTo(-2.5, -5.5);
  rStabShape.lineTo(0, 0);

  const rStabGeom = new THREE.ExtrudeGeometry(rStabShape, { depth: 0.3, bevelEnabled: false });
  rStabGeom.translate(0, 0, -0.15);

  const rStab = new THREE.Mesh(rStabGeom, matGrey);
  rStab.rotation.x = Math.PI / 2;
  rStab.position.set(-12, 1.0, -0.5); 
  rStab.castShadow = true;
  airplane3d.add(rStab);

  // –õ–ï–í–´–ô (Y > 0)
  const lStabShape = new THREE.Shape();
  lStabShape.moveTo(0, 0);
  lStabShape.lineTo(-4, 0);
  lStabShape.lineTo(-6, 5.5);
  lStabShape.lineTo(-2.5, 5.5);
  lStabShape.lineTo(0, 0);

  const lStabGeom = new THREE.ExtrudeGeometry(lStabShape, { depth: 0.3, bevelEnabled: false });
  lStabGeom.translate(0, 0, -0.15);

  const lStab = new THREE.Mesh(lStabGeom, matGrey);
  lStab.rotation.x = Math.PI / 2;
  lStab.position.set(-12, 1.0, 0.5);
  lStab.castShadow = true;
  airplane3d.add(lStab);

  // === 7. –®–ê–°–°–ò ===
  const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
  wheelGeom.rotateX(Math.PI / 2); 

  // –ù–æ—Å
  const noseStrut = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 2.0), matMetal);
  noseStrut.position.set(13, -2.5, 0); 
  airplane3d.add(noseStrut);
  const nWheel = new THREE.Mesh(wheelGeom, matDark);
  nWheel.position.set(13, -3.5, 0);
  airplane3d.add(nWheel);

  // –û—Å–Ω–æ–≤–Ω—ã–µ
  const mainStrutL = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5), matMetal);
  mainStrutL.position.set(-1, -2.5, 3.0); 
  airplane3d.add(mainStrutL);
  const mWheelL = new THREE.Mesh(wheelGeom, matDark);
  mWheelL.position.set(-1, -3.8, 3.0);
  airplane3d.add(mWheelL);

  const mainStrutR = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5), matMetal);
  mainStrutR.position.set(-1, -2.5, -3.0);
  airplane3d.add(mainStrutR);
  const mWheelR = new THREE.Mesh(wheelGeom, matDark);
  mWheelR.position.set(-1, -3.8, -3.0);
  airplane3d.add(mWheelR);


  // –§–ò–ù–ê–õ
  airplane3d.rotation.y = Math.PI / 2;
  const gearHeight = 4.0;
  airplane3d.position.set(0, gearHeight, 0);

  scene.add(airplane3d);
}

function toggleGsCorridor() {
  gsVisible = document.getElementById("chk-gs").checked;
  if (locPlane) locPlane.visible = gsVisible;
  if (gsPlane) gsPlane.visible = gsVisible;
  if (renderer && camera3d) renderer.render(scene, camera3d);
}

function togglePath() {
  showPath = document.getElementById('chk-path').checked;
  if (pathLine) {
    pathLine.visible = showPath;
  }
  if (renderer && camera3d) {
    renderer.render(scene, camera3d);
  }
}


function update3D(d) {
  if (!airplane3d) return;
  

  
  // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–∂–µ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –≤ calculateDistanceAndHeight
  // –ù–∞–º –Ω—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–º–µ—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –ø–æ–ª–æ—Å—ã –≤ —Å—Ü–µ–Ω–µ (z = -215 - —ç—Ç–æ —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è –≤ 3D –º–∏—Ä–µ)
  const sceneTouchdownZ = -270; 
  
  // –í calculateDistanceAndHeight: 0 = —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è, –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ Z = –ø–æ–¥–ª–µ—Ç.
  // –í scene: -270 = —Ç–æ—á–∫–∞ –∫–∞—Å–∞–Ω–∏—è.
  // –ó–Ω–∞—á–∏—Ç:
  let zPos = sceneTouchdownZ + d.zPos; 
  let xPos = d.xPos; // –ë–æ–∫–æ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ (–º–µ—Ç—Ä—ã)
  
  const gearHeight = 4;
  const ra = d.radioAltitude; 
  let yPos;

  // –õ–æ–≥–∏–∫–∞ "–ü—Ä–∏–ª–∏–ø–∞–Ω–∏—è" –∫ –ø–æ–ª–æ—Å–µ
  // –ï—Å–ª–∏ RA <= -4 (–∏–ª–∏ —á—É—Ç—å –±–æ–ª—å—à–µ —Å –∑–∞–ø–∞—Å–æ–º, –Ω–∞–ø—Ä–∏–º–µ—Ä <= 0), —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –º—ã –µ–¥–µ–º
  if (ra !== null && ra !== undefined && ra <= -4) { 
    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ –∑–µ–º–ª–µ
    yPos = gearHeight;
  } else {
    // –í –≤–æ–∑–¥—É—Ö–µ
    // –ë–µ—Ä–µ–º –±–∞—Ä–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫—É—é –≤—ã—Å–æ—Ç—É (–ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—É—é –≤ –º–µ—Ç—Ä—ã)
    let altMeters = (d.correctedAltitude || 0) * 0.3048;
    
    // –ù–æ –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ–º —É–π—Ç–∏ –ø–æ–¥ –∑–µ–º–ª—é, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –±–∞—Ä–æ–≤—ã—Å–æ—Ç–∞ –≤—Ä–µ—Ç
    yPos = Math.max(gearHeight, altMeters);
  }
  
  airplane3d.position.set(xPos, yPos, zPos);
  
  // –í—Ä–∞—â–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
  const runwayHeading = selectedHeading;
  const planeHeading = d.heading || runwayHeading;
  let headingDiff = planeHeading - runwayHeading;
  
  // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —É–≥–ª–∞
  while (headingDiff > 180) headingDiff -= 360;
  while (headingDiff < -180) headingDiff += 360;
  
  const yaw = Math.PI/2 - THREE.MathUtils.degToRad(headingDiff);
  const pitch = THREE.MathUtils.degToRad(d.pitch);
  const roll = THREE.MathUtils.degToRad(d.roll);

  const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), roll);
  const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitch);
  const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

  airplane3d.quaternion.copy(qYaw);
  airplane3d.quaternion.multiply(qPitch);
  airplane3d.quaternion.multiply(qRoll);

  // –¢—Ä–µ–π–ª (–ø—É—Ç—å)
  pathPoints.push(new THREE.Vector3(xPos, yPos, zPos));
  if (pathPoints.length > 500) pathPoints.shift();
  
  if (pathLine) scene.remove(pathLine);
  
  if (pathPoints.length > 1) {
    const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
    const pathMaterial = new THREE.LineBasicMaterial({ 
      color: 0x00ff00, 
      linewidth: 2,
      transparent: true,
      opacity: 0.8
    });
    pathLine = new THREE.Line(pathGeometry, pathMaterial);
    pathLine.visible = showPath;
    scene.add(pathLine);
  }
}


function updateCamera() {
  if (!airplane3d || !orbitControls || !camera3d) return;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Å—Ñ–µ—Ä–∏—á–µ—Å–∫—É—é –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ target
  const spherical = new THREE.Spherical();
  const offset = new THREE.Vector3();
  
  // –í—ã—á–∏—Å–ª—è–µ–º offset –æ—Ç —Å—Ç–∞—Ä–æ–≥–æ target
  offset.copy(camera3d.position).sub(orbitControls.target);
  spherical.setFromVector3(offset);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º target –Ω–∞ –ø–æ–∑–∏—Ü–∏—é —Å–∞–º–æ–ª—ë—Ç–∞
  orbitControls.target.copy(airplane3d.position);
  
  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–æ—Ç –∂–µ offset –∫ –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
  offset.setFromSpherical(spherical);
  camera3d.position.copy(airplane3d.position).add(offset);
  
  // –ö–∞–º–µ—Ä–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ —Å–∞–º–æ–ª—ë—Ç
  camera3d.lookAt(airplane3d.position);
}

// ========================================
// PFD - –ê–î–ê–ü–¢–ò–í–ù–ê–Ø –í–ï–†–°–ò–Ø
// ========================================

function initPFD() {
  pfdCanvas = document.getElementById('canvas-pfd');
  pfdCtx = pfdCanvas.getContext('2d');
  resizePFD();
  window.addEventListener('resize', resizePFD);
  drawPFD(null);
}

function resizePFD() {
  const rect = pfdCanvas.parentElement.getBoundingClientRect();
  pfdCanvas.width = rect.width;
  pfdCanvas.height = rect.height;
}

// PFD - –≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (–∞–¥–∞–ø—Ç–∏–≤–Ω–∞—è)
function drawPFD(data) {
  const ctx = pfdCtx;
  const w = pfdCanvas.width;
  const h = pfdCanvas.height;
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);
  
  if (!data) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '18px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö', w / 2, h / 2);
    return;
  }
  
  const cx = w / 2;
  const cy = h / 2;
  
  // –ë–∞–∑–æ–≤—ã–π –º–∞—Å—à—Ç–∞–± –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ 600px
  const scale = Math.min(w, h) / 600;
  
  // Top bar

  
  // DME –∏ Wind - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
  const margin = Math.max(10, w * 0.02);
  const topOffset = Math.max(40, h * 0.08);
  drawDME(ctx, margin, topOffset, data, scale);
  drawWindCompact(ctx, w - margin - 100 * scale, topOffset, data, scale);
  
  // Horizon - –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–º–µ—Ä
  const horizonSize = Math.min(w * 0.35, h * 0.4, 250 * scale);
  drawAttitudeFull(ctx, cx, cy, horizonSize, data, scale);
  
  // Speed tape - —Å–ª–µ–≤–∞
  const tapeWidth = Math.max(50, w * 0.11);
  const tapeHeight = Math.min(h * 0.5, 300 * scale);
  drawSpeedTapeFull(ctx, tapeWidth * 0.7, cy, tapeWidth * 0.75, tapeHeight, data, scale);
  
  // Altitude tape - —Å–ø—Ä–∞–≤–∞
  const altTapeWidth = Math.max(60, w * 0.13);
  drawAltitudeTapeFull(ctx, w - altTapeWidth * 1.2, cy, altTapeWidth * 0.7, tapeHeight, data, scale);
  
  // Vertical speed - –∫—Ä–∞–π–Ω—è—è –ø—Ä–∞–≤–∞—è
  const vsWidth = Math.max(25, w * 0.05);
  const vsHeight = Math.min(h * 0.4, 240 * scale);
  drawVerticalSpeedFull(ctx, w - vsWidth * 0.7, cy, vsWidth, vsHeight, data, scale);
  
  // Heading tape - –≤–Ω–∏–∑—É
  const headingY = h - Math.max(70, h * 0.14);
  const headingWidth = Math.min(w * 0.6, 420 * scale);
  const headingHeight = Math.max(50, h * 0.11);
  drawHeadingFull(ctx, cx, headingY, headingWidth, headingHeight, data, scale);
  
  // Radio altitude - –Ω–∞–¥ heading
  const raY = headingY - Math.max(25, h * 0.06);
  drawRadioHeight(ctx, cx, raY, data, scale);
  
  // Status - –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
  drawStatus(ctx, margin, h - margin - 10, data, scale);
}

function drawTopBar(ctx, w, data, scale = 1) {
  ctx.fillStyle = '#4a5568';
  ctx.fillRect(0, 0, w, 30 * scale);
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#10b981';
  ctx.fillText('SINGLE CH', w / 2, 20 * scale);
}

function drawDME(ctx, x, y, data, scale = 1) {
  const distNM = (data.distanceToThresholdNM || 0);
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e0e0e0';
  ctx.textAlign = 'left';
  ctx.fillText('DME', x, y);
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.fillStyle = '#10b981';
  ctx.fillText(distNM.toFixed(1), x, y + 18 * scale);
}

function drawWindCompact(ctx, x, y, data, scale = 1) {
  const windDir = data.windDirection || 0;
  const windSpd = Math.round(data.windSpeed || 0);
  const heading = data.heading || 0;
  
  if (windSpd < 1) return;
  
  let relativeDir = windDir - heading;
  while (relativeDir > 180) relativeDir -= 360;
  while (relativeDir < -180) relativeDir += 360;
  
  const arrowAngle = relativeDir;
  const arrowSize = 11 * scale;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate((arrowAngle * Math.PI) / 180);
  ctx.strokeStyle = '#0ea5e9';
  ctx.fillStyle = '#0ea5e9';
  ctx.lineWidth = 2 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -arrowSize);
  ctx.lineTo(0, arrowSize);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, arrowSize);
  ctx.lineTo(-4 * scale, arrowSize - 5 * scale);
  ctx.lineTo(4 * scale, arrowSize - 5 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  
  ctx.fillStyle = '#0ea5e9';
  ctx.font = `bold ${Math.round(12 * scale)}px monospace`;
  ctx.textAlign = 'left';
  const absDir = Math.round(windDir % 360);
  ctx.fillText(`${absDir.toString().padStart(3, '0')}/${windSpd}KT`, x + 16 * scale, y + 5 * scale);
}

function drawAttitudeFull(ctx, cx, cy, size, data, scale = 1) {
  const pitch = -data.pitch;
  const roll = data.roll;
  
  ctx.save();
  const r = size / 2;
  ctx.beginPath();
  ctx.rect(cx - r, cy - r, size, size);
  ctx.clip();
  
  ctx.translate(cx, cy);
  ctx.rotate((-roll * Math.PI) / 180);
  
  const pitchScale = 10 * scale;
  const offset = pitch * pitchScale;
  
  // Sky
  ctx.fillStyle = '#3b82f6';
  ctx.fillRect(-size, -size - offset, size * 2, size);
  
  // Ground
  ctx.fillStyle = '#92400e';
  ctx.fillRect(-size, -offset, size * 2, size);
  
  // Horizon line
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(-size, -offset);
  ctx.lineTo(size, -offset);
  ctx.stroke();
  
  // Pitch lines
  ctx.font = `bold ${Math.round(14 * scale)}px monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  
  // Major lines (10¬∞)
  for (let a = -30; a <= 30; a += 10) {
    if (a === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 65 * scale;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2.5 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
    
    const label = Math.abs(a).toString();
    ctx.fillText(label, -lineW - 22 * scale, y + 5 * scale);
    ctx.fillText(label, lineW + 22 * scale, y + 5 * scale);
  }
  
  // Medium lines (5¬∞)
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  for (let a = -30; a <= 30; a += 5) {
    if (a === 0 || a % 10 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 42 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  // Short lines (2.5¬∞)
  ctx.strokeStyle = '#aaaaaa';
  ctx.lineWidth = 1.5 * scale;
  for (let a = -30; a <= 30; a += 2.5) {
    if (a === 0 || a % 5 === 0) continue;
    const y = -offset - (a * pitchScale);
    const lineW = 25 * scale;
    ctx.beginPath();
    ctx.moveTo(-lineW, y);
    ctx.lineTo(lineW, y);
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Aircraft reference symbol
  ctx.strokeStyle = '#fbbf24';
  ctx.fillStyle = '#fbbf24';
  ctx.lineWidth = 4 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - 65 * scale, cy);
  ctx.lineTo(cx - 23 * scale, cy);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + 23 * scale, cy);
  ctx.lineTo(cx + 65 * scale, cy);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(cx, cy - 5 * scale);
  ctx.lineTo(cx - 8 * scale, cy + 6 * scale);
  ctx.lineTo(cx + 8 * scale, cy + 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(cx, cy, 3 * scale, 0, Math.PI * 2);
  ctx.fillStyle = '#000';
  ctx.fill();
  
  // Roll indicator
  drawRollIndicatorFull(ctx, cx, cy - r - 12 * scale, r * 0.92, roll, scale);
  
  // GS and LOC indicators
  drawGSIndicator(ctx, cx + r + 28 * scale, cy, size * 0.4, data.gsDeviation, scale);
  drawLOCIndicator(ctx, cx, cy + r + 28 * scale, size * 0.4, data.locDeviation, scale);
}

function drawRollIndicatorFull(ctx, cx, cy, radius, roll, scale = 1) {
  ctx.save();
  ctx.translate(cx, cy);
  ctx.strokeStyle = '#ffffff';
  ctx.fillStyle = '#ffffff';
  ctx.lineWidth = 2 * scale;
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  
  const marks = [
    { angle: -60, len: 13 * scale, label: '60' },
    { angle: -45, len: 13 * scale, label: '45' },
    { angle: -30, len: 13 * scale, label: '30' },
    { angle: -20, len: 8 * scale, label: null },
    { angle: -10, len: 8 * scale, label: '10' },
    { angle: 0, len: 13 * scale, label: '0' },
    { angle: 10, len: 8 * scale, label: '10' },
    { angle: 20, len: 8 * scale, label: null },
    { angle: 30, len: 13 * scale, label: '30' },
    { angle: 45, len: 13 * scale, label: '45' },
    { angle: 60, len: 13 * scale, label: '60' }
  ];
  
  marks.forEach(m => {
    const rad = (m.angle * Math.PI) / 180;
    const x1 = Math.sin(rad) * radius;
    const y1 = -Math.cos(rad) * radius;
    const x2 = Math.sin(rad) * (radius + m.len);
    const y2 = -Math.cos(rad) * (radius + m.len);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    
    if (m.label) {
      const labelRadius = radius + m.len + 11 * scale;
      const lx = Math.sin(rad) * labelRadius;
      const ly = -Math.cos(rad) * labelRadius;
      ctx.fillText(m.label, lx, ly + 4 * scale);
    }
  });
  
  // Roll pointer
  ctx.rotate((roll * Math.PI) / 180);
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(0, -radius);
  ctx.lineTo(-8 * scale, -radius - 13 * scale);
  ctx.lineTo(8 * scale, -radius - 13 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
  

  // Roll value text
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
  ctx.fillText(roll.toFixed(2) + '¬∞', cx, cy - radius + 18 * scale);
}

function drawGSIndicator(ctx, x, cy, height, gsDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(x, cy - height / 2);
  ctx.lineTo(x, cy + height / 2);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotY = cy + (i * height) / 5;
    ctx.beginPath();
    ctx.arc(x, dotY, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (gsDeviation !== null && gsDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, gsDeviation));
    const gy = cy + (clamped * height) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x - 8 * scale, gy);
    ctx.lineTo(x, gy - 6 * scale);
    ctx.lineTo(x + 8 * scale, gy);
    ctx.lineTo(x, gy + 6 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawLOCIndicator(ctx, cx, y, width, locDeviation, scale = 1) {
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx - width / 2, y);
  ctx.lineTo(cx + width / 2, y);
  ctx.stroke();
  
  ctx.fillStyle = '#94a3b8';
  for (let i = -2; i <= 2; i++) {
    const dotX = cx + (i * width) / 5;
    ctx.beginPath();
    ctx.arc(dotX, y, 2.5 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (locDeviation !== null && locDeviation !== undefined) {
    const clamped = Math.max(-2, Math.min(2, locDeviation));
    const lx = cx + (clamped * width) / 5;
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(lx, y - 8 * scale);
    ctx.lineTo(lx + 6 * scale, y);
    ctx.lineTo(lx, y + 8 * scale);
    ctx.lineTo(lx - 6 * scale, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
}

function drawSpeedTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const speed = data.airspeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Speed tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'right';
  const step = 20;
  const pixelsPerKnot = 3.5 * scale;
  
  for (let s = Math.floor((speed - step) / step) * step - 100; s <= speed + 100; s += step) {
    if (s < 40) continue;
    const sy = y - (s - speed) * pixelsPerKnot;
    if (sy < y - h / 2 || sy > y + h / 2) continue;
    
    ctx.strokeStyle = '#94a3b8';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(x + w / 2 - 16 * scale, sy);
    ctx.lineTo(x + w / 2, sy);
    ctx.stroke();
    ctx.fillText(s.toString(), x + w / 2 - 20 * scale, sy + 4 * scale);
  }
  ctx.restore();
  
  // Current speed box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(18 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(speed), x, y);
  ctx.textBaseline = 'alphabetic';
  
  // Ground speed
  const groundSpeed = data.groundSpeed || 0;
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(16 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const gsText = Math.round(groundSpeed).toString();
  ctx.strokeText(gsText, x, y + h / 2 + 15 * scale);
  ctx.fillText(gsText, x, y + h / 2 + 15 * scale);
  ctx.font = `${Math.round(10 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('GS', x, y + h / 2 + 26 * scale);
}

function drawAltitudeTapeFull(ctx, x, y, w, h, data, scale = 1) {
  const alt = data.altitude;
  const selectedAlt = 2000;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w / 2, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w / 2, y - h / 2, w, h);
  
  // Selected altitude
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(selectedAlt.toString(), x, y - h / 2 - 8 * scale);
  
  // Altitude tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(x - w / 2, y - h / 2, w, h);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  ctx.fillStyle = '#e5e7eb';
  ctx.textAlign = 'left';
  const step = 100;
  const pixelsPerFoot = 1.1 * scale;
  
  for (let a = Math.floor((alt - step) / step) * step - 1000; a <= alt + 1000; a += step) {
    if (a < 0) continue;
    const ay = y - (a - alt) * pixelsPerFoot;
    if (ay < y - h / 2 || ay > y + h / 2) continue;
    
    if (a % 200 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 16 * scale, ay);
      ctx.stroke();
      ctx.fillText(a.toString(), x - w / 2 + 19 * scale, ay + 4 * scale);
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 1 * scale;
      ctx.beginPath();
      ctx.moveTo(x - w / 2, ay);
      ctx.lineTo(x - w / 2 + 10 * scale, ay);
      ctx.stroke();
    }
  }
  ctx.restore();
  
  // Current altitude box - –†–ò–°–£–ï–¢–°–Ø –ü–û–í–ï–†–• –õ–ï–ù–¢–´
  const boxHeight = 36 * scale;
  const boxPadding = 3 * scale;
  ctx.fillStyle = '#000000';
  ctx.fillRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  ctx.strokeStyle = '#10b981';
  ctx.lineWidth = 2 * scale;
  ctx.strokeRect(x - w / 2 - boxPadding, y - boxHeight / 2, w + boxPadding * 2, boxHeight);
  
  ctx.fillStyle = '#10b981';
  ctx.font = `bold ${Math.round(17 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(Math.round(alt), x, y);
  ctx.textBaseline = 'alphabetic';
}

function drawVerticalSpeedFull(ctx, x, y, w, h, data, scale = 1) {
  const vs = data.verticalSpeed;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(x - w, y - h / 2, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(x - w, y - h / 2, w, h);
  
  const maxVS = 2000;
  const vsScale = h / (maxVS * 2);
  const clamped = Math.max(-maxVS, Math.min(maxVS, vs));
  const posY = y - clamped * vsScale;
  
  ctx.fillStyle = '#10b981';
  ctx.beginPath();
  ctx.moveTo(x - w + 3 * scale, posY);
  ctx.lineTo(x - 3 * scale, posY);
  ctx.lineTo(x - w / 2, posY - 6 * scale);
  ctx.closePath();
  ctx.fill();
  
  ctx.font = `${Math.round(9 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.textAlign = 'center';
  
  [-2, -1, 0, 1, 2].forEach(val => {
    const my = y - (val * 1000) * vsScale;
    if (my >= y - h / 2 && my <= y + h / 2) {
      ctx.fillText(val, x - w / 2, my + 3 * scale);
    }
  });
  
  // VS value
  ctx.fillStyle = '#10b981';
  ctx.strokeStyle = '#000';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.lineWidth = 2 * scale;
  const vsText = Math.round(vs).toString();
  ctx.strokeText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.fillText(vsText, x - w / 2, y + h / 2 + 14 * scale);
  ctx.font = `${Math.round(8 * scale)}px monospace`;
  ctx.fillStyle = '#94a3b8';
  ctx.fillText('FPM', x - w / 2, y + h / 2 + 24 * scale);
}

function drawHeadingFull(ctx, cx, y, w, h, data, scale = 1) {
  const hdg = data.heading;
  
  ctx.fillStyle = 'rgba(20,25,35,0.85)';
  ctx.fillRect(cx - w / 2, y, w, h);
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 1.5 * scale;
  ctx.strokeRect(cx - w / 2, y, w, h);
  
  // Selected heading
  ctx.fillStyle = '#e879f9';
  ctx.font = `bold ${Math.round(15 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(selectedHeading.toString().padStart(3, '0'), cx - w / 2 + 8 * scale, y + h - 8 * scale);
  
  // Current heading box
  const boxW = 75 * scale;
  const boxH = 28 * scale; // –£–≤–µ–ª–∏—á–µ–Ω–∞ –≤—ã—Å–æ—Ç–∞
  ctx.fillStyle = '#000';
  ctx.fillRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  ctx.strokeStyle = '#fbbf24';
  ctx.lineWidth = 2.5 * scale;
  ctx.strokeRect(cx - boxW / 2, y + 2 * scale, boxW, boxH);
  
  ctx.fillStyle = '#fbbf24';
  ctx.font = `bold ${Math.round(20 * scale)}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle'; // –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï - —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
  ctx.fillText(Math.round(hdg).toString().padStart(3, '0'), cx, y + 3 * scale + boxH / 2);
  ctx.textBaseline = 'alphabetic'; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ
  
  // Heading tape
  ctx.save();
  ctx.beginPath();
  ctx.rect(cx - w / 2, y + 20 * scale, w, h - 20 * scale);
  ctx.clip();
  
  ctx.font = `bold ${Math.round(13 * scale)}px monospace`;
  const pxPerDeg = 4.5 * scale;
  
  for (let a = 0; a < 360; a += 5) {
    let diff = hdg - a;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;
    
    const hx = cx - diff * pxPerDeg;
    if (hx < cx - w / 2 || hx > cx + w / 2) continue;
    
    if (a % 30 === 0) {
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1.5 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 18 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
      
      const labels = { 0: 'N', 90: 'E', 180: 'S', 270: 'W' };
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.fillText((labels[a] || (a / 10).toString()), hx, y + h - 21 * scale);
    } else if (a % 10 === 0) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1.2 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 11 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    } else {
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = 0.8 * scale;
      ctx.beginPath();
      ctx.moveTo(hx, y + h - 8 * scale);
      ctx.lineTo(hx, y + h);
      ctx.stroke();
    }
  }
  
  // Selected heading marker
  let diffSel = hdg - selectedHeading;
  if (diffSel > 180) diffSel -= 360;
  if (diffSel < -180) diffSel += 360;
  const selX = cx - diffSel * pxPerDeg;
  
  if (selX >= cx - w / 2 && selX <= cx + w / 2) {
    ctx.fillStyle = '#e879f9';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5 * scale;
    ctx.beginPath();
    ctx.moveTo(selX, y + 56 * scale);
    ctx.lineTo(selX - 8 * scale, y + 44 * scale);
    ctx.lineTo(selX + 8 * scale, y + 44 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  
  ctx.restore();
  
  // Current heading pointer
  ctx.fillStyle = '#fbbf24';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1.5 * scale;
  ctx.beginPath();
  ctx.moveTo(cx, y + 56 * scale);
  ctx.lineTo(cx - 8 * scale, y + 44 * scale);
  ctx.lineTo(cx + 8 * scale, y + 44 * scale);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}


function drawRadioHeight(ctx, x, y, data, scale = 1) {
  const radioAlt = Math.round(data.radioAltitude || 0);
  ctx.font = `bold ${Math.round(24 * scale)}px monospace`;
  ctx.fillStyle = '#fbbf24';
  ctx.textAlign = 'center';
  ctx.fillText(`RA ${radioAlt}`, x, y);
}

function drawStatus(ctx, x, y, d, scale = 1) {
  ctx.fillStyle = '#e5e7eb';
  ctx.font = `bold ${Math.round(11 * scale)}px monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(d.onGround ? 'GROUND' : 'AIRBORNE', x, y);
}

// ================================================================
// –ó–ê–ì–†–£–ó–ö–ê –ò –î–ê–ù–ù–´–ï
// ================================================================
function loadFile() {
  document.getElementById("file-input").click();
}
document.getElementById("file-input").addEventListener("change", handleFile);

function handleFile(e) {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById('loading').style.display = 'flex';
  const reader = new FileReader();

  reader.onload = (ev) => {
    try {
      const data = new Uint8Array(ev.target.result);
      const workbook = XLSX.read(data, {type: 'array'});
      const firstSheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[firstSheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet, {defval: null});

      if (jsonData.length === 0) {
        throw new Error("–§–∞–π–ª –ø—É—Å—Ç –∏–ª–∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã—Ö.");
      }

      const columns = Object.keys(jsonData[0]);
      console.log(`–ù–∞–π–¥–µ–Ω–æ —Å—Ç–æ–ª–±—Ü–æ–≤: ${columns.length}`);

      // 1. –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è: –ú–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ -> –û–±—ä–µ–∫—Ç –º–∞—Å—Å–∏–≤–æ–≤
      let processedData = {};
      columns.forEach(col => {
        processedData[col] = jsonData.map(row => row[col]);
      });

      // 2. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã
      let timeKey = columns.find(c => ['time', 'Time', 'TIME', '–í—Ä–µ–º—è'].includes(c));
      if (!timeKey) timeKey = columns[0];
      
      const timeArray = processedData[timeKey];
      if (!timeArray || timeArray.length === 0) throw new Error("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∏");

      const firstTime = timeArray[0];
      let count = 0;
      for (let i = 0; i < timeArray.length; i++) {
        if (timeArray[i] === firstTime) count++;
        else break;
      }
      const origHz = count || 1;
      console.log(`–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∏—Å—Ö–æ–¥–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞: ${origHz} –ì—Ü`);

      // 3. –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –í–´–°–û–¢–´
      const hcorKey = columns.find(c => c.startsWith('Hcor1') || c.startsWith('Hcor'));
      const vsKey = columns.find(c => ['Vy', 'VS', 'VerticalSpeed'].includes(c));
      const timeData = processedData[timeKey]; // –ú–∞—Å—Å–∏–≤ –≤—Ä–µ–º–µ–Ω–∏

      if (hcorKey && processedData[hcorKey]) {
          console.log(`–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã—Å–æ—Ç—ã ${hcorKey}...`);
          
          // –®–ê–ì 1: –§–∏–∑–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (—É–¥–∞–ª–µ–Ω–∏–µ –≤—ã–±—Ä–æ—Å–æ–≤ –ø—Ä–æ—Ç–∏–≤ —Ñ–∏–∑–∏–∫–∏)
          if (vsKey && processedData[vsKey]) {
              console.log(`–ü—Ä–∏–º–µ–Ω—è—é Smart VS Filter...`);
              processedData[hcorKey] = filterAltitudeByVS(
                  processedData[hcorKey], 
                  processedData[vsKey], 
                  timeData
              );
          }
          
          // –®–ê–ì 2: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å—Ç—É–ø–µ–Ω–µ–∫ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –º–æ–º–µ–Ω—Ç—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è)
          processedData[hcorKey] = filterRepeats(processedData[hcorKey]);
      }

      // 4. –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–ø—É—Å–∫–æ–≤
      columns.forEach(col => {
          if (col !== timeKey) {
              processedData[col] = fillGaps(processedData[col]);
          }
      });

      // 5. –†–µ—Å–µ–º–ø–ª–∏–Ω–≥ –¥–æ 32 –ì—Ü
      const targetHz = 32;
      let finalData = {}; 

      if (origHz === targetHz) {
          console.log(`–ß–∞—Å—Ç–æ—Ç–∞ —É–∂–µ ${targetHz} –ì—Ü, –∫–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ.`);
          columns.forEach(col => {
              if (col !== timeKey) {
                  finalData[`i.${col}`] = processedData[col];
              }
          });
      } else {
          console.log(`–†–µ—Å–µ–º–ø–ª–∏–Ω–≥ —Å ${origHz} –ì—Ü –¥–æ ${targetHz} –ì—Ü...`);
          columns.forEach(col => {
              if (col !== timeKey) {
                  const originalArray = processedData[col];
                  const sampleVal = originalArray.find(v => v !== null && v !== undefined);
                  const isNumeric = (typeof sampleVal === 'number');
                  finalData[`i.${col}`] = resampleArray(originalArray, origHz, targetHz, isNumeric);
              }
          });
      }

      // 6. –°–ë–û–†–ö–ê flightData
      const firstKey = Object.keys(finalData)[0];
      const length = finalData[firstKey].length;
      
      flightData = [];
      
      const getVal = (colName, idx) => {
          let key = `i.${colName}`;
          if (finalData[key]) return finalData[key][idx];
          const prefixKey = Object.keys(finalData).find(k => k.startsWith(`i.${colName}`));
          if (prefixKey) return finalData[prefixKey][idx];
          const suffixKey = Object.keys(finalData).find(k => k.endsWith(`.${colName}`));
          if (suffixKey) return finalData[suffixKey][idx];
          return 0;
      };
      
      const getValNullable = (colName, idx) => {
           let key = `i.${colName}`;
           if (finalData[key]) return finalData[key][idx];
           const prefixKey = Object.keys(finalData).find(k => k.startsWith(`i.${colName}`));
           if (prefixKey) return finalData[prefixKey][idx];
           const suffixKey = Object.keys(finalData).find(k => k.endsWith(`.${colName}`));
           if (suffixKey) return finalData[suffixKey][idx];
           return null;
      };

      for (let i = 0; i < length; i++) {
        const d = {};
        d.timestamp = i * (1000 / targetHz); 

        d.pitch = getVal('PITCH', i);
        if (d.pitch === 0) d.pitch = getVal('Pitch', i);

        d.roll = getVal('ROLL', i);
        if (d.roll === 0) d.roll = getVal('Roll', i);

        d.heading = getVal('HDN', i);
        if (d.heading === 0) d.heading = getVal('Heading', i);

        d.airspeed = getVal('Vcom', i);
        if (d.airspeed === 0) d.airspeed = getVal('IAS', i);

        d.verticalSpeed = getVal('Vy', i);
        if (d.verticalSpeed === 0) d.verticalSpeed = getVal('VS', i);

        d.radioAltitude = getVal('Hg', i);
        if (d.radioAltitude === 0) d.radioAltitude = getVal('RA', i);

        d.altitude = getVal('Hcor1', i);
        if (d.altitude === 0) d.altitude = getVal('Hcor', i);
        
        d.windSpeed = getVal('Vw', i);
        d.windDirection = getVal('Wdir', i);
        if (d.windDirection === 0) d.windDirection = getVal('Wdirr', i);

        d.locDeviation = getValNullable('LOCdev', i);
        d.gsDeviation = getValNullable('GSdev', i);
        
        d.distanceToThresholdNM = getValNullable('DMEl', i);
        if (d.distanceToThresholdNM === null) d.distanceToThresholdNM = getValNullable('DME', i);
        
        d.groundSpeed = getVal('Vgr', i);
        
        if (d.groundSpeed === 0 && d.windSpeed > 0 && d.airspeed > 0) {
            const hdgRad = (d.heading * Math.PI) / 180;
            const tasX = d.airspeed * Math.sin(hdgRad);
            const tasY = d.airspeed * Math.cos(hdgRad);
            const windRad = ((d.windDirection + 180) * Math.PI) / 180;
            const windX = d.windSpeed * Math.sin(windRad);
            const windY = d.windSpeed * Math.cos(windRad);
            d.groundSpeed = Math.sqrt(Math.pow(tasX + windX, 2) + Math.pow(tasY + windY, 2));
        }
        
        // –£–º–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ OnGround (—Å—Ç—Ä–æ–∫–∏/—á–∏—Å–ª–∞)
        let agVal = getVal('Air/Gr', i);
        if (!agVal) agVal = getVal('AirGr', i); 
        
        if (agVal && typeof agVal === 'string') {
            d.onGround = agVal.toLowerCase().includes('ground');
        } else {
             d.onGround = (agVal > 0.5);
        }

        flightData.push(d);
      }
      
      // –ü–û–ò–°–ö –ò –£–°–¢–ê–ù–û–í–ö–ê –ö–£–†–°–ê –ü–û–õ–û–°–´ (HDNsel –∏–ª–∏ –ê–≤—Ç–æ-—Ä–∞—Å—á–µ—Ç)
      // 1. –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —è–≤–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä HDNsel
      const hdnSelKey = Object.keys(finalData).find(k => k.includes('HDNsel') || k.includes('HDN.sel'));
      let foundHdn = false;
      
      if (hdnSelKey) {
          const val = finalData[hdnSelKey][0];
           if (val && val !== 0) {
              selectedHeading = Math.round(val);
              foundHdn = true;
           }
      }

      // 2. –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –≤—ã—á–∏—Å–ª—è–µ–º –ø–æ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏ –∑–∞—Ö–æ–¥–∞
      if (!foundHdn && flightData.length > 0) {
        console.log("Auto-detecting Runway Heading from final approach...");
        let touchdownIdx = flightData.findIndex(d => d.radioAltitude !== null && d.radioAltitude <= -4);
        if (touchdownIdx === -1) touchdownIdx = flightData.length - 1;
        
        const fps = 32;
        const endWindow = Math.max(0, touchdownIdx - 5 * fps);
        const startWindow = Math.max(0, touchdownIdx - 30 * fps);
        
        if (endWindow > startWindow) {
            let sinSum = 0;
            let cosSum = 0;
            let count = 0;
            
            for (let i = startWindow; i < endWindow; i++) {
                const d = flightData[i];
                if (d.groundSpeed > 50) {
                    let track = d.heading;
                    if (d.windSpeed > 0 && d.airspeed > 0) {
                       const hdgRad = (d.heading * Math.PI) / 180;
                       const windRad = ((d.windDirection + 180) * Math.PI) / 180;
                       const vAirX = d.airspeed * Math.sin(hdgRad);
                       const vAirY = d.airspeed * Math.cos(hdgRad);
                       const vWindX = d.windSpeed * Math.sin(windRad);
                       const vWindY = d.windSpeed * Math.cos(windRad);
                       track = (Math.atan2(vAirX + vWindX, vAirY + vWindY) * 180) / Math.PI;
                       if (track < 0) track += 360;
                    }
                    
                    const r = (track * Math.PI) / 180;
                    sinSum += Math.sin(r);
                    cosSum += Math.cos(r);
                    count++;
                }
            }
            
            if (count > 0) {
                const avgRad = Math.atan2(sinSum, cosSum);
                let avgDeg = (avgRad * 180) / Math.PI;
                if (avgDeg < 0) avgDeg += 360;
                selectedHeading = parseFloat(avgDeg.toFixed(2)); 
                console.log(`Detected RWY HDG: ${selectedHeading}¬∞ (based on ${count} samples)`);
            }
        }
      }
      
      // –û–±–Ω–æ–≤–ª—è–µ–º UI —Å –Ω–∞–π–¥–µ–Ω–Ω—ã–º –∫—É—Ä—Å–æ–º
      document.getElementById('input-hdg').value = selectedHeading;
      createRunwayNumber(-40); 

      calculateDistanceAndHeight();
      totalFrames = flightData.length;
      currentFrame = 0;
      enableControls();
      updateAllViews();
      console.log(`${totalFrames} –∫–∞–¥—Ä–æ–≤ (${(totalFrames/FPS).toFixed(1)}—Å)`);

    } catch (err) {
      console.error(err);
      alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ' + err.message);
    } finally {
      document.getElementById('loading').style.display = 'none';
    }
  };

  reader.readAsArrayBuffer(file);
}

<!-- function interpolateData(data) { -->
  <!-- if (data.length < 2) return data; -->
  <!-- const t0 = data[0].timestamp; -->
  <!-- const t1 = data[data.length - 1].timestamp; -->
  <!-- const total = t1 - t0; -->
  <!-- const frames = Math.ceil(total / FRAME_MS); -->
  <!-- const out = []; -->
  <!-- for (let i = 0; i < frames; i++) { -->
    <!-- const t = t0 + i * FRAME_MS; -->
    <!-- let j2 = data.findIndex(d => d.timestamp >= t); -->
    <!-- if (j2 === -1) { out.push({ ...data[data.length - 1], timestamp: t }); continue; } -->
    <!-- if (j2 === 0) { out.push({ ...data[0], timestamp: t }); continue; } -->
    <!-- const j1 = j2 - 1; -->
    <!-- const d1 = data[j1], d2 = data[j2]; -->
    <!-- const k = (t - d1.timestamp) / (d2.timestamp - d1.timestamp); -->
  
<!-- out.push({ -->
  <!-- timestamp: t, -->
  <!-- pitch: lerp(d1.pitch, d2.pitch, k), -->
  <!-- roll: lerp(d1.roll, d2.roll, k), -->
  <!-- heading: lerpAngle(d1.heading, d2.heading, k), -->
  <!-- airspeed: lerp(d1.airspeed, d2.airspeed, k), -->
  <!-- groundSpeed: lerp(d1.groundSpeed, d2.groundSpeed, k), -->
  <!-- verticalSpeed: lerp(d1.verticalSpeed, d2.verticalSpeed, k), -->
  <!-- locDeviation: mixOpt(d1.locDeviation, d2.locDeviation, k), -->
  <!-- gsDeviation: mixOpt(d1.gsDeviation, d2.gsDeviation, k), -->
  <!-- windSpeed: lerp(d1.windSpeed, d2.windSpeed, k), -->
  <!-- windDirection: lerpAngle(d1.windDirection, d2.windDirection, k), -->
  <!-- onGround: d1.onGround || d2.onGround, -->
  <!-- radioAltitude: lerp(d1.radioAltitude, d2.radioAltitude, k), -->
  <!-- altitude: lerp(d1.altitude || 0, d2.altitude || 0, k), -->
  <!-- distanceFromTouchdown: lerp(d1.distanceFromTouchdown || 0, d2.distanceFromTouchdown || 0, k), -->
  <!-- // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º DME, –µ—Å–ª–∏ –æ–±–∞ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ null -->
  <!-- distanceToThresholdNM: (d1.distanceToThresholdNM !== null && d2.distanceToThresholdNM !== null) -->
    <!-- ? lerp(d1.distanceToThresholdNM, d2.distanceToThresholdNM, k) -->
    <!-- : (d1.distanceToThresholdNM !== null ? d1.distanceToThresholdNM : d2.distanceToThresholdNM) -->
<!-- }); -->

  <!-- } -->
  <!-- return out; -->
<!-- } -->


    function calculateDistanceAndHeight() {
        if (flightData.length === 0) return;
        
        console.log("–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—á–µ—Ç (–ß–∏—Å—Ç–∞—è —Ñ–∏–∑–∏–∫–∞ + –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ RadioAlt)...");

        // 1. –ü–æ–∏—Å–∫ —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è (—Å—Ç—Ä–æ–≥–æ –ø–æ –≤—ã—Å–æ—Ç–µ < 1.5 —Ñ—É—Ç–∞)
        let touchdownIndex = flightData.findIndex(d => d.radioAltitude !== null && d.radioAltitude <= 4);
        
        // Fallback
        if (touchdownIndex === -1) {
             touchdownIndex = flightData.findIndex(d => d.onGround); // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        }
        
        let altitudeBias = 0;
        if (touchdownIndex === -1) {
            let minAlt = Infinity;
            flightData.forEach((d, i) => { 
                const ra = (d.radioAltitude !== null) ? d.radioAltitude : 9999;
                if (ra < minAlt) { minAlt = ra; touchdownIndex = i; } 
            });
            altitudeBias = flightData[touchdownIndex].altitude - (flightData[touchdownIndex].radioAltitude || 0);
        } else {
            altitudeBias = flightData[touchdownIndex].altitude;
        }

        // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –≤—ã—Å–æ—Ç—ã
        flightData.forEach(d => {
            d.correctedAltitude = d.altitude - altitudeBias;
        });

        // 2. –†–∞—Å—á–µ—Ç –≤–µ–∫—Ç–æ—Ä–æ–≤
flightData.forEach(d => {
            // –ë–∞–∑–æ–≤—ã–π —É–≥–æ–ª (–∫—É–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–æ—Å)
            let rawTrack = d.heading;
            
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º "–ò–¥–µ–∞–ª—å–Ω—ã–π –∞—ç—Ä–æ–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥—Ä–µ–π—Ñ" (–∫–∞–∫ –µ—Å–ª–∏ –±—ã –º—ã –ª–µ—Ç–µ–ª–∏)
            let aerodynamiDrift = 0;
            
            // –°—á–∏—Ç–∞–µ–º –¥—Ä–µ–π—Ñ, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å (–∑–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0)
            if (d.airspeed > 10 && d.windSpeed && d.windDirection) {
                 const hdgRad = (d.heading * Math.PI) / 180;
                 const windRad = ((d.windDirection + 180) * Math.PI) / 180;
                 
                 const vAirX = d.airspeed * Math.sin(hdgRad);
                 const vAirY = d.airspeed * Math.cos(hdgRad);
                 const vWindX = d.windSpeed * Math.sin(windRad);
                 const vWindY = d.windSpeed * Math.cos(windRad);
                 
                 // –í–µ–∫—Ç–æ—Ä –ø—É—Ç–µ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ (Air + Wind)
                 const vGroundX = vAirX + vWindX;
                 const vGroundY = vAirY + vWindY;
                 
                 let trackWithWind = (Math.atan2(vGroundX, vGroundY) * 180) / Math.PI;
                 if (trackWithWind < 0) trackWithWind += 360;
                 
                 // –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –¢—Ä–µ–∫–æ–º –∏ –ö—É—Ä—Å–æ–º = –£–≥–æ–ª —Å–Ω–æ—Å–∞
                 let diff = trackWithWind - d.heading;
                 if (diff > 180) diff -= 360;
                 if (diff < -180) diff += 360;
                 aerodynamiDrift = diff;
            }

            // === –ì–õ–ê–í–ù–ê–Ø –õ–û–ì–ò–ö–ê ===
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–ª—É –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è –≤–µ—Ç—Ä–∞ (Wind Effect Factor)
            let windFactor = 0;

            const isOnGroundReal = (d.radioAltitude !== null && d.radioAltitude <= -4.0);

            if (!isOnGroundReal) {
                // –í –í–û–ó–î–£–•–ï: –í–µ—Ç–µ—Ä –¥–µ–π—Å—Ç–≤—É–µ—Ç –Ω–∞ 100%
                windFactor = 1.0;
            } else {
                // –ù–ê –ó–ï–ú–õ–ï: –í–µ—Ç–µ—Ä –¥–µ–π—Å—Ç–≤—É–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏
                // > 130 —É–∑–ª–æ–≤ -> Factor 1.0 (–µ—â–µ –ª–µ—Ç–∏–º –Ω–∞–¥ –ø–æ–ª–æ—Å–æ–π/–∫–∞—Å–∞–Ω–∏–µ)
                // < 100 —É–∑–ª–æ–≤ -> Factor 0.0 (–µ–¥–µ–º –∫–∞–∫ —Ç—Ä–∞–º–≤–∞–π)
                // –ú–µ–∂–¥—É 100 –∏ 130 -> –ü–ª–∞–≤–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ
                
                const speed = d.airspeed; // –õ—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å groundSpeed –Ω–∞ –ø—Ä–æ–±–µ–≥–µ, –Ω–æ airspeed —Ç–æ–∂–µ –æ–∫
                
                // –í–µ—Ä—Ö–Ω–∏–π –ø–æ—Ä–æ–≥ (–≤–µ—Ç–µ—Ä 100%): –≤—ã—à–µ 130 —É–∑–ª–æ–≤
                const upperSpeed = 130;
                // –ù–∏–∂–Ω–∏–π –ø–æ—Ä–æ–≥ (–≤–µ—Ç–µ—Ä 0%): –Ω–∏–∂–µ 50 —É–∑–ª–æ–≤
                const lowerSpeed = 50; 
                
                if (speed >= upperSpeed) {
                    windFactor = 1.0;
                } else if (speed <= lowerSpeed) {
                    windFactor = 0.0;
                } else {
                    // –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –º–µ–∂–¥—É 50 –∏ 130
                    // –î–∏–∞–ø–∞–∑–æ–Ω = 130 - 50 = 80
                    windFactor = (speed - lowerSpeed) / (upperSpeed - lowerSpeed);
                }

            }
            
            // –ò—Ç–æ–≥–æ–≤—ã–π —É–≥–æ–ª —Å–Ω–æ—Å–∞
            const finalDrift = aerodynamiDrift * windFactor;
            
            // –ò—Ç–æ–≥–æ–≤—ã–π Track
            rawTrack = d.heading + finalDrift;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è 0-360
            if (rawTrack >= 360) rawTrack -= 360;
            if (rawTrack < 0) rawTrack += 360;

            d.targetTrack = rawTrack;
            // –î–ª—è –∏–Ω–µ—Ä—Ü–∏–∏ —Å—á–∏—Ç–∞–µ–º "–∑–µ–º–ª–µ–π" —Ç–æ–ª—å–∫–æ –ø–æ–ª–Ω–æ–µ —Å—Ü–µ–ø–ª–µ–Ω–∏–µ (—Ñ–∞–∫—Ç–æ—Ä < 0.5)
            d.isCalculatedGround = (windFactor < 0.5); 
        });

        // 3. –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ (–ò–Ω–µ—Ä—Ü–∏—è 60 —Ç–æ–Ω–Ω)
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–≤—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º
        let currentVecX = Math.sin(flightData[0].targetTrack * Math.PI / 180);
        let currentVecY = Math.cos(flightData[0].targetTrack * Math.PI / 180);
        
        const inertiaFactor = 0; // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø–ª–∞–≤–Ω–æ—Å—Ç–∏

        for (let i = 0; i < flightData.length; i++) {
            const d = flightData[i];
            
            // –ù–∞ –∑–µ–º–ª–µ –∏–Ω–µ—Ä—Ü–∏—è —á—É—Ç—å –º–µ–Ω—å—à–µ (—Å—Ü–µ–ø–ª–µ–Ω–∏–µ –ª—É—á—à–µ), –≤ –≤–æ–∑–¥—É—Ö–µ –±–æ–ª—å—à–µ
            const effectiveInertia = d.isCalculatedGround ? 0.2 : inertiaFactor;

            const targetRad = d.targetTrack * Math.PI / 180;
            const targetX = Math.sin(targetRad);
            const targetY = Math.cos(targetRad);
            
            // –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞
            currentVecX += (targetX - currentVecX) * effectiveInertia;
            currentVecY += (targetY - currentVecY) * effectiveInertia;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
            const len = Math.sqrt(currentVecX**2 + currentVecY**2);
            currentVecX /= len;
            currentVecY /= len;
            
            let smoothedTrack = (Math.atan2(currentVecX, currentVecY) * 180) / Math.PI;
            if (smoothedTrack < 0) smoothedTrack += 360;
            
            d.smoothedTrack = smoothedTrack;
        }

        // 4. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ø–æ–∑–∏—Ü–∏–∏
        flightData[touchdownIndex].xPos = 0; 
        flightData[touchdownIndex].zPos = 0; 
        flightData[touchdownIndex].distanceFromTouchdown = 0;

        const calculateStep = (dataPoint, dtSeconds) => {
            const gsMps = (dataPoint.groundSpeed || 0) * 0.514444; 
            let trackToUse = dataPoint.smoothedTrack;

            let trackDelta = trackToUse - selectedHeading;
            const trackRad = (trackDelta * Math.PI) / 180;
            
            const distStep = gsMps * dtSeconds;
            
            return {
                dX: distStep * Math.sin(trackRad),
                dZ: distStep * Math.cos(trackRad)
            };
        };

        // –ù–ê–ó–ê–î (–≤–∞—à–∏ –∑–Ω–∞–∫–∏ +)
        for (let i = touchdownIndex - 1; i >= 0; i--) {
            const curr = flightData[i];
            const next = flightData[i+1];
            const dt = (next.timestamp - curr.timestamp) / 1000;
            const step = calculateStep(curr, dt);
            
            curr.xPos = next.xPos + step.dX; 
            curr.zPos = next.zPos + step.dZ; 
            curr.distanceFromTouchdown = curr.zPos * 3.28084;
        }

        // –í–ü–ï–†–ï–î (–≤–∞—à–∏ –∑–Ω–∞–∫–∏ -)
        for (let i = touchdownIndex + 1; i < flightData.length; i++) {
            const curr = flightData[i];
            const prev = flightData[i-1];
            const dt = (curr.timestamp - prev.timestamp) / 1000;
            const step = calculateStep(prev, dt);
            
            curr.xPos = prev.xPos - step.dX;
            curr.zPos = prev.zPos - step.dZ;
            curr.distanceFromTouchdown = curr.zPos * 3.28084;
        }
        
        flightData.forEach(d => {
            const distToThrMeters = d.zPos - 300; 
            d.distanceToThresholdNM = distToThrMeters / 1852;
        });
        
        pathMeta.totalDistanceNM = Math.max(...flightData.map(d => d.distanceToThresholdNM));
    }



function lerp(a, b, t) { return a + (b - a) * t; }
function lerpAngle(a, b, t) {
  let diff = b - a;
  if (diff > 180) diff -= 360;
  if (diff < -180) diff += 360;
  return (a + diff * t + 360) % 360;
}
function mixOpt(a, b, t) {
  if (a != null && b != null) return lerp(a, b, t);
  return a != null ? a : b;
}

// ================================================================
// –í–û–°–ü–†–û–ò–ó–í–ï–î–ï–ù–ò–ï
// ================================================================
function enableControls() {
  ["btn-play","btn-stop","btn-b10","btn-b1","btn-f1","btn-f10"].forEach(id=>{
    document.getElementById(id).disabled = false;
  });
  document.getElementById("timeline").disabled = false;
}
function togglePlay() { isPlaying ? pause() : play(); }

function play() {
  if (!flightData.length) return;

  isPlaying = true;
  document.getElementById("btn-play").textContent = "‚è∏ Pause";

  if (timerId) clearInterval(timerId);
  timerId = setInterval(() => {
    currentFrame += playbackSpeed;
    currentFrame = Math.round(currentFrame);

    if (currentFrame >= totalFrames) {
      currentFrame = totalFrames - 1;
      pause();
    }

    updateAllViews();
  }, FRAME_MS);
}
function pause() {
  isPlaying = false;
  document.getElementById("btn-play").textContent = "‚ñ∂Ô∏è Play";
  if (timerId) { clearInterval(timerId); timerId = null; }
}
function stopPlayback() {
  pause();
  currentFrame = 0;
  pathPoints = []; // –û—á–∏—Å—Ç–∫–∞ –ø—É—Ç–∏
  if (pathLine) {
    scene.remove(pathLine);
    pathLine = null;
  }
  updateAllViews();
}
function skipTime(sec) {
  if (!flightData.length) return;
  const frames = sec * FPS;
  currentFrame = Math.max(0, Math.min(totalFrames - 1, currentFrame + frames));
  updateAllViews();
}
function setSpeed(s) {
  playbackSpeed = s;
  document.querySelectorAll(".control-group button").forEach(b => b.classList.remove("active"));
  event.target.classList.add("active");
}

function initTimeline() {
  const tl = document.getElementById("timeline");
  tl.addEventListener("input", (e) => {
    if (!flightData.length) return;
    const v = parseFloat(e.target.value) / 100;
    currentFrame = Math.floor(v * (totalFrames - 1));
    updateAllViews();
  });
}

function updateTimelineLabel() {
  const label = document.getElementById('time-label');
  if (!flightData.length) {
    label.textContent = '00:00 / 00:00';
    return;
  }
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∏–∑ –¥–∞–Ω–Ω—ã—Ö
  const curTimeMs = flightData[currentFrame].timestamp;
  const totTimeMs = flightData[flightData.length - 1].timestamp;
  
  const fmt = (ms) => {
    const totalSec = Math.floor(ms / 1000);
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  };
  
  label.textContent = `${fmt(curTimeMs)} / ${fmt(totTimeMs)}`;
  
  const tl = document.getElementById('timeline');
  if (tl) {
    tl.value = (currentFrame / (totalFrames - 1)) * 100;
  }
}

// ================================================================
// –û–ë–ù–û–í–õ–ï–ù–ò–ï –í–°–ï–• –í–ò–î–û–í
// ================================================================
function updateAllViews() {
  if (!flightData.length) return;
  const d = flightData[currentFrame];
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –≤–∏–¥—ã
  drawPFD(d);
  update3D(d);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–ª–∞–π–Ω
  const tl = document.getElementById("timeline");
  if (tl && !tl.matches(':active')) {
    tl.value = (currentFrame / totalFrames) * 100;
  }
    updateTimelineLabel();
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
  const timeEl = document.getElementById("current-time");
  if (timeEl) {
    const sec = currentFrame / FPS;
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    timeEl.textContent = `${m}:${s.toString().padStart(2, '0')}`;
  }
updateDebugPanel()
}

function initSelectedHeading() {
  const input = document.getElementById('input-hdg');
  input.step = "0.01"; 

  input.addEventListener('change', (e) => {
    const val = parseFloat(e.target.value);
    if (!isNaN(val)) {
      console.log(`New Runway Heading set: ${val}`);
      selectedHeading = val; // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
      
      // –ò–°–ü–û–õ–¨–ó–£–ï–ú createRunwayNumber, –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–±–æ—Ç–∞–µ—Ç
      createRunwayNumber(-40);
      
      // –ü–µ—Ä–µ—Å—á–µ—Ç —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏
      calculateDistanceAndHeight(); 
      updatePath();
      updateAllViews(); 
    }
  });
}

function updateRunwayNumber() {
  // 1. –í—ã—á–∏—Å–ª—è–µ–º —Ü–∏—Ñ—Ä—É –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ selectedHeading
  // –ï—Å–ª–∏ heading 0 (–Ω–µ –∑–∞–¥–∞–Ω), —Ä–∏—Å—É–µ–º –¥–µ—Ñ–æ–ª—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä 36 –∏–ª–∏ –ø—É—Å—Ç–æ–π)
  let headingToUse = selectedHeading || 260; // –î–µ—Ñ–æ–ª—Ç 260 (26), –µ—Å–ª–∏ 0
  let numberMesh;
  let num = Math.round(headingToUse / 10);
  if (num === 0) num = 36; 
  if (num > 36) num -= 36; // –ù–∞ —Å–ª—É—á–∞–π —Å—Ç—Ä–∞–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π > 360
  
  const text = num.toString().padStart(2, '0');
  console.log(`Updating Runway Number to: ${text} (Hdg: ${headingToUse})`);

  // 2. –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –º–µ—à
  if (numberMesh) {
    scene.remove(numberMesh);
    if (numberMesh.material.map) numberMesh.material.map.dispose();
    if (numberMesh.material) numberMesh.material.dispose();
    if (numberMesh.geometry) numberMesh.geometry.dispose();
  }

  // 3. –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = 'rgba(0,0,0,0)'; 
  ctx.clearRect(0, 0, 256, 256);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 140px Arial'; // –ß—É—Ç—å –º–µ–Ω—å—à–µ, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –≤–ª–µ–∑–∞–ª–æ
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // –ü–æ–≤–æ—Ä–æ—Ç —Ü–∏—Ñ—Ä—ã (—á—Ç–æ–±—ã —á–∏—Ç–∞–ª–∞—Å—å –ø—Ä–∏ –ø–æ–¥–ª–µ—Ç–µ)
  ctx.translate(128, 128);
  ctx.rotate(-Math.PI / 2); 
  ctx.fillText(text, 0, 0);

  const tex = new THREE.CanvasTexture(canvas);
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

  const geom = new THREE.PlaneGeometry(12, 12);
  const mat = new THREE.MeshBasicMaterial({ 
    map: tex, 
    transparent: true,
    opacity: 0.9
  });
  
  numberMesh = new THREE.Mesh(geom, mat);
  numberMesh.rotation.x = -Math.PI / 2;
  
  // 4. –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
  numberMesh.position.set(0, 0.05, -40); // Z = -40
  numberMesh.renderOrder = 3;

  scene.add(numberMesh);
}

function roundTo4(num) {
    if (typeof num !== 'number') return num;
    return Math.round(num * 10000) / 10000;
}

function filterRepeats(arr) {
    if (!arr || arr.length === 0) return arr;
    const newArr = [...arr];
    let lastUniqueVal = null; 
    for (let i = 0; i < newArr.length; i++) {
        const val = newArr[i];
        if (val === null || val === undefined) continue;
        if (i === 0) {
            lastUniqueVal = val;
            continue;
        }
        if (val === lastUniqueVal) {
            newArr[i] = null;
        } else {
            lastUniqueVal = val;
        }
    }
    return newArr;
}

function fillGaps(arr) {
    const newArr = [...arr];
    const len = newArr.length;
    for (let i = 0; i < len; i++) {
        if (newArr[i] === null || newArr[i] === undefined) {
            let prevIdx = i - 1;
            while (prevIdx >= 0 && (newArr[prevIdx] === null || newArr[prevIdx] === undefined)) prevIdx--;
            let nextIdx = i + 1;
            while (nextIdx < len && (newArr[nextIdx] === null || newArr[nextIdx] === undefined)) nextIdx++;
            const prevVal = (prevIdx >= 0) ? newArr[prevIdx] : null;
            const nextVal = (nextIdx < len) ? newArr[nextIdx] : null;
            if (prevVal !== null && nextVal !== null && typeof prevVal === 'number' && typeof nextVal === 'number') {
                const totalSteps = nextIdx - prevIdx;
                const stepVal = (nextVal - prevVal) / totalSteps;
                const currentStep = i - prevIdx;
                newArr[i] = roundTo4(prevVal + (stepVal * currentStep));
            } else if (prevVal === null && nextVal !== null) {
                newArr[i] = nextVal;
            } else if (prevVal !== null && nextVal === null) {
                newArr[i] = prevVal;
            }
        }
    }
    return newArr;
}

function resampleArray(data, srcFreq, destFreq, isNumeric) {
    const ratio = destFreq / srcFreq;
    const srcLen = data.length;
    const destLen = Math.floor(srcLen * ratio);
    const result = new Array(destLen);
    for (let i = 0; i < destLen; i++) {
        const srcIndex = i / ratio;
        const p0 = Math.floor(srcIndex);
        const p1 = Math.min(p0 + 1, srcLen - 1);
        const t = srcIndex - p0;
        const val0 = data[p0];
        const val1 = data[p1];
        if (isNumeric) {
            const v0 = (val0 !== null && val0 !== undefined) ? val0 : 0;
            const v1 = (val1 !== null && val1 !== undefined) ? val1 : 0;
            result[i] = roundTo4(v0 + (v1 - v0) * t);
        } else {
            result[i] = val0;
        }
    }
    return result;
}

/**
 * –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –≤—ã—Å–æ—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏.
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: –µ—Å–ª–∏ –æ–Ω–æ —Å–∏–ª—å–Ω–æ –æ—Ç–∫–ª–æ–Ω—è–µ—Ç—Å—è –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ (Alt_prev + VS*dt),
 * –æ–Ω–æ –ø–æ–º–µ—á–∞–µ—Ç—Å—è –∫–∞–∫ null.
 */
function filterAltitudeByVS(altArray, vsArray, timeArray) {
    if (!altArray || !vsArray || !timeArray) return altArray;
    
    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é
    const cleanAlt = [...altArray];
    const len = cleanAlt.length;
    
    // –ò—â–µ–º –ø–µ—Ä–≤–æ–µ –≤–∞–ª–∏–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    let lastValidIdx = cleanAlt.findIndex(v => v !== null && v !== undefined);
    if (lastValidIdx === -1) return cleanAlt;
    
    // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º—É –º–∞—Å—Å–∏–≤—É
    for (let i = lastValidIdx + 1; i < len; i++) {
        const currAlt = cleanAlt[i];
        
        // –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if (currAlt === null || currAlt === undefined) continue;
        
        // –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞
        const prevAlt = cleanAlt[lastValidIdx];
        const dt = (timeArray[i] - timeArray[lastValidIdx]) / 1000; // —Å–µ–∫
        
        // –ë–µ—Ä–µ–º VS –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞ (–∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤–∞–ª–∏–¥–Ω–æ–≥–æ, –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π –ø—É—Å—Ç)
        // –ï—Å–ª–∏ VS –Ω–µ—Ç, —Å—á–∏—Ç–∞–µ–º 0
        let vs = vsArray[i];
        if (vs === null || vs === undefined) vs = vsArray[lastValidIdx] || 0;
        
        // –ü—Ä–æ–≥–Ω–æ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—ã—Å–æ—Ç—ã: (ft/min / 60) * sec
        const predictedDelta = (vs / 60) * dt;
        const predictedAlt = prevAlt + predictedDelta;
        
        // –î–æ–ø—É—Å—Ç–∏–º–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ.
        // –£ Hcor1 —à–∞–≥ 32 —Ñ—É—Ç–∞. –ü–ª—é—Å —à—É–º. –ü–ª—é—Å –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç—å VS.
        // –†–∞–∑—Ä–µ—à–∞–µ–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –Ω–∞ 64 —Ñ—É—Ç–∞ (2 —à–∞–≥–∞ –∫–≤–∞–Ω—Ç–æ–≤–∞–Ω–∏—è) + 50% –æ—Ç —Ä–∞—Å—á–µ—Ç–Ω–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        const margin = 64 + Math.abs(predictedDelta * 0.5);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞: –ù–∞—Å–∫–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞?
        // –û—Å–æ–±—ã–π —Å–ª—É—á–∞–π: –ï—Å–ª–∏ VS –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è (—Å–Ω–∏–∂–µ–Ω–∏–µ), –∞ –≤—ã—Å–æ—Ç–∞ –í–´–†–û–°–õ–ê -> —ç—Ç–æ —è–≤–Ω–∞—è –æ—à–∏–±–∫–∞ (–µ—Å–ª–∏ —Ä–æ—Å—Ç > 10 —Ñ—É—Ç–æ–≤)
        // –ù–æ —É—á–∏—Ç—ã–≤–∞–µ–º, —á—Ç–æ –ø—Ä–∏ VS ~ 0 –º–æ–∂–µ—Ç –±—ã—Ç—å —à—É–º.
        
        let isValid = true;
        
        if (vs < -100 && (currAlt - prevAlt) > 10) {
            // –Ø–≤–Ω–æ–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–µ: —Å–Ω–∏–∂–µ–Ω–∏–µ > 100fpm, –∞ –≤—ã—Å–æ—Ç–∞ –≤—ã—Ä–æ—Å–ª–∞
            isValid = false;
            // console.log(`Anomaly at ${i}: Climbing while descending. Prev: ${prevAlt}, Curr: ${currAlt}, VS: ${vs}`);
        } else if (Math.abs(currAlt - predictedAlt) > margin) {
            // –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞
            isValid = false;
        }
        
        if (isValid) {
            lastValidIdx = i; // –¢–æ—á–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞, —Ç–µ–ø–µ—Ä—å –æ—Ç—Å—á–∏—Ç—ã–≤–∞–µ–º –æ—Ç –Ω–µ—ë
        } else {
            cleanAlt[i] = null; // –£–¥–∞–ª—è–µ–º –≤—ã–±—Ä–æ—Å
        }
    }
    
    return cleanAlt;
}

// ================================================================
// DEBUG –§–£–ù–ö–¶–ò–ò 
// ================================================================

let isDebugVisible = false;

function toggleDebug() {
  isDebugVisible = !isDebugVisible;
  const panel = document.getElementById('debug-panel');
  const btn = document.getElementById('btn-debug');
  
  if (!panel) return;

  if (isDebugVisible) {
    panel.style.display = 'flex';
    if (btn) btn.classList.add('active');
    updateDebugPanel(); // –°—Ä–∞–∑—É –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
  } else {
    panel.style.display = 'none';
    if (btn) btn.classList.remove('active');
  }
}

function updateDebugPanel() {
  // –ü—Ä–æ–≤–µ—Ä–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
  if (!isDebugVisible) return;
  if (!flightData || flightData.length === 0) return;
  const content = document.getElementById('debug-content');
  if (!content) return;

  const d = flightData[currentFrame];
  if (!d) return;

  // 1. –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–ª—é—á–∏ –æ–±—ä–µ–∫—Ç–∞ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
  const keys = Object.keys(d).sort();

  let html = '';

  // 2. –ü—Ä–æ—Ö–æ–¥–∏–º—Å—è –ø–æ –≤—Å–µ–º –∫–ª—é—á–∞–º
  keys.forEach(key => {
    const rawVal = d[key];
    let displayVal = rawVal;
    let valClass = 'debug-val';

    // 3. –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
    if (rawVal === null || rawVal === undefined) {
      displayVal = 'null';
      valClass += ' null'; // –ö—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç
    } 
    else if (typeof rawVal === 'boolean') {
      displayVal = rawVal ? 'TRUE' : 'FALSE';
    } 
    else if (typeof rawVal === 'number') {
      // –ï—Å–ª–∏ —ç—Ç–æ timestamp, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å –∏–ª–∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–µ–∫—É–Ω–¥—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
      if (key === 'timestamp') {
         displayVal = (rawVal / 1000).toFixed(2) + ' s';
      } else {
         // –û–∫—Ä—É–≥–ª—è–µ–º –¥—Ä–æ–±–Ω—ã–µ –¥–æ 4 –∑–Ω–∞–∫–æ–≤, —Ü–µ–ª—ã–µ –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
         displayVal = Number.isInteger(rawVal) ? rawVal : parseFloat(rawVal.toFixed(4));
      }
    }

    html += `
      <div class="debug-row">
        <span class="debug-key">${key}</span>
        <span class="${valClass}">${displayVal}</span>
      </div>
    `;
  });
  
  content.innerHTML = html;
}



</script>
</body>
</html>
